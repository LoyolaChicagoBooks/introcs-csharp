% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Introductory Programming in C\#}
\date{February 19, 2012}
\release{1.0}
\author{Andrew N. Harrington and George K. Thiruvathukal}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Context}
\label{context:introductory-programming-in-c}\label{context::doc}\label{context:context}

\section{Introduction to the Notes}
\label{intro::doc}\label{intro:introduction-to-the-notes}
These notes are designed for Comp 170.  They are closely tied to the
excellent C\# introduction in Rob Miles' free online
\href{http://www.robmiles.com/c-yellow-book/Rob\%20Miles\%20CSharp\%20Yellow\%20Book\%202011.pdf}{C\# Yellow Book}.

These notes will follow mostly the same order, adding some extra explanations, examples,
and challenges, and introduce the Mono open source implementation of C\#.

The content here will be interspersed with comments about where to look at parts of Miles book,
with clarifications of the book and comments about what is not important for a
beginner in the book.

Computer programs are designed to run on a computer and solve problems.
Though the initial problems will be tiny and often silly, they will serve as learning tools
to prepare for substantive problems.


\section{Comments on Miles Chapter 1}
\label{milesintro:comments-on-miles-chapter-1}\label{milesintro::doc}
Miles Chapter 1 on Computers and Programs makes a good introduction and gives context.
\emph{Read} for the grounding it gives.

The chapter makes some reference to Microsoft,
the original creator of C\#, and its
Visual Studio software development environment, which works only on Windows machines,
and costs a lot if you are not a student.
The optional text by Lewis discussed Visual Studio at some length.
The next section of these notes will introduce an alternative to the
Microsoft environment: Mono, which is free,
open-source software that makes C\# available for multiple platforms:
Windows, Mac, or Linux machines.


\chapter{C\# Data and Operations}
\label{data::doc}\label{data:c-data-and-operations}

\section{Development Tools}
\label{monotools:development-tools}\label{monotools::doc}

\subsection{About Software Development Kits (SDKs)}
\label{monotools:about-software-development-kits-sdks}
A software development kit (SDK) is a set of tools for developing in a
particular programming language (in our class, C\#). Developing in a
language means everything from compiling to running and (when things
go wrong) to debugging programs.

The Microsoft SDK is the proprietary implementation of .Net. It runs
only on Windows and is the primary development framework for all
things Microsoft.

The Mono Project SDK \textless{}\href{http://mono-project.com}{http://mono-project.com}\textgreater{} is the free/open source
equivalent implementation of the Microsoft SDK. It runs on all major platforms (including Windows) and is needed in situations where you want to develop .Net applications on non-Windows platforms.

As an interesting aside, the company whose developers lead the work on
the Mono SDK are working on commercial tools that allow you to
develop/run applications written in .Net on Apple iOS and Android
mobile devices (phones and tablets).


\subsection{About Integrated Development Environments (IDE)}
\label{monotools:about-integrated-development-environments-ide}
While just about everything you need to create programs can, indeed,
be found in the SDK, it is not long before you wish there were an ``app
for that'' so to speak. While most programmers who developed code (like
your instructors) in the 1970s-1990s learned to program directly with
the SDK using the \emph{command line}, today's programmers largely to
prefer working in an IDE.

There are two major IDEs for .Net development, which we explain briefly below:
\begin{itemize}
\item {} 
Visual Studio is the Microsoft IDE that interfaces directly to the
Microsoft SDK.

\item {} 
MonoDevelop is the free/open source IDE for developing applications
using the Mono SDK on Windows and all other platforms (in
particular, Linux and OS X).

\end{itemize}

In addition, there is another Windows-specific IDE, SharpDevelop, that
inspired the creation of MonoDevelop. It is still actively maintained
and provides a somewhat ``lighter weight'' alternative to Visual Studio
for Windows users. Like MonoDevelop, it is aimed at developers who
would prefer a more free/open source ``friendly'' version.


\subsection{Our Approach}
\label{monotools:our-approach}
In the interest of providing a consistent experience for our students,
we will be using Mono (the SDK) and MonoDevelop (the IDE) for
everything we demonstrate in class. We will also be encouraging you to
use it for your work, especially if you are interested in
non-Microsoft platforms.

Our notes assume for the most part that you are working with Mono and
MonoDevelop. In most cases, what we are showing you in Mono and
MonoDevelop will translate almost \emph{as is} to the Microsoft
equivalents. However, there are some tools, such as the \code{csharp}
interpreter, that have a rough analog in Microsoft's tools but in a somewhat
limited form. As there is significant evolution of both the Microsoft
and Mono \emph{toolchains}--a fancy word we want you to know and a more
elegant way of saying SDK--we'll issue updates to these notes.


\subsection{Installing Mono}
\label{monotools:installing-mono}
Because the Mono Project web page is known to change frequently, these
instructions are designed to be as generic as possible. If you have
any questions, you should contact the intructors immediately or seek
tutoring help.


\subsection{OS X}
\label{monotools:os-x}\begin{enumerate}
\item {} 
Go to \textless{}\href{http://mono-project.com}{http://mono-project.com}\textgreater{}.

\item {} 
Look for the Mono downloads link. You want to get the latest \emph{stable}
version of Mono for OS X. For this class, you need version 2.10 or
later.

\item {} 
You may see a link to download \emph{Runtime} or \emph{SDK}. Make sure you select SDK.

\item {} 
For OS X, the SDK is distributed as a DMG disk image. You'll need
to download this image and double-click it. Open the image and run
the installer. Administrative privileges are required to run the
installer, so if you do not know this information, please stop
here.

\item {} 
Once installation is completed, you have everything needed to start
using the IDE, MonoDevelop.

\item {} 
Now go to \textless{}\href{http://mono-develop.com}{http://mono-develop.com}\textgreater{}.

\item {} 
As with Mono, we need to look for the downloads link.
You should download the \emph{stable} version.

\item {} 
As with Mono, you will see a DMG file,
which you should download and double-click to mount on your desktop.

\item {} 
This time, you will see an App for MonoDevelop,
which you can drag and drop into the Applications foldeer.

\end{enumerate}

Here is how to do a quick sanity check of your Mono setup:
\begin{enumerate}
\item {} 
Go to Applications -\textgreater{} Utilities and launch the Terminal
application. (Terminal is how you get to a command-line shell in OS X.)

\item {} 
You'll see a prompt that looks like this
\code{computername:folder user\$}.
This means that Terminal is ready for input.

\item {} 
Type \code{which csharp} and hit enter/return. You should see
\code{/usr/bin/csharp} as output. \code{csharp} is the C\# interpreter.

\item {} 
Type \code{which dmcs} and hit enter/return. You should see
\code{/usr/bin/dmcs} as output.  \code{dmcs} is one of the interfaces to
the C\# compiler.

\item {} 
If the two preceding steps were successful, you can launch
MonoDevelop by double-clicking the icon in your Applications
folder. (You won't know what to do with it yet, but at least you can
verify that it launches correctly and then use Command-Q to exit.)

\end{enumerate}


\subsection{Windows}
\label{monotools:windows}\begin{enumerate}
\item {} 
Go to \textless{}\href{http://mono-project.com}{http://mono-project.com}\textgreater{}.

\item {} 
Look for the Mono downloads link. You want to get the latest
\emph{stable} version of Mono for Windows. For this class, you need version
2.10 or later.

\item {} 
You may see a link to download \emph{Runtime} or \emph{SDK}. Make sure you select SDK.

\item {} 
For Windows, there is only one option to download the SDK. It is a
self-extracting executable, so you will need to double click it to
install. For Vista and 7 users, you may need to check your taskbar to
see whether the installer is being held up by Microsoft's enhanced
security, UAM, that makes sure you really want to install something
you downloaded from the internet.

\item {} 
Once installation is completed, you have everything needed to start
using the IDE, MonoDevelop.

\item {} 
Now go to \textless{}\href{http://mono-develop.com}{http://mono-develop.com}\textgreater{}.

\item {} 
As with Mono, we need to look for the downloads link. You should
download the \emph{stable} version.

\item {} 
As with Mono, you will see a self-extracting installer,
which you should run as before.

\end{enumerate}

Here is how to do a quick sanity check of your Mono setup:
\begin{enumerate}
\item {} 
Open the Start Menu and type ``mono'' in the text field at the bottom.
You should see a short list places ``mono'' appears.

\item {} 
Click on the choice that says ``Mono 2.10... Command prompt''.
If it comes up, you are all set.
Close the window, or save it for later use....
You can also find the program in the Start Menu manually,
finding the Mono folder, expanding it, and clicking on{]}
the Mono Command Prompt.

\item {} 
If the two preceding steps were successful, you can launch
MonoDevelop by double-clicking the icon in your Applications
folder. (You won't know what to do with it yet, but at least you can
verify that it launches correctly and then close the window.
Ctrl-Q is a shortcut.)

\end{enumerate}


\subsection{Linux}
\label{monotools:linux}
We only provide instructions for Debian-based Linux distributions such
as Ubuntu.
\begin{enumerate}
\item {} 
Using the command-line \code{apt-get} tool, you can install everything
that you need using \code{apt-get install monodevelop}. This should be
run as the \textbf{root} user (using the \code{sudo} command).

\item {} 
You can test the sanity of your setup by following the instructions
under OS X.

\end{enumerate}

MonoDevelop releases on Linux tend to lag behind the official stable
release.

This page,
\href{https://launchpad.net/~keks9n/+archive/monodevelop-latest}{https://launchpad.net/\textasciitilde{}keks9n/+archive/monodevelop-latest},

describes
how to update your MonoDevelop setup if it is not version 2.8 or later
as we'll need for this course.

We wish to stress that Linux is recommended for students who already
have a bit of programming experience under their belts. It can take a
significant amount of energy to get a Linux setup up and running and
to tweak it to your liking. While it has gotten ever so much easier
since the 1990s when it first appeared, we encourage you to set it up
perhaps a bit later in the semester or consider running it using
virtualization software (on Mac or Windows) such as VirtualBox or
VMware.


\section{Lab Exercise: Editing, Compiling, and Running}
\label{lab-edit-compile-run:lab-exercise-editing-compiling-and-running}\label{lab-edit-compile-run::doc}\label{lab-edit-compile-run:lab-edit-compile-run}

\subsection{Summary}
\label{lab-edit-compile-run:summary}
This first lab is aimed at taking you through the end-to-end process of
writing and running a basic computer program. As with all things in
life, we will learn in this lab that becoming a programmer requires you
to learn a number of other things along the way.

In software development/engineering parlance, we typically describe a
scenario as a \emph{workflow}, which can be thought of as a series of steps
that are possibly repeated. The workflow of programming can loosely be
defined as follows:
\begin{enumerate}
\item {} 
Use a text editor to write your source code (human readable).

\item {} 
Compile your code using the Software Development Kit (SDK) into
object code.

\item {} 
Link your object code to create an executable. (There are other
kinds of results to produce, but we will start with the idea of an
executable program to keep things simple.)  The default is to nave
an executable program created with compilation, automatically.

\item {} 
Run your program. Even for the most seasoned developers, your
program may not work entirely right the first time, so you may end
up repeating these steps (debugging).

\end{enumerate}

As we will learn later in the course, development environments such as
Visual Studio (from Microsoft) and MonoDevelop (an open source
implementation similar to Visual Studio) basically shield you from the
details of understanding the workflow in detail. We think it is
important that you \emph{learn} this workflow from day one, because many types
of software development don't always have the easiest software
development tools.  You will be able to use fancy tools later.


\subsection{To be completed in the lab}
\label{lab-edit-compile-run:to-be-completed-in-the-lab}
The following is the code for a very well-known program, \emph{Hello,
World!}:

This program is deliberately simple, so you can type it into a text
editor (Emacs is recommended but your instructor may introduce you to
a different editor, subject to availability in the lab) quickly and become familiar with how
to create, edit, and save a program. Perform the following steps. (You
are free to deviate but may want to consider following the steps
religiously at least once to ensure you were successful.)
\begin{enumerate}
\item {} 
Open the text editor. This can usually be done from your
GUI's start menu.

\item {} 
Create a folder anywhere you like (e.g. in Documents) and name it
\code{hello}. (This can be done through the desktop shell
(e.g. Windows Explorer or Apple Finder.) As a general rule, we
recommend that you start any new programming project in its own
folder that is free of other folders/files. Clutter is a great
enemy of those who aspire to become good programmers.

\item {} 
When you start in Emacs, you are in what is known as \emph{scratch}
mode.  Typical of a sketchpad used by artists, this is where you
can start typing right away. You can now begin typing in the text
above. Keep in mind that the exact formatting is not important at
this stage; however, as we progress in this course, you'll \emph{want}
to pay attention to how your code is formatted. (With most text editors, it is
possible to reformat your code to make it \emph{beautiful}. More on
that later.)

\item {} 
Once you have entered the text, you will want to \emph{save} it, just
as if you were saving a file in your word processor. (In the Emacs
text editor, you use Control-x, Control-s. You will want to save
the file with the name \code{Hello.cs}. If you are using a graphical
text editor (like the case) then you will usually be able to save
from the File menu, much like you would do in a regular word
processor. Keep in mind, however, that you will eventually want to
learn the \emph{keyboard shortcuts} for your editor as much development
work in the real world happens from the command line and remote
terminal sessions (e.g. web and embedded systems development).

\item {} 
If all has gone well, you will now have a version of \emph{Hello,
World} in a file named \code{Hello.cs} in a folder named \code{hello}
(located in \code{Documents}).

\item {} 
Now we are going to learn how to compile this program. For this,
you will need to open a shell. On Linux and OS X, the shell is
opened by launching Terminal. On Windows, open a Mono Command
Prompt, as discussed above (or use one you left open).  Again to
find it:
\begin{itemize}
\item {} 
OS X: Applications -\textgreater{} Terminal (double click it)

\item {} 
Linux: Applications -\textgreater{} Terminal

\item {} 
Windows: Start Menu, search for Mono Command Line

\end{itemize}

\item {} 
Now you need to learn how to ``move around'' using the shell. The
command shell basically awaits user input and does whatever it is
told (and does nothing otherwise). You'll begin by using the ``cd''
command to change your working directory to where you saved
\code{Hello.cs}.  Note: Replace Dr. Thiruvathukals's login id gkt by
your login id.  Also note for Mac/Unix examples that his machine
is called macaroni.

If you did everything right, you can do this on Windows:

\begin{Verbatim}[commandchars=\\\{\}]
C:\PYGZbs{}Windows\PYGZbs{}System32\textgreater{} cd C:\PYGZbs{}users\PYGZbs{}gkt
C:\PYGZbs{}Users\PYGZbs{}gkt\textgreater{} cd Documents\PYGZbs{}hello
C:\PYGZbs{}Users\PYGZbs{}gkt\PYGZbs{}Documents\PYGZbs{}hello\textgreater{}
\end{Verbatim}

Mac/Linux:

\begin{Verbatim}[commandchars=\\\{\}]
\$ cd Documents/hello
\end{Verbatim}

\item {} 
If you are on OS X or Linux, you can list the directory using the
\code{ls} command. If the output you see here does not match, make
sure you are in the \code{hello} folder:

\begin{Verbatim}[commandchars=\\\{\}]
\$ ls

macaroni:hello gkt\$ ls
Hello.cs

\$ pwd
/Users/gkt/Documents/hello
\end{Verbatim}

\item {} 
If you're on Windows, can list the contents of the directory using
\code{dir}:

\begin{Verbatim}[commandchars=\\\{\}]
C:\PYGZbs{}Users\PYGZbs{}gkt\PYGZbs{}Documents\PYGZbs{}hello\textgreater{}dir
         Volume in drive C has no label.
         Volume Serial Number is 2C13-C918

         Directory of C:\PYGZbs{}Users\PYGZbs{}anh\PYGZbs{}Documents\PYGZbs{}hello

        01/16/2012  06:07 PM    \textless{}DIR\textgreater{}          .
        01/16/2012  06:07 PM    \textless{}DIR\textgreater{}          ..
        11/04/2011  08:20 PM               646 Hello.cs

        ...
\end{Verbatim}

\item {} 
If you are unable to see \code{Hello.cs} at this stage, you need to
go back and check all previous steps. It is entirely possible you
did not create the folder or save properly. If you think you
completed these steps, this is a good time to ask the instructor
or teaching assistant for help.

\item {} 
Assuming you are able to see \code{Hello.cs} in the \code{hello} folder,
we are now ready for \emph{the good stuff*\textasciitilde{}\textasciitilde{}the technical term we use
when we are about to learn something that we need to know how to
do *for life}. We're going to compile the \code{Hello.cs} program
into \code{Hello.exe} so we can run it. FYI, you should still be in
the Terminal/DOS window where we just listed the directory (this
works regardless of what OS you are using). Enter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{gmcs} \PYG{n}{Hello}\PYG{p}{.}\PYG{n}{cs}
\end{Verbatim}

\item {} 
If everything worked right, you will not see any output. If you
spot any error messages, it means that you probably made a typo
when copying/typing the sample code into the text editor. Go back
to step @EditHello and check that everything is typed
properly. (We will not be discussing all the possible errors you
an encounter at this stage, but you might find them helpful to
edit your program.) If your text editor is not still open, then
you need to re-open the file, which can be done easily by using
File \code{-\textgreater{}} Open and browsing your folder structure to find folder
\code{hello}, then \code{Hello.cs}.

\item {} 
Now for the great moment you have been awaiting: You can \emph{run}
\code{Hello.exe}.  Enter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mono} \PYG{n}{Hello}\PYG{p}{.}\PYG{n}{exe}
\end{Verbatim}

You should see the result:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Hello}\PYG{p}{,} \PYG{n}{World}\PYG{p}{!}
\end{Verbatim}

\end{enumerate}

At this point, we have accomplished the major objective for Lab 0: to
enter, compile, and run a C\# program. In the next lab, we will work on
some revisions to \code{Hello.cs} to personalize it a bit.

As this point, you should grab the instructor or teaching assistant so
they can perform a quick inspection of your work and check it off. Per
the syllabus, labs are not graded but do need to be completed to receive
credit. If you are unable to make class on a lab day, please make sure
that you complete the work and demonstrate it by the beginning of the
next lab.


\subsection{For further reinforcement}
\label{lab-edit-compile-run:for-further-reinforcement}\begin{enumerate}
\item {} 
Download and install the Emacs and Mono Software Development Kit on
your home computer or laptop.

\item {} 
Make sure you can do everything that you just completed in the lab.

\item {} 
See whether you can get a head start on Lab 1.

\end{enumerate}


\subsection{Some Useful Resources for Learning Emacs}
\label{lab-edit-compile-run:some-useful-resources-for-learning-emacs}\begin{enumerate}
\item {} 
The GNU Emacs Tutorial, \href{http://www.gnu.org/software/emacs/tour/}{http://www.gnu.org/software/emacs/tour/}

\item {} 
University of Chicago Libraries Emacs Tutorial,
\href{http://www2.lib.uchicago.edu/keith/tcl-course/emacs-tutorial.html}{http://www2.lib.uchicago.edu/keith/tcl-course/emacs-tutorial.html}

\end{enumerate}


\subsection{Other Useful Text Editors}
\label{lab-edit-compile-run:other-useful-text-editors}
\#. Gedit, \href{http://gedit.org}{http://gedit.org}, is a very nice editor that comes with most
Linux/Gnome distributions. Although it allegedely runs on Windows and OS X, we
have not had a chance to test it and cannot recommend it at this time.
\begin{enumerate}
\item {} 
Vim,  \href{http://www.vim.org/docs.php}{http://www.vim.org/docs.php}, is another popular editor based
on the famous \textbf{vi} text editor that goes back a number of
decades. There are graphical versions for Linux, Mac, and Windows.

\end{enumerate}

Unfortuntely, these are not available in the Windows labs yet (unlike
Emacs); however, students working in the Linux laboratory have access
to these editors and may wish to learn them.


\subsection{What's next in Lab 1?}
\label{lab-edit-compile-run:what-s-next-in-lab-1}
We'll continue learning more about C\#. The next lab will give you
exposure to the C\# interactive mode (in Mono, the \code{csharp} command),
where we will learn to work with arithmetic and basic primitive types.
The \code{csharp} command allows you to use C\# as a sort of ``toy
calculator'' language. It also allows you to test capabilities of the C\#
\emph{programming library}. For example, we will learn some other things you
can do with the \code{Console} interfaces, including how to prompt a user
for input.


\section{Comments on Miles Simple Data}
\label{milessimpledata:comments-on-miles-simple-data}\label{milessimpledata::doc}
Miles Chapter 2 on Simple Data Processing is also well written.
Start by reading through section 2.3.1, ending on page 38.  As you \emph{read it},
note the specific comments below.   The chapter does not mention the Mono tool,
csharp, which makes it very easy to test simple data operations.
\begin{description}
\item[{Page 27}] \leavevmode
The table is for reference, context, and completeness:
You do NOT need to memorize all the types, particularly now!
Mostly used are int and char, and possibly long for really big numbers.

\item[{Page 28}] \leavevmode
We will mostly stick to double for convenience.
Using smaller versions is only important if you have enormous collections of data.
You do not need to use the E notation â€“ though you may see it.

\item[{Page 29}] \leavevmode
This is another table for reference/completeness.
The only escape code we are likely to use are \textbackslash{}n, \textbackslash{}\textbackslash{}, \textbackslash{}''.

\item[{Page 30}] \leavevmode
Unicode is nice if you want different languages and special symbols, but we will not use it.

\item[{Page 33}] \leavevmode
The precedence table is very misleading:
It does not distinguish operands with the SAME precedence:
Operators * and /, have the same precedence.
The binary operations + and - have the same precedence.

This is the same precedence as in normal math.  See the related section added below
about another useful operator related to division, the remainder operator, \%.
It has the same precedence as * and /.

\item[{Page 34-35:}] \leavevmode
The idea of casting numbers is important,
that the same abstract number may have different representations,
and some are more or less accurate.
In practice the main cast for us will be int to double.
Make sure you realize that casting double to int is NOT the same as rounding; instead
it removes the fractional part whether high, .999, low, 0.1, or in the middle, .5.

\end{description}

\index{division!remainder}\index{remainder!division}

\section{Division and Remainders}
\label{remainders:index-0}\label{remainders::doc}\label{remainders:division-and-remainders}\label{remainders:id1}
Try in the csharp shell.  Be sure to include the decimal points:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{5.0}\PYG{p}{/}\PYG{l+m}{2.0}\PYG{p}{;}
\PYG{l+m}{1}\PYG{l+m}{4.0}\PYG{p}{/}\PYG{l+m}{4.0}\PYG{p}{;}
\end{Verbatim}

On the other hand, try in csharp:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{4}\PYG{p}{/}\PYG{l+m}{4}\PYG{p}{;}
\end{Verbatim}

you get something that looks strange:  Just and addition, subtraction, and multiplication
of \code{int}s produces and \code{int}, so, too with division.

In C\#, the result of the / operator depends on the
type of the operands, not on the mathematical value of the operands.

If you think about it, you learned several ways to do division.
Eventually you learned how to do division resulting in a decimal.
In the earliest grades you would say
\begin{quote}

``14 divided by 4 is 3 with a remainder of 2''.
\end{quote}

Note the the quotient is an integer 3, that matches the C\# evaluation of 14/4,
so having a way to generate an integer quotient is not actually too strange.
The problem here is
that the answer from grade school is in two parts, the integer quotient 3 and the
remainder 2.

C\# has separate operation to generate the remainder part.  There is no standard
single operator character operator in regular math, so C\# grabs an unused symbol
(the same ias in many other computer languages): \% is the remainder operator.

Try in the csharp shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{4}\PYG{p}{\PYGZpc{}}\PYG{l+m}{4}\PYG{p}{;}
\end{Verbatim}

You see you do get the remainder from our grade school division.

Now predict and then try each in the csharp shell:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{2}\PYG{l+m}{3}\PYG{p}{/}\PYG{l+m}{5}\PYG{p}{;}
\PYG{l+m}{2}\PYG{l+m}{3}\PYG{p}{\PYGZpc{}}\PYG{l+m}{5}\PYG{p}{;}
\PYG{l+m}{2}\PYG{l+m}{0}\PYG{p}{\PYGZpc{}}\PYG{l+m}{5}\PYG{p}{;}
\PYG{l+m}{6}\PYG{p}{/}\PYG{l+m}{8}\PYG{p}{;}
\PYG{l+m}{6}\PYG{p}{\PYGZpc{}}\PYG{l+m}{8}\PYG{p}{;}
\PYG{l+m}{6.0}\PYG{p}{/}\PYG{l+m}{8}\PYG{p}{;}
\end{Verbatim}

The / operator can be confusing, depending on the type, not the mathematical value.
Note that if at least one operand is double, the result was be.

Finding remainders will prove more useful than you might think in
the future!


\subsection{Exercise for Quotients}
\label{remainders:quotientproblem}\label{remainders:exercise-for-quotients}
Write a program, \code{quotient.cs}, that
prompts the user for two integers, and then prints them out in a
sentence with an integer division problem like

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{n}{quotient} \PYG{n}{of} \PYG{l+m}{1}\PYG{l+m}{4} \PYG{n}{and} \PYG{l+m}{3} \PYG{k}{is} \PYG{l+m}{4} \PYG{n}{with} \PYG{n}{a} \PYG{n}{remainder} \PYG{n}{of} \PYG{l+m}{2}
\end{Verbatim}


\section{Substitutions in Console.WriteLine}
\label{writeline-substitution:substitutions-in-console-writeline}\label{writeline-substitution::doc}

\subsection{Output With \texttt{+}}
\label{writeline-substitution:output-with}
An elaboration of a ``Hello, World'' program, could greet the user,
after obtaining the user's name.  If the user enters thje name
Kim, the program could print
\begin{quote}

Hello, Kim!
\end{quote}

This is a very simple
input-process-output program (in fact with almost no ``process'').
Think how would you code it?

You need to obtain a name, remember it and use it in your output.
A solution is in the next section.

\index{WriteLine!\{\} for format}\index{\{\} for format!WriteLine}

\subsection{String Format Operation}
\label{writeline-substitution:index-0}\label{writeline-substitution:string-format-operation}\label{writeline-substitution:format-strings}
A common convention is fill-in-the blanks. For instance,
\begin{quote}

Hello, \_\_\_\_\_!
\end{quote}

and you can fill in the name of the person greeted, and combine
given text with a chosen insertion. C\# has a similar
construction, better called fill-in-the-braces,
that can be used with \code{Console.WriteLine}.

Instead of inserting user input with the \code{+} operation as in
\code{HelloYou1.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{HelloYou1}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"What is your name?"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{name} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hello, "} \PYG{p}{+} \PYG{n}{name} \PYG{p}{+} \PYG{l+s}{"!"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

look at a variation, \code{HelloYou2.cs}, shown below.
Both programs
look exactly the same to the user:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{HelloYou}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"What is your name?"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{name} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine} \PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hello, \PYGZob{}0\PYGZcb{}!"}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\code{Console.WriteLine} actually can take parameters \emph{after} an initial string,
but only when  the string is in the form of a \emph{format string},
with expression(s) in braces where substitutions are to be made,
(like in fill-in-the-blanks).

The remaining parameters, after the initial string,
give the values to be substituted.  To
know \emph{which} further parameter to substitute, the parameters after the
initial string are implicitly numbered,
\emph{starting from 0}.
Starting with 0 is consistent with other numbering sequences in C\#.
So here, where there is just one value to substitute, it gets the index 0,
and where it is substituted, the braces get 0 inside, to indicate
that parameter 0 is to be substituted.

Everything in the initial string that is \emph{outside} the braces is just
repeated verbatim.  In particular, if the only parameter is a string
with no braces, it is printed completely
verbatim (as we have used \code{Console.WriteLine} before).

A more elaborate silly examples that you could test in csharp would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string} \PYG{n}{first} \PYG{p}{=} \PYG{l+s}{"Peter"}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{last} \PYG{p}{=} \PYG{l+s}{"Piper"}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{what} \PYG{p}{=} \PYG{l+s}{"pick"}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{}, \PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{}, \PYGZob{}2\PYGZcb{}."}\PYG{p}{,} \PYG{n}{first}\PYG{p}{,} \PYG{n}{last}\PYG{p}{,} \PYG{n}{what}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

It would print:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Peter} \PYG{n}{Piper}\PYG{p}{,} \PYG{n}{Peter} \PYG{n}{Piper}\PYG{p}{,} \PYG{n}{pick}\PYG{p}{.}
\end{Verbatim}

where parameter 0 is \code{first} (value \code{"Peter"}),
parameter 1 is \code{last} ( value \code{"Piper"}), and
parameter 2 is \code{what} (value \code{"pick"}).

Make sure you see why the given output is exactly what is printed.

Or try in csharp:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{7}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{y} \PYG{p}{=} \PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} plus \PYGZob{}1\PYGZcb{} = \PYGZob{}2\PYGZcb{}; \PYGZob{}0\PYGZcb{} times \PYGZob{}1\PYGZcb{} = \PYGZob{}3\PYGZcb{}."}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{+}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{*}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and see it print:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{7} \PYG{n}{plus} \PYG{l+m}{5} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{2}\PYG{p}{;} \PYG{l+m}{7} \PYG{n}{times} \PYG{l+m}{5} \PYG{p}{=} \PYG{l+m}{3}\PYG{l+m}{5.}
\end{Verbatim}

Note the following features:
\begin{itemize}
\item {} 
Parameters can be any expression,
and the expressions get evaluated before printing.

\item {} 
Parameters to be substituted can be of any type.

\item {} 
The parameters are automatically converted to a string form, just as in the
use of the string \code{+} operation.

\end{itemize}

In fact the simple use of format strings
shown so far can be completed replaced by long expressions with \code{+},
if that is your taste.  Miles later (on page 50) discusses fancier formatting,
that \emph{cannot} be duplicated with a simple string \code{+} operation.
We will just use the simple numbered substitutions for now,
to get used to the idea of substitution.

A technical point: Since braces have special meaning in a format
string, there must be a special rule if you want braces to actually
be included in the final \emph{formatted} string. The rule is to double
the braces: \code{'\{\{'} and \code{'\}\}'}. The fragment

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{,} \PYG{n}{b} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"The set is \PYGZob{}\PYGZob{}\PYGZob{}0\PYGZcb{}, \PYGZob{}1\PYGZcb{}\PYGZcb{}\PYGZcb{}."}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

produces

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{The} \PYG{k}{set} \PYG{k}{is} \PYG{p}{\PYGZob{}}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{.}
\end{Verbatim}
\phantomsection\label{learning-to-problem-solve:learn-solve}
\index{problem solving!strategy}

\section{Learning to Solve Problems}
\label{learning-to-problem-solve:index-0}\label{learning-to-problem-solve::doc}\label{learning-to-problem-solve:learning-to-solve-problems}
This section might have been placed earlier,
but by placing it here,
you should realize that you will have a \emph{lot} of data to deal with.

The manner in which you deal with all the data and ideas is very important for effective learning.
It might be rather different than what you needed if you were in a situation
where \emph{rote} recall is the main important thing.

Different learning styles mean different things are useful to different people.
Consider what is mentioned here and try out some approaches.

The idea of this course is not to regurgitate the notes, but to learn to solve problems
(generally involving producing a computer program).
In this highly connected and wired world
you have access to all sorts of data.  The data is not an end in itself, the question is
\emph{doing} the right things with the tools out there.

In this course there is a lot of data tied into syntax and library function names and ....
It can seem overwhelming.  It need not be. Take a breath.

First basic language syntax:  When learning any new language, there is a lot to take in.
We introduce C\# in chunks.  For a while there will always be the new current topic coming.
You do NOT need to memorize \emph{everything} immediately!
\begin{itemize}
\item {} 
Some things that you use rarely, you may never memorize, like,
``What is the exact maximum magnitude of a \code{double}?''  At \emph{some} point that might be useful.
Can you find it?  It happens to be in a table in Miles.  It is also in online .Net documentation
that you can Google or bookmark.

\item {} 
Some things you will use all the time, but of course they start off as new and maybe strange.
Knowing where to go to check is still useful but not sufficient. For much-used material
that you do not find yourself obsorbing immediately,
consider writing down a summary of the current topic.
Both thinking of a summary and writing help reinforce things and get you to remember faster.
Also, if you have the current things of interest summarized in one place, they are easy to look
up!

\item {} 
If you need some syntax to solve a simple early problem,
first try to remember the syntax, then check.  With frequently
used material with this sort of repetition,
most everyone will remember most everything shortly.  If there are a few things
that just do not stick, keep them in your list.  Then go on to new material.  The list of
what you need to check on will keep changing as you get more experience and get to more topics.
If you keep some of the old lists, you will be amazed how much stuff that you sweated over,
is later ho-hum or automatic.

\item {} 
Earliest exercises
should have the general steps needed pretty apparent, and you can just concentrate on
translating simple ideas into C\# syntax
(likely concentrating on the material most recently introduced).
In this case the focus is mostly on syntax.

\end{itemize}

Memorizing syntax is not going to directly get you to solve real problems.  In any domain:
programming, construction, organizing political action, ..., you need to analyse the problem
and figure out a sequence of steps, knowing what powers and resources you have.

For example with political action:
if you know demonstrations are possible in front of City Hall, you can make a high-level
plan to have one, but then you have to attend to details:  Do you need city permission?
Who do you call? ... You do not have to have all that in your head when coming up with the
idea of the demonstration, but you better know how to find the information allowing you
to follow through to make it happen.

With programming, syntax details are like the details above: not the first thing to think of,
and maybe not things that you have memorized.  What \emph{is} important to break down a problem
and plan a solution, is to know the basic capacities you have in programming.  As you get
into larger projects and have more experience, ``basic capacities'' will be bigger and bigger ideas.
For now, as beginners, it is important to know:
\begin{itemize}
\item {} 
You can get information from a user and return information via keyboard and screen.

\item {} 
You can remember and recall and use information using variables.

\item {} 
You can deal directly with various kinds of data: numbers and Strings at this point.

\item {} 
There are basic operations you can do with the data (arithmetic, contatenating string,
converting between data types).

\item {} 
At a slightly higher level, you might already have the idea of basic recurring patterns,
like solving a straightforward problem with \textbf{input-processing-output}.

\item {} 
You will shortly see that you have more tools:  decision, repetition, more built-in
ways to deal with data (like more string operations shortly), creating your own data types....

\end{itemize}

At slightly more detailed level, \emph{after} thinking of overall plans:
\begin{itemize}
\item {} 
There are multiple kinds of number types.  What is appropriate for your use?

\item {} 
There are various ways of formatting and presenting data to output. What shall you use?

\end{itemize}

\emph{Finally}, you actually need to translate specific instructions into C\# (or whatever language).
Of course if you remember the syntax, then this level of step is pretty automatic.
Even if you do \emph{not} remember, you have something very specific to look up!  If you are
keeping track of your sources of detailed information, this is hopefully only one further
step.

Contrast this last-step translation with the earlier creative organizational process:
If you do not have \emph{in your head} an idea of the basic tools available,
how are you going to plan?
How are you going to even know how to start looking something up?

So far basic ideas for planning a solution has been discussed, and you can see that you do not
need to think of everything at once or have everything equally prominent in your brain.

Also, when you are coding, you do not need to to have all the details of syntax in your head,
even for the \emph{one} instruction that you are dealing with at the moment.  You want to have
the main idea, and you want to get it written down, but once it is written down, you can make
multiple passes, examining and modifying what you have.  For example, Dr. Harrington does a lot of
Python programming, where semicolons are not needed.  He can get the main ideas down
in C\# without the required
semicolons.  He \emph{could} wait for the compiler to stop him on every one that is missed,
and maybe have the compiler misinterpret further parts, and give bogus error messages.
\emph{More effective} is having
a list of things to concentrate on in later rounds of manual checking.
For example, checking for semicolons: Scan the statements;
look at the ends; add semicolons where missing.  You can go through a large program very
quickly and efficiently doing this and have one less thing to obsess about when first writing.

This list of things-to-check-separately should come from experience.
Keep track of the errors you make.  Some people even keep an error log.
What errors keep occuring?
Make entries in things-to-check-separately,
so you will make scans checking for the specific thinsg you frequently slip up on.

This things-to-check-separately list, too, will evolve.  Revise it occasionally.
If Dr. Harrington does enough
concentrated C\#, \emph{maybe} he will find that entering semicolons becomes automatic,
and he can take the separate round of semicolon checking off his list.

What to do \emph{after} you finish an exercise is important, too.  The natural thing psychologically,
particularly if you had a struggle, is to think, ``Whew, outa here!!!!''

On something that came automatically or flowed smoothly, that is not a big deal -
you will probably get it just as fast the next time. If you had a hard time and only eventually
got to success, you may be doing yourself a disservice with ``Whew, outa here!!!''

We have already mentioned how not everything is equally important, and some things are more
important to keep in your head than others.  The same applies to all the steps in solving
a possibly long problem.  Some parts were easy; some were hard; there may have been many steps.
If all of that goes into your brain in one continuous stream of stuff that you
remember at the same level, then you are going to leave an awful lot as just unimportant
and basically useless (so why do the problem anyway?), \emph{or} have a
brain \emph{very} stuffed with things you want to recall.

What is important?  The most obvious thing you will need at a higher level of recall is what
\emph{just messed you up}, what you missed until doing this problem:  After finishing the
actual problem, \emph{actively} follow up and ask yourself:
\begin{itemize}
\item {} 
What did I get in the end that I was misssing initially? What was the connection I made?

\item {} 
Does this example fit in to some larger idea/abstraction/generalization in a way that
I did not see before?

\item {} 
How am I going to look at this so I can make a similar connection
in a similar (or maybe only partly similar) problem?

\item {} 
Is there a kernal here that I can think of as a new tool in my bag of tricks?

\end{itemize}

Your answers are the most important things to take away.
The extra consideration puts them more in
the ``priority'' part of your brain, so you can really learn from your effort.  When you need
the important ideas
next, you do not need to play through all the details of
the stuff you did to solve the exact earlier problem.

\index{labs!division sentences}

\section{Lab: Division Sentences}
\label{lab-division-sentences:lab-division-sentences}\label{lab-division-sentences:index-0}\label{lab-division-sentences::doc}\label{lab-division-sentences:lab-division}

\subsection{Overview}
\label{lab-division-sentences:overview}
In this lab, we're going to begin to look at what makes computers \emph{do
their thing} so to speak.

It is rather insightful to look at how Wikipedia summarizes the
computer:
\begin{quote}

A computer is a programmable machine designed to sequentially and
automatically carry out a sequence of arithmetic or logical
operations. The particular sequence of operations can be changed
readily, allowing the computer to solve more than one kind of
problem.
\end{quote}

In other words, a computer is a calculator--and much
more. Furthermore, the definition of a computer goes on to include
access to storage and peripherals, such as consoles (graphical displays),
printers, and the network. We already got a glimpse of this access
when we explored \code{Console.WriteLine} in the first lab exercise.

So in this lab, we're going to explore the use of C\# as a
calculator. We're going to begin by looking at the \textbf{csharp} command
as opposed to the compiler (\textbf{gmcs} that we used in the first
lab). Then we will take what we've learned in this session and use it
to write a full program.

This is a large enough program that it may be useful to have the
editor be knowledgeable about C\# syntax and formatting conventions.
You may want to jump to the final section that discusses how to
set emacs up for that.


\subsection{Requirements}
\label{lab-division-sentences:requirements}
We want to develop a program that can do the following:
\begin{itemize}
\item {} 
Prompt the user for input of two integers, which we will call
\emph{numerator} and \emph{denominator}. For clarity, we are only looking at
integers, because this assignment is about rational numbers. A
rational number can always be expressed as a quotient of two integers.

\item {} 
Calculate the floating point division result (e.g. 10/4 = 2.5).

\item {} 
Calculate the quotient and the remainder (e.g. 10/4 = 2 with a
remainder of 2 = 2 2/4).

\end{itemize}

As an example of how this program will ultimately work:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Please} \PYG{n}{enter} \PYG{n}{the} \PYG{n}{numerator}\PYG{p}{?} \PYG{l+m}{1}\PYG{l+m}{4}
\PYG{n}{Please} \PYG{n}{enter} \PYG{n}{the} \PYG{n}{denominator}\PYG{p}{?} \PYG{l+m}{4}
\PYG{n}{Floating} \PYG{n}{point} \PYG{n}{division} \PYG{n}{result} \PYG{p}{=} \PYG{l+m}{3.5}
\PYG{n}{Integer} \PYG{n}{division} \PYG{n}{result} \PYG{p}{=} \PYG{l+m}{3} \PYG{n}{remainder} \PYG{l+m}{2}
\PYG{n}{Result} \PYG{k}{as} \PYG{n}{a} \PYG{n}{fraction} \PYG{p}{=} \PYG{l+m}{3} \PYG{l+m}{2}\PYG{p}{/}\PYG{l+m}{4}
\end{Verbatim}

We will later learn how to turn the 3 2/4 into a reduced
fraction. This will be achieved using a famous method known as the
\emph{greatest common divisor} algorithm, which has a very simple
formulation that is credited to Euclid, of of the great early
mathematicians (among other things).


\subsection{csharp}
\label{lab-division-sentences:csharp}
So let's get this party started by firing up the \textbf{csharp}
command. Open a terminal (Linux or OS X) or command window for the
Mono tools, which we know how to use from previous work:

\begin{Verbatim}[commandchars=\\\{\}]
\$ csharp
Mono C\# Shell, type "help;" for help

Enter statements below.
csharp\textgreater{}
\end{Verbatim}

The \code{csharp\textgreater{}} prompt tells you that the C\# interpreter has started
and is awaiting input. This allows you to create C\# variables and
execute C\# statements without having to write a full program.

You can also use features of the C\# programming
library (e.g. the \code{Console.WriteLine} we learned about in the
previous lab):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Please enter the numerator?"}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Please} \PYG{n}{enter} \PYG{n}{the} \PYG{n}{numerator}\PYG{p}{?}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{input} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{2}\PYG{l+m}{5}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{numerator} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{input}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{numerator}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{2}\PYG{l+m}{5}
\end{Verbatim}

Before we continue with this session, please note that it is ok to
make mistakes. The C\# interpreter tends to be forgiving, although
there are some cases where you might find yourself a bit
confused. Here's an example of something that could happen to you in
the course of typing a statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{denominator} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}
\PYG{p}{\textgreater{}}
\end{Verbatim}

In this example, I accidentally hit the return/enter key after
entering the left parenthesis. For \code{int.Parse(} to work, it needs
more input to bring the statement to completion. For example, it needs
to know \emph{what to parse} and must be a complete C\# statement. The
closing parenthesis and statement terminator (semicolon) need to be
typed for this to happen.

So we can either continue entering the input:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{denominator} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}
\PYG{p}{\textgreater{}} \PYG{n}{input}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Or we can type semicolon (;) followed by return/enter to end the input
and try again:

\begin{Verbatim}[commandchars=\\\{\}]
csharp\textgreater{} int denominator = int.Parse(
\textgreater{} ;
\PYGZob{}interactive\PYGZcb{}(2,0): error CS1525: Unexpected symbol {}`;'
\end{Verbatim}

This will force the statement to be processed by the C\# interpreter
and give an error. You can then \emph{try again} if you like!

A particularly useful feature of the C\# interpreter is the
\code{ShowVars()} function. (Yes, we know you haven't fully learned
functions yet, but we're introducing some things by doing them and
will be explaining more formally later.) \code{ShowVars()} prints the
list of variables and their values that have been defined in a given
session:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{ShowVars}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{denominator} \PYG{p}{=} \PYG{l+m}{4}
\PYG{k+kt}{int} \PYG{n}{numerator} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{4}
\PYG{k+kt}{string} \PYG{n}{input} \PYG{p}{=} \PYG{l+s}{"14"}
\PYG{k+kt}{string} \PYG{n}{input2} \PYG{p}{=} \PYG{l+s}{"4"}
\end{Verbatim}

This just happens to be the list of variables/values that are defined
in my session. Yours may vary depending on what variables you typed,
etc.

Now let's use the C\# operators to get the quotient and the remainder:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{quotient} \PYG{p}{=} \PYG{n}{numerator} \PYG{p}{/} \PYG{n}{denominator}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{quotient}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{remainder} \PYG{p}{=} \PYG{n}{numerator} \PYG{p}{\PYGZpc{}} \PYG{n}{denominator}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{remainder}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{2}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} / \PYGZob{}1\PYGZcb{} = \PYGZob{}2\PYGZcb{} remainder \PYGZob{}3\PYGZcb{}"}\PYG{p}{,} \PYG{n}{numerator}\PYG{p}{,} \PYG{n}{denominator}\PYG{p}{,} \PYG{n}{quotient}\PYG{p}{,} \PYG{n}{remainder}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{1}\PYG{l+m}{4} \PYG{p}{/} \PYG{l+m}{4} \PYG{p}{=} \PYG{l+m}{3} \PYG{n}{remainder} \PYG{l+m}{2}
\end{Verbatim}

Because we are working with integer data, we need the ability to get
the result of the division and the remainder \emph{as integers}. As shown,
14 / 4 results in 3. That's because the remainder is not included (nor
can it be) unless we use another data type (float) that can hold the
full result of a division operation.

C\# gives you the ability to get the remainder using a separate
operation known as the \emph{modulus} operator. This operator is what we
sometimes call a \emph{convenience} operator, because we all learned in
basic mathematics that the remainder = numerator - quotient *
denominator (here the remainder is 14 - 3 * 4 = 2).

In the above, we are also introducing the ability to take the results
of a calculation and \emph{format} them using \code{Console.WriteLine}. Here
\{0\}, \{1\}, \{2\}, and \{3\} refer to each of the variables that follow the
text that we wish to print. Each of these variables will be
substituted into the string to produce the beautifully formatted
output that is shown:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{4} \PYG{p}{/} \PYG{l+m}{4} \PYG{p}{=} \PYG{l+m}{3} \PYG{n}{remainder} \PYG{l+m}{2}
\end{Verbatim}

You may find this example to be helpful to print the output according
to the requirements:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{4} \PYG{p}{/} \PYG{l+m}{4} \PYG{p}{=} \PYG{l+m}{3} \PYG{l+m}{2}\PYG{p}{/}\PYG{l+m}{4}
\end{Verbatim}

Now let's take a look at how we can get the results as a floating
point result. To do this, we must declare a couple of float (C\#'s
basic real number type) variables to hold each of the numerator and
denominator integers. Then we will declare a variable to capture the
result of the floating point division operation. Because division is
meaningful for all numeric data types, it is exactly the same
operator. C\# knows that the operator is being applied to floating
point data in this case, because we declared floating point
variables. (We will show how you can avoid declaring some of these
variables but are erring on the side of clarity.) We named each of the
floating-point variables with the number 2 in the name as C\# permits
variable names that have numbers and underscores after the first
character (which must be a \emph{letter} or an \emph{underscore}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{float} \PYG{n}{numerator2} \PYG{p}{=} \PYG{n}{numerator}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{float} \PYG{n}{denominator2} \PYG{p}{=} \PYG{n}{denominator}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{float} \PYG{n}{quotient2} \PYG{p}{=} \PYG{n}{numerator2}\PYG{p}{/}\PYG{n}{denominator2}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{quotient2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3.5}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} / \PYGZob{}1\PYGZcb{} = \PYGZob{}2\PYGZcb{} remainder \PYGZob{}3\PYGZcb{}"}\PYG{p}{,} \PYG{n}{numerator}\PYG{p}{,} \PYG{n}{denominator}\PYG{p}{,} \PYG{n}{quotient}\PYG{p}{,} \PYG{n}{remainder}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{1}\PYG{l+m}{4} \PYG{p}{/} \PYG{l+m}{4} \PYG{p}{=} \PYG{l+m}{3} \PYG{n}{remainder} \PYG{l+m}{2}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} / \PYGZob{}1\PYGZcb{} = \PYGZob{}2\PYGZcb{} approximately"}\PYG{p}{,} \PYG{n}{numerator2}\PYG{p}{,} \PYG{n}{denominator2}\PYG{p}{,} \PYG{n}{quotient2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{1}\PYG{l+m}{4} \PYG{p}{/} \PYG{l+m}{4} \PYG{p}{=} \PYG{l+m}{3.5} \PYG{n}{approximately}
\end{Verbatim}

So effectively we have shown everything you need to understand to
complete this lab. Your job in the remaining time is to see whether
you can use a text editor to create a program, which you can name
anything you like. We suggest calling it \code{DoTheMath.cs}. To help you
get started, we provided this simple \emph{template}. You'll probably find
it convenient to cut and paste code that you've already ``tried out'' (in
the C\# interpreter) into your text editor:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{namespace} \PYG{n+nn}{Comp170} \PYG{p}{\PYGZob{}}
   \PYG{k}{class} \PYG{n+nc}{DoTheMath} \PYG{p}{\PYGZob{}}
      \PYG{k}{public} \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
          \PYG{c+c1}{// Prompt the user for the numerator using}
          \PYG{c+c1}{// Console.WriteLine().}

          \PYG{c+c1}{// Convert this text into int numerator using}
          \PYG{c+c1}{// int.Parse().}

          \PYG{c+c1}{// Do the same for the denominator.}

          \PYG{c+c1}{// Calculate quotient and remainder (as integers)}
          \PYG{c+c1}{// Use Console.WriteLine() to make the results pretty as}
          \PYG{c+c1}{// above.}

          \PYG{c+c1}{// Do the same but using floating point division and not}
          \PYG{c+c1}{// doing the remainder calculation.}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
\phantomsection\label{lab-division-sentences:java-mode}
\index{emacs!java-mode}\index{java-mode!emacs}

\subsection{Proper Indentation and Emacs java-mode}
\label{lab-division-sentences:proper-indentation-and-emacs-java-mode}\label{lab-division-sentences:index-1}
With this exercise, we are now entering a phase where we must start
paying a bit more attention to the basic \emph{appearance} of our code. As
programs become larger, they also can become harder to maintain (let
alone understand) if they are not formatted according to some basic
style guidelines.

As you'll come to learn in programming, different communities have
different conventions. The folks who make another open source C\# tool,
known as SharpDevelop (not used in this class but an awesome project)
have their own style guide that is particularly well written. See
\href{http://www.icsharpcode.net/technotes/sharpdevelopcodingstyle03.pdf}{http://www.icsharpcode.net/technotes/sharpdevelopcodingstyle03.pdf}.

In any event, luckily for us, we have access to editors like Emacs and
Gedit (in the Linux lab anyway) that support automatic source-code
indenting. In Emacs, you can enable this support by using
\emph{java-mode}. At the time of writing, there is actually a \emph{csharp-mode}
but it is not yet a part of the standard Emacs distribution. For the
most part, you can get by using \emph{java-mode}, given that C\# is very
similar to Java in terms of its overall syntax. It doesn't understand
keywords like \code{namespace} but otherwise seems to work in our
testing.

When in Emacs, you can enable Java mode in your buffer for
\code{DoTheMath.cs} by typing Escape-x. The minibuffer (the space you see
at the bottom of the screen where an \code{M-x} or similar prompt is
shown) will wait for you to type the name of a command. Enter
\emph{java-mode} and you will be able to take advantage of the magical
support in Emacs for automatic formatting of your source code. Your
instructor will show you how to make effective use of it.  Two features
are worthy of immediate notice:
\begin{itemize}
\item {} 
The program becomes color-coded.  On of the most useful things
is that literal strings have a different color.
Forgetting the final quote mark at the end of a literal string
ia=s a common
error that may not be associated with good error messages.
The color coding makes it very obvious that the editor sees the
string as being too long.

\item {} 
Nice indentation is done with very little effort.  Pressing the
Enter key still takes you to the beginning of the next line,
but a single further press of the tab key
generally indents to exactly where the line should start.

\end{itemize}

If you are feeling a bit adventurous, you can download \emph{csharp-mode}
from the Emacs Wiki at
\href{http://www.emacswiki.org/emacs/CSharpMode}{http://www.emacswiki.org/emacs/CSharpMode}. All you need to do is save
the Emacs Lisp file (a file with the .el suffix) anywhere in your home
folder. Then you can use Emacs to load this file (Esc-x, then type
\emph{load-file}). You'll need to browse to the folder where you saved the
\emph{csharp-mode} code to complete the process. Then you ca type
\emph{csharp-mode} instead of \emph{java-mode}.

As this is a bit of an advanced topic, this explanation will have to
suffice for now. We're hopeful that future versions of Emacs will
include \emph{csharp-mode} by default.

\index{homework!input-output decisions}\index{input-output!decisions, homework}\index{decisions!homework input-output}

\section{Homework: Grade Calculation}
\label{homework-gradecalculation:index-0}\label{homework-gradecalculation:homework-grade-calculation}\label{homework-gradecalculation::doc}\label{homework-gradecalculation:id1}
You are going to be
putting together your first programming assignment where
you will be taking the various concepts we have learned
thus far in lecture and lab and to put together your first
meaningful program on your own.

This program will incorporate the following elements:
\begin{itemize}
\item {} 
Prompt a user for input.

\item {} 
Perform some rudimentary calculations.

\item {} 
Make some decisions.

\item {} 
Produce output.

\end{itemize}

As we've mentioned in the early lectures, our focus is going
to be on learning how to write computer programs that start
with a Main() function and perhaps use other functions as
needed to \emph{get a particular job done}. Eventually, we will
be incorporating more and more advanced elements, such as
classes and objects. For now, we would like you to organize
your program according to the guidelines set forth here.


\subsection{Program Summary}
\label{homework-gradecalculation:program-summary}
We're going to begin with an \emph{executive summary} of what the
first homework assignment will actually accomplish. We want
to train your brain early about the importance of not only
understanding what you are doing but also the great
importance of being able to explain your ideas to others.

Our first program is based on a common task that every
course professor/instructor needs to do: make grades. In
any given course, there is a \emph{grading scale} and a set of
\emph{categories}.


\subsection{Details}
\label{homework-gradecalculation:details}
This is based on the idea of Dr. Thiruvathukal's own
legendary course syllabus.
We're going to start
by assuming that there is a fixed set of categories.
As an example we assume Dr. Thiruvathukal's categories.

In the example below we work out for
Dr. Thiruvathukal's weights in each category,
though your program should prompt
the user for these integer percentages:
\begin{itemize}
\item {} 
exams - 40\% (integer weight is 40)

\item {} 
labs - 15\% (weight 15)

\item {} 
homework - 15\% (weight 15)

\item {} 
project - 20\% (weight 20)

\item {} 
participation - 10\% (weight 10)

\end{itemize}

Your program will prompt the user for each the weights
for each of the categories. These weights will be entered
as integers, which must add up to 100.

If the weights do not add up to 100, print a message and
end the program. You can use an \code{if-else} construction
here.  An alternative is an \code{if} statement to test for a bad sum.
In the block of statements that go with the \code{if} statement,
you can put not only the message to the user, but also a
statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{return}\PYG{p}{;}
\end{Verbatim}

Recall that a function ends when a return statement is reached.
You may not have heard that this can also be used
with a \code{void} function.  In a \code{void} function
there is no return value in the \code{return} statement.

Assuming the weights add to 100, then we will use
these weights as \emph{floating point} numbers to compute your
grade. We will be using \code{double}, which gives you the
best precision when it comes to floating-point arithmetic.

We'll talk in class about why we want the weights to be
integers. Because floating-point mathematics is not 100\%
precise, it is important that we have an accurate way
to know that the weights \emph{really add up} to 100. The only
way to be assured of this is to use \emph{integers}. We will
actually use floating-point calculations to compute the
grade, because we have a certain tolerance for errors at
this stage. (This is a fairly advanced topic that is
covered extensively in courses like COMP 264/Systems
Programming and even more advanced courses like Numerical
Analysis, Comp 308.)

We are going to pretend
that we already know our score (as a percentage) for each
one of these categories, so it will be fairly simple to
compute the grade.

For each category, you will define a weight (int) and a
score (double). Then you will sum up the weight * score and
divide by 100.0 (to get a double-precision floating-point
result).

This is best illustrated by example.

George is a student in COMP 170. He has the following
averages for each category to date:
\begin{itemize}
\item {} 
exams: 50\%

\item {} 
labs: 100\%

\item {} 
homework: 100\%

\item {} 
project: 100\%

\item {} 
participation: 5\%

\end{itemize}

The following session with the \code{csharp} interpreter shows
the how you would declare all of the needed variables and
the calculation to be performed:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{exam\PYGZus{}weight} \PYG{p}{=} \PYG{l+m}{4}\PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{lab\PYGZus{}weight} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{hw\PYGZus{}weight} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{project\PYGZus{}weight} \PYG{p}{=} \PYG{l+m}{2}\PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{participation\PYGZus{}weight} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{p}{;}

\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{double} \PYG{n}{exam\PYGZus{}grade} \PYG{p}{=} \PYG{l+m}{5}\PYG{l+m}{0.0}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{double} \PYG{n}{lab\PYGZus{}grade} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{double} \PYG{n}{homework\PYGZus{}grade} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{double} \PYG{n}{project\PYGZus{}grade} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{double} \PYG{n}{participation\PYGZus{}grade} \PYG{p}{=} \PYG{l+m}{5}\PYG{p}{;}

\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{ShowVars}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{exam\PYGZus{}weight} \PYG{p}{=} \PYG{l+m}{4}\PYG{l+m}{0}
\PYG{k+kt}{double} \PYG{n}{lab\PYGZus{}weight} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{5}
\PYG{k+kt}{int} \PYG{n}{hw\PYGZus{}weight} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{5}
\PYG{k+kt}{int} \PYG{n}{project\PYGZus{}weight} \PYG{p}{=} \PYG{l+m}{2}\PYG{l+m}{0}
\PYG{k+kt}{int} \PYG{n}{participation\PYGZus{}weight} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}
\PYG{k+kt}{double} \PYG{n}{exam\PYGZus{}grade} \PYG{p}{=} \PYG{l+m}{5}\PYG{l+m}{0}
\PYG{k+kt}{double} \PYG{n}{homework\PYGZus{}grade} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}
\PYG{k+kt}{double} \PYG{n}{lab\PYGZus{}grade} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}
\PYG{k+kt}{double} \PYG{n}{project\PYGZus{}grade} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}
\PYG{k+kt}{double} \PYG{n}{participation\PYGZus{}grade} \PYG{p}{=} \PYG{l+m}{5}
\end{Verbatim}

This is intended only to be as an example though. Your
program must ask the user to enter each of these variables.

Here is an example of how to prompt for an exam weight and
grade:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Enter the weight for exams: "}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Enter} \PYG{n}{the} \PYG{n}{weight} \PYG{k}{for} \PYG{n}{exams}\PYG{p}{:}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{input} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{exam\PYGZus{}weight} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{input}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"You entered \PYGZob{}0\PYGZcb{} for exams."}\PYG{p}{,} \PYG{n}{exam\PYGZus{}weight}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{You} \PYG{n}{entered} \PYG{l+m}{4}\PYG{l+m}{0} \PYG{k}{for} \PYG{n}{exams}\PYG{p}{.}
\end{Verbatim}

The code is similar for entering the exam grade. Where you
see the \code{int} type, you'll want to use \code{double}. We are
going to leave this part to your imagination.

Once we have all of the weights and scores entered, we
can calculate the grade as follows.  This is a long
expression: It is continued on multiple lines.  Recall all
the \code{\textgreater{}} sybols are csharp prompts, not part of the
expression:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{double} \PYG{n}{grade} \PYG{p}{=} \PYG{p}{(}\PYG{n}{exam\PYGZus{}weight} \PYG{p}{*} \PYG{n}{exam\PYGZus{}grade} \PYG{p}{+}
      \PYG{p}{\textgreater{}} \PYG{n}{homework\PYGZus{}weight}\PYG{p}{*} \PYG{n}{homework\PYGZus{}grade} \PYG{p}{+}
      \PYG{p}{\textgreater{}} \PYG{n}{lab\PYGZus{}weight} \PYG{p}{*} \PYG{n}{lab\PYGZus{}grade} \PYG{p}{+} \PYG{n}{project\PYGZus{}weight} \PYG{p}{*} \PYG{n}{project\PYGZus{}grade} \PYG{p}{+}
      \PYG{p}{\textgreater{}} \PYG{n}{participation\PYGZus{}weight} \PYG{p}{*} \PYG{n}{participation\PYGZus{}grade}\PYG{p}{)} \PYG{p}{/} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0.0}\PYG{p}{;}
\end{Verbatim}

Then you can display the grade as a percentage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Your grade is \PYGZob{}0\PYGZcb{}\PYGZpc{}"}\PYG{p}{,} \PYG{n}{grade}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Your} \PYG{n}{grade} \PYG{k}{is} \PYG{l+m}{7}\PYG{l+m}{0.5}\PYG{p}{\PYGZpc{}}
\end{Verbatim}

Now for the fun part. We will use \code{if} statements to
print the letter grade. You will actually need to use
multiple \code{if} statements to test the conditions. A way
of thinking of how you would write the logic for determining
your grade is similar to how you tend to think of the \emph{best}
grade you can \emph{hope for} in any given class. (We know that
we used to do this as students.)

Here is the thought process:
\begin{itemize}
\item {} 
If my grade is 93 (93.0) or higher, I'm getting an A.

\item {} 
If my grade is 90 or higher (but less than 93), I
am getting an A-.

\item {} 
If my grade is 87 or higher (but less than 90), I
am getting a B+.

\item {} 
And so on...

\item {} 
Finally, if I am less than 60, I am unlikely to pass.

\end{itemize}

We'll come to see how \emph{logic} plays a major role in
computer science--sometimes even more of a role than
other mathematical aspects. In this particular program,
however, we see a bit of the best of both worlds. We're
doing \emph{arithmetic} calculations to \emph{compute} the grade.
But we are using \emph{logic} to determine the grade in the
cold reality that we all know and love: the bottom-line
grade.

This assignment is listed in the data chapter,
because you can do most all of it with tools
learned so far.  Add the parts with \code{if} statements
when you have been introduced to \code{if} statements.
(Initially be sure to use data that makes the
weights actually add up to 100.)

You should be able to write the program more concisely
and readably if you use functions developed
in class for the prompting and user input.


\subsection{Usage}
\label{homework-gradecalculation:usage}
Here is sample output from two runs of the program.
The only data entered by the user are
show in \textbf{boldface} for illustration here.

One successful run with the data used above:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Enter weights for each part as an integer
\item[] percentage of the final grade:
\item[] Exams: \textbf{40}
\item[] Labs: \textbf{15}
\item[] Homework: \textbf{15}
\item[] Project: \textbf{20}
\item[] Participation: \textbf{10}
\item[] 
\item[] Enter decimal numbers for the averages in each part:
\item[] Exams: \textbf{50}
\item[] Labs: \textbf{100}
\item[] Homework: \textbf{100}
\item[] Project: \textbf{100}
\item[] Participation: \textbf{5}
\item[] 
\item[] Your grade is 70.5\%
\item[] Your letter grade is C-.
\end{DUlineblock}
\end{quote}

A run with bad weights:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Enter weights for each part as an integer
\item[] percentage of the final grade:
\item[] Exams: \textbf{30}
\item[] Labs: \textbf{10}
\item[] Homework: \textbf{10}
\item[] Project: \textbf{10}
\item[] Participation: \textbf{10}
\item[] 
\item[] Your weights add to 70, not 100.
\item[] This grading program is ending.
\end{DUlineblock}
\end{quote}


\chapter{Defining Functions of your Own}
\label{functions:defining-functions-of-your-own}\label{functions::doc}\label{functions:defining-own-functions}
\index{syntax template!typography}\index{typography!syntax template}

\section{Syntax Template Typography}
\label{typography:syntax-template-typography}\label{typography:index-0}\label{typography::doc}\label{typography:id1}
When new C\# syntax is introduced, the usual approach will be to
give both specific examples and general templates. In general
templates for C\# syntax the typeface indicates the the category
of each part:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textbf{
Typeface
} & \textbf{
Meaning
}\\\hline

\code{Typewriter font}
 & 
Text to be written \emph{verbatim}
\\\hline

\emph{Emphasized}
 & 
A place where you can use an arbitrary
expression.
\\\hline

\textbf{Bold}
 & 
A place where you can use an arbitrary
identifier.
\\\hline

Normal text
 & 
A description of what goes in that position,
without giving explicit syntax
\\\hline
\end{tabulary}


An attempt is made with the parts that are not verbatim to be
descriptive of the use expected.

We will use these conventions shortly in the discussion of function
syntax, and will continue to use the conventions throughout the
notes.

\index{function!definition}\index{definition!function}

\section{A First Function Definition}
\label{firstfunc:index-0}\label{firstfunc::doc}\label{firstfunc:a-first-function}\label{firstfunc:a-first-function-definition}
If you know it is the birthday of a friend, Emily, you might tell
those gathered with you to sing ``Happy Birthday to Emily''.

We can make C\# display the song. \emph{Read}, and run if you like,
the example program \code{birthday1.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday1}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Emily."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Here the song is just a part of the \code{Main} method that is in
every program.

Note that we are using a function already provided to us,
\code{Console.WriteLine}.  We can use it over and over, wherever we like.
We can alter its behavior by including a different parameter.
Now we look further at writing and using your own functions.

If we
want this song to be just part of a larger program, and be able to refer
to it repeatedly and easily, we might like
to package it separately.
You would probably not repeat the whole song to let others know
what to sing. You would give a request to sing via a descriptive
name like ``Happy Birthday to Emily''.

In C\# we can also give a name like \code{happyBirthdayEmily}, and
associate the name with whole song by using a new
\emph{function definition}, also called a \emph{method}. We will see many variations
on method definitions.  Later we will see definitions that are
attached to a particular object.
For now the simpler cases do not involve creating a type of object,
but there is an extra word needed to distinguish a function definition
\emph{not} attached to  on object, \code{static}.
We will also shortly look at functions more like
the functions from math class, that produce or \emph{return} a value.  In
this simple case we will not deal with returning a value.
This also requires a special word in the heading:  \code{void}.  A \code{void}
function will just be a shorthand name for something to do, a procedure
to follow, in this case
printing out the Happy Birthday song for Emily.  (Note that
the \code{Main} method for a program is also \code{static void}.
This \emph{does} your whole program and is not attached to an object.)

\emph{Read} for now:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday2}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Emily."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}   
      \PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Hip hip hooray!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

There are several parts of the syntax for a function definition to
notice:

Line 5: The \emph{heading} starts with \code{static void}, the name of the function,
and then parentheses.  A more general syntax for functions that just \emph{do}
something is
\begin{quote}

\code{static void} \textbf{function\_name}\code{()}
\end{quote}

Lines 6-11: The remaining lines form the function \emph{body}.  They are enclosed
in braces.  By convention the lines inside the braces are indented by a
consistent amount. Four spaces is common indentation.

The whole definition does just that: \emph{defines} the meaning of the
name \code{happyBirthdayEmily}, but it does not do anything else yet -
for example, the definition itself does not make anything be
printed yet. This is our first example of altering the order of
execution of statements from the normal sequential order. This is
important: the statements in the function \emph{definition} are \emph{not}
executed as C\# first passes over the lines.
The only part of a program that is automatically executed is \code{Main}.
Hence \code{Main} better refer to the newly defined function....

Look at the first statement inside Main, line 15:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Note that the \code{static void} of the function definition is missing,
but we still have the function name and parentheses.
C\# goes back and looks up
the definition, and only then, executes the code inside the
function definition. The term for this action is a \emph{function call}
or function \emph{invocation}.  In this simple situation the format is
\begin{quote}

\emph{function\_name}\code{()}
\end{quote}

Can you predict what the program will do?  Note the two function calls
to \code{happyBirthdayEmily}.  To see, load and run \code{birthday2.cs}.

\index{function!execution sequence}\index{execution!sequence, function}\index{sequence!function execution}
The \emph{execution} sequence for the program is different from the
\emph{textual} sequence.  Execution always starts in Main:
\begin{enumerate}
\item {} 
Line 13: Main is where execution starts, and initially proceeds
sequentially.

\item {} 
Line 15: the function is called while this location is
remembered.

\item {} 
Lines 5-11: Jump!  The code of the function is executed for the first
time, printing out the song.

\item {} 
End of line 15: Back from the function call. continue on.

\item {} 
Line 16:  Just to mix things up, print out a ``Hip, hip, hooray''.

\item {} 
Line 17: the function is called again while this location is
remembered.

\item {} 
Lines 5-11: The function is executed again, printing out the song
again.

\item {} 
End of line 17: Back from the function call, but at this point
there is nothing more in \code{Main}, and execution stops.

\end{enumerate}

Functions alter execution order in several ways: by statements not
being executed as the definition is first read, and then when the
function is called during execution, jumping to the function code,
and back at the the end of the function execution.

If it also happens to be Andre's birthday, we might define a
function \code{happyBirthdayAndre}, too. Think how to do that before
going on ....


\section{Multiple Function Definitions}
\label{multfunc::doc}\label{multfunc:multiple-function-definitions}\label{multfunc:id1}
Here is example program \code{birthday3.cs} where we add a function
\code{happyBirthdayAndre}, and call them both. Guess what happens, and
then load and try it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday3}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}   
       \PYG{n}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
       \PYG{n}{happyBirthdayAndre}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthdayEmily}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Emily."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthdayAndre}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}   
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear Andre."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Again, definitions are remembered and execution starts in \code{Main}.
The order in which the function definitions are given does not matter
to C\#.  It is a human choice.  For variety I show \code{Main} first.  This
means a human reading in order gets an overview of what is happening
by looking at Main, but does not know the details until reading the
definitions of the birthday functions.

Detailed order of execution:
\begin{enumerate}
\item {} 
Line 5: Start on \code{Main}

\item {} 
Line 7. This location is remembered as execution jumps to
\code{happyBirthdayEmily}

\item {} 
Lines 11-17 are executed and Emily is sung to.

\item {} 
Return to the end of Line 7: Back from \code{happyBirthdayEmily}
function call

\item {} 
Line 8: Now \code{happyBirthdayAndre} is called as this location is
remembered.

\item {} 
Lines 19-25: Sing to Andre

\item {} 
Return to the end of line 8: Back from \code{happyBirthdayAndre}
function call, done with \code{Main};
at the end of the program

\end{enumerate}

The calls to the birthday functions
\emph{happen} to be in the same order as their definitions, but that is
arbitrary. If the two lines of the body of \code{Main} were swapped,
the order of
operations would change.

Functions that you write can also call other functions you write.
In this case Main calls each of the birthday functions.


\subsection{Poem Function Exercise}
\label{multfunc:poem-function-exercise}
Write a program, \code{poem.cs}, that defines a function that
prints a \emph{short} poem or song verse. Give a meaningful name to the
function. Have the program call the function three times,
so the poem or verse is repeated three times.

\index{function!parameter}\index{parameter!function}

\section{Function Parameters}
\label{funcparam:index-0}\label{funcparam::doc}\label{funcparam:function-parameters}\label{funcparam:id1}
As a young child, you probably heard Happy Birthday sung to a
couple of people, and then you could sing to a new person, say
Maria, without needing to hear the whole special version with
Maria's name in it word for word. You had the power of
\emph{abstraction}. With examples like the versions for Emily and Andre,
you could figure out what change to make it so the song could be
sung to Maria!

Unfortunately, C\# is not that smart. It needs explicit rules.
If you needed to explain \emph{explicitly} to someone how Happy Birthday
worked in general, rather than just by example, you might say
something like this:

First you have to be \emph{given} a person's name. Then you sing the
song with the person's name inserted at the end of the third line.

C\# works something like that, but with its own syntax. The term
``person's name'' serves as a stand-in for the actual data that
will be used, ``Emily'', ``Andre'', or ``Maria''. This is just like
the association with a variable name in C\#. ``person's name''
is not a legal C\# identifier, so we will use just \code{person} as
this stand-in.  It will be a variable in the program,
so it needs a type in C\#.  The names are strings,
so the type of \code{person} is \code{string}.

The function definition indicates that the variable name \code{person}
will be used inside the function by inserting it between the
parentheses of the definition, preceeded by its type.
Then in the body of the definition
of the function, person is used in place of the real data for any
specific person's name. Read and then run example program
\code{birthday4.cs}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday4}
\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthday}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{person}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear "} \PYG{p}{+} \PYG{n}{person} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}   
        \PYG{n}{happyBirthday}\PYG{p}{(}\PYG{l+s}{"Emily"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{happyBirthday}\PYG{p}{(}\PYG{l+s}{"Andre"}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

In the definition heading for \code{happyBirthday}, \code{person} is
referred to as a \emph{parameter}, or a \emph{formal parameter}. This
variable name is a \emph{placeholder} for the real name of the person
being sung to.

Main now has two calls to the same function,
but between the parentheses, where there was the palceholder \code{person}
in the definition, now we have the actual people being sung to.
The value between the parentheses here in the function call
is referred to as an \emph{argument} or \emph{actual parameter} of the
function call. The argument supplies the actual data to be used in
the function execution. When the call is made, C\# does this by
associating the formal parameter name \code{person} with the actual
parameter data, as in an assignment statement. In the first call,
this actual data is \code{'Emily'}. We say the actual parameter value
is \emph{passed} to the function.

The execution in greater detail:
\begin{enumerate}
\item {} 
Lines 13: Execution starts in Main.

\item {} 
Line 15: Call to \code{happyBirthday}, with actual parameter
\code{'Emily'}.

\item {} 
Line 5: \code{'Emily'} is passed to the function, so
\code{person = 'Emily'}.

\item {} 
Lines 7-10: The song is printed, with \code{'Emily'} used as the
value of \code{person} in line 9: printing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Happy} \PYG{n}{Birthday}\PYG{p}{,} \PYG{n}{dear} \PYG{n}{Emily}\PYG{p}{.}
\end{Verbatim}

\item {} 
End of line 15 after returning from the function call

\item {} 
Line 16: Call to \code{happyBirthday}, this time with actual
parameter \code{'Andre'}

\item {} 
Line 5: \code{'Andre'} is passed to the function, so
\code{person = 'Andre'}.

\item {} 
Lines 7-10: The song is printed, with \code{'Andre'} used as the
value of \code{person} in line 9: printing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Happy} \PYG{n}{Birthday}\PYG{p}{,} \PYG{n}{dear} \PYG{n}{Andre}\PYG{p}{.}
\end{Verbatim}

\item {} 
End of line 16 after returning from the function call,
and the program is over.

\end{enumerate}

The beauty of this system is that the same function definition can
be used for a call with a different actual parameter variable, and
then have a different effect. The value of the variable person is
used in the third line of \code{happyBirthday}, to put in whatever
actual parameter value was given.

\index{abstraction}
This is the power of \emph{abstraction}. It is one application of the
most important principal in programming. Rather than have a number
of separately coded parts with only slight variations, see where it
is appropriate to combine them using a function whose parameters
refer to the parts that are different in different situations. Then
the code is written to be simultaneously appropriate for the
separate specific situations, with the substitutions of the right
parameter values.

\begin{notice}{note}{Note:}
Be sure you completely understand \code{birthday4.cs}
and the sequence of execution!  It illustrates extremely
important ideas that many people miss the first time!  It is
essential to understand the difference between
\begin{enumerate}
\item {} 
\emph{Defining} a function (lines 5-11)
with the heading including \emph{formal} parameter name and type,
where the code is merely instructions to be remembered,
not acted on immediately.

\item {} 
\emph{Calling} a function with an \emph{actual} paramerer value to be
substituted for the formal parameter,
(with \emph{no} type included!) and have the function
code actually \emph{run} when the instruction containing the call
is run.  Also note that the function can be
called multiple times with different expressions as the
actual parameter (line 15 and again in line 16).

\end{enumerate}
\end{notice}

We can combine function parameters with user input, and have the
program be able to print Happy Birthday for anyone. Check out the
main method and run \code{birthday\_who.cs}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Birthday\PYGZus{}Who}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{happyBirthday}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{person}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday, dear "} \PYG{p}{+} \PYG{n}{person} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"Happy Birthday to you!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{userName}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Who would you like to sing Happy Birthday to?"}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{userName} \PYG{p}{=} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{happyBirthday}\PYG{p}{(}\PYG{n}{userName}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This last version illustrates several important ideas:
\begin{enumerate}
\item {} 
There are more than one way to get information into a function:
\begin{enumerate}
\item {} 
Have a value passed in through a parameter (from line 18 to line 5).

\item {} 
Prompt the user, and obtain data from the keyboard (lines 16-17).

\end{enumerate}

\item {} 
It is a good idea to separate the \emph{internal} processing of data
from the \emph{external} input from the user by the use of distinct
functions. Here the user interaction is in \code{main}, and the data
is manipulated in \code{happyBirthday}.

\item {} 
In the first examples of actual parameters, we used literal
values. In general an actual parameter can be an expression. The
expression is evaluated before it is passed in the function call.
One of the simplest expressions is a plain variable name, which is
evaluated by replacing it with its associated value. Since it is
only the value of the actual parameter that is passed, not any
variable name, there is \emph{no need} to have a variable name used in
an actual parameter match a formal parameter name. (Here we have the
value of \code{userName} in \code{main} becoming the value of \code{person}
in \code{happyBirthday}.)

\end{enumerate}


\subsection{Birthday Function Exercise}
\label{funcparam:birthdayfunctionex}\label{funcparam:birthday-function-exercise}
Make your own further change to \code{birthday4.cs} and save it as
\code{birthdayMany.cs}: Add a function call
(but \emph{not} another function \emph{definition}), so Maria gets a verse, in
addition to Emily and Andre. Also print a blank line between
verses. (There ae two ways to handle the blank lines:
You may \emph{either} do this by adding a print line to the
function definition, \emph{or} by adding a print line between all calls to
the function.  Recall that if you give Console.WriteLine an empty
parameter list, it just goes to the next line.)

\index{function!parameter}\index{parameter!function}

\section{Multiple Function Parameters}
\label{funcparam2:index-0}\label{funcparam2:multiple-function-parameters}\label{funcparam2::doc}
A function can have more than one parameter in a parameter list
separated by commas. Each formal parameter name is preceded by its type.
For example the example program \code{addition1.cs}
uses
a function to make it easy to display many sum problems. Read and
follow the code, and then run:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Addition1}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{sumProblem}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{sum} \PYG{p}{=} \PYG{n}{x} \PYG{p}{+} \PYG{n}{y}\PYG{p}{;}
      \PYG{k+kt}{string} \PYG{n}{sentence} \PYG{p}{=} \PYG{l+s}{"The sum of "} \PYG{p}{+} \PYG{n}{x} \PYG{p}{+} \PYG{l+s}{" and "} \PYG{p}{+} \PYG{n}{y} \PYG{p}{+} \PYG{l+s}{" is "} \PYG{p}{+} \PYG{n}{sum} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sentence}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{sumProblem}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{3}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sumProblem}\PYG{p}{(}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{p}{,} \PYG{l+m}{5}\PYG{l+m}{3}\PYG{l+m}{5}\PYG{l+m}{7}\PYG{l+m}{9}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter an integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter another integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sumProblem}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\index{parameter!actual}\index{actual!parameter}\index{parameter!formal}\index{formal!parameter}
The actual parameters in the function call are evaluated left to
right, and then these values are associated with the formal
parameter names in the function definition, also left to right. For
example a function call with actual parameters,
\code{f(actual1, actual2, actual3)}, calling a function \code{f} with
definition heading:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{formal1}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{formal2}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{formal3}\PYG{p}{)}
\end{Verbatim}

acts approximately as if the first lines executed inside the called
function \code{f} were

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{formal1} \PYG{p}{=} \PYG{n}{actual1}\PYG{p}{;}
\PYG{n}{formal2} \PYG{p}{=} \PYG{n}{actual2}\PYG{p}{;}
\PYG{n}{formal3} \PYG{p}{=} \PYG{n}{actual3}\PYG{p}{;}
\end{Verbatim}

Functions provide extremely important functionality to programs,
allowing tasks to be defined once and performed repeatedly with
different data. It is essential to see the difference between the
\textbf{formal} parameters used to describe what is done inside the function
definition (like x and y in the definition of sumProblem) and the
\textbf{actual} parameters (like 2 and 3 or 12345 and 53579)
which \emph{substitute} for the formal parameters when the function is
actually executed. \code{Main} uses three different sets
of actual parameters in the three calls to sumProblem.


\subsection{Quotient Function Exercise}
\label{funcparam2:quotient-function-exercise}\label{funcparam2:quotientfunctionex}
Modify \code{quotient.cs{}`from
:ref:{}`QuotientProblem} and save it
as \code{quotientProb.cs}.
You should create a function \code{quotientProblem} with int
parameters.  Like in the earlier versions, it should print a full
sentence with inputs, quotient, and remainder.
\code{Main}
should test the \code{quotientProblem} function
on several sets of literal values, and also test the function with
input from the user.

\index{function!return math}\index{return!math, function}\index{math!function return}\index{function!sequence}\index{sequence!function}

\section{Returned Function Values}
\label{funcreturn:returned-function-values}\label{funcreturn:index-0}\label{funcreturn::doc}\label{funcreturn:id1}
You probably have used mathematical functions in algebra class, but
they all had calculated values associated with them. For instance
if you defined
\begin{quote}

f(x)=x$^{\text{2}}$
\end{quote}

then it follows that f(3) is 3$^{\text{2}}$, and f(3)+f(4) is
3$^{\text{2}}$ + 4$^{\text{2}}$

Function calls in expressions get
replaced during evaluation by the value of the function.

The corresponding definition and examples in C\# would be the
following, taken from example program \code{return1.cs}. \emph{Read}
\emph{and run}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Return1}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
       \PYG{k}{return} \PYG{n}{x}\PYG{p}{*}\PYG{n}{x}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)} \PYG{p}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The new C\# syntax is the \emph{return statement}, with the word
\code{return} followed by an expression. Functions that return values
can be used in expressions, just like in math class. When an
expression with a function call is evaluated, the function call is
effectively replaced temporarily by its returned value. Inside the
C\# function, the value to be returned is given by the
expression in the \code{return} statement.

Since the function returns data, and all data in C\# is typed,
there must be a type given for the value returned.  Note that the
function heading does not start with \code{static void}.
In place of \code{void} is \code{int}.  The \code{void} in earlier function headings
meant nothing was returned.  The \code{int} here means that a value \emph{is}
returned and its type is \code{int}.

After the function \code{f}
finishes executing from inside

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

it is as if the statement temporarily became

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and similarly when executing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)} \PYG{p}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

the interpreter first evaluates f(3) and effectively replaces the
call by the returned result, 9, as if the statement temporarily
became

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9} \PYG{p}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and then the interpreter evaluates f(4) and effectively replaces
the call by the returned result, 16, as if the statement
temporarily became

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+m}{9} \PYG{p}{+} \PYG{l+m}{1}\PYG{l+m}{6}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

resulting finally in 25 being calculated and printed.

\textbf{C\#} functions can return any type of data, not just numbers, and
there can be any number of statements executed before the return
statement. Read, follow, and run the example program
\code{return2.cs}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Return2}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{lastFirst}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{firstName}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{lastName}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{separator} \PYG{p}{=} \PYG{l+s}{", "}\PYG{p}{;}
      \PYG{k+kt}{string} \PYG{n}{result} \PYG{p}{=} \PYG{n}{lastName} \PYG{p}{+} \PYG{n}{separator} \PYG{p}{+} \PYG{n}{firstName}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{result}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{lastFirst}\PYG{p}{(}\PYG{l+s}{"Benjamin"}\PYG{p}{,} \PYG{l+s}{"Franklin"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{lastFirst}\PYG{p}{(}\PYG{l+s}{"Andrew"}\PYG{p}{,} \PYG{l+s}{"Harrington"}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Many have a hard time following the flow of execution with functions.
Even more is involved when there are return vaues.
Make sure you completely follow the details of the execution:
\begin{enumerate}
\item {} 
Lines 12: Start at Main

\item {} 
Line 14: call the function, remembering where to return

\item {} 
Line 5: pass the parameters: \code{firstName = "Benjamin"};
\code{lastName = "Franklin"}

\item {} 
Line 7: Assign the variable \code{separator} the value \code{", "}

\item {} 
Line 8: Assign the variable \code{result} the value of
\code{lastName + separator + firstName} which is
\code{"Franklin" + ", " + "Benjamin"}, which evaluates to
\code{"Franklin, Benjamin"}

\item {} 
Line 9: Return \code{"Franklin, Benjamin"}

\item {} 
Line 14: Use the value returned from the function call so the line
effectively becomes  \code{Console.WriteLine("Franklin, Benjamin");},
so print it.

\item {} 
Line 15: call the function with the new actual parameters,
remembering where to return

\item {} 
Line 5: pass the parameters: \code{firstName = "Andrew"};
\code{lastName = "Harrington"}

\item {} 
Lines 7-9: ... calculate and return \code{"Harrington, Andrew"}

\item {} 
Line 15: Use the value returned by the function and print
\code{"Harrington, Andrew"}

\end{enumerate}

Compare \code{return2.cs} and \code{addition1.cs}, from the previous
section. Both use functions. Both print, but where the printing \emph{is
done} differs. The function \code{sumProblem} prints directly inside
the function and returns nothing explicitly. On the other hand
\code{lastFirst} does not print anything but returns a string. The
caller gets to decide what to do with the string, and above it is
printed in \code{Main}.

In general functions should do a single thing.
You can easily combine a sequence of functions, and you have more
flexibility in the combinations
if each does just one unified thing.  The function
sumProblem in \code{addition1.cs} does two thing:  It creates a sentence,
and prints it.  If that is all you have, you are out of luck if you want
to do something different with the sentence string.  A better way is
to have a functon that just creates the sentence, and returns it for
whatever further use you want.  After returning that value,
printing is one possibility, done in
\code{addition2.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Addition2}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{sumProblemString}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{y}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{sum} \PYG{p}{=} \PYG{n}{x} \PYG{p}{+} \PYG{n}{y}\PYG{p}{;}
      \PYG{k+kt}{string} \PYG{n}{sentence} \PYG{p}{=} \PYG{l+s}{"The sum of "} \PYG{p}{+} \PYG{n}{x} \PYG{p}{+} \PYG{l+s}{" and "} \PYG{p}{+} \PYG{n}{y} \PYG{p}{+} \PYG{l+s}{" is "} \PYG{p}{+} \PYG{n}{sum} \PYG{p}{+} \PYG{l+s}{"."}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{sentence}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sumProblemString}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sumProblemString}\PYG{p}{(}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{p}{,} \PYG{l+m}{5}\PYG{l+m}{3}\PYG{l+m}{5}\PYG{l+m}{7}\PYG{l+m}{9}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter an integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{a} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"Enter another integer: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{b} \PYG{p}{=} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{sumProblemString}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\textbf{In class recommendation}:  Improve Miles' original example
with functions.  What makes sense? The original example is saved
as \code{GlazerCalc1.cs}.


\subsection{Quotient String Return Exercise}
\label{funcreturn:quotient-string-return-exercise}\label{funcreturn:quotientstringex}
Create \code{quotientReturn.cs} by modifying \code{quotientProb.cs} in
{\hyperref[funcparam2:quotientfunctionex]{\emph{Quotient Function Exercise}}} so that the program accomplishes the same
thing, but everywhere change the quotientProblem function into one
called \code{quotientString} that merely \emph{returns} the string rather
than printing the string directly. Have \code{Main} print
the result of each call to the \code{quotientString} function.

\index{function!consumer}\index{consumer!function}\index{function!writer}\index{writer!function}

\section{Two Roles: Writer and Consumer of Functions}
\label{writerconsumer:index-0}\label{writerconsumer:two-roles-writer-and-consumer-of-functions}\label{writerconsumer:two-roles}\label{writerconsumer::doc}
The remainder of this section covers finer
points about functions that you might skip on a first reading.

We are only doing tiny examples so far to get the basic idea of
functions. In much larger programs, functions are useful to manage
complexity, splitting things up into logically related, modest
sized pieces. Programmers are both writers of functions and
consumers of the other functions called inside their functions. It
is useful to keep those two roles separate:

The user of an already written function needs to know:
\begin{enumerate}
\item {} 
the name of the function

\item {} 
the order and meaning of parameters

\item {} 
what is returned or produced by the function

\end{enumerate}

\emph{How} this is accomplished is not relevant at this point. For
instance, you use the work of the C\# development team, calling
functions that are built into the language. You need know the three
facts about the functions you call. You do not need to know exactly
\emph{how} the function accomplishes its purpose.

On the other hand when you \emph{write} a function you need to figure
out exactly how to accomplish your goal, name relevant variables,
and write your code, which brings us to the next section.

\index{local!scope}\index{scope!local}

\section{Local Scope}
\label{localscope:local-scope}\label{localscope:index-0}\label{localscope::doc}\label{localscope:id1}
For the logic of writing functions, it is important that the writer
of a function knows the names of variables inside the function. On
the other hand, if you are only using a function, maybe written by
someone unknown to you, you should not care what names are given to
values used internally in the implementation of the function you
are calling. C\# enforces this idea with \emph{local scope} rules:
Variable names initialized and used inside one function are
\emph{invisible} to other functions. Such variables are called \emph{local}
variables. For example, an elaboration of the earlier program
\code{return2.cs} might have its \code{lastFirst} function with its local
variable \code{separator}, but it might also have another function
that defines a \code{separator} variable, maybe with a different value
like \code{"\textbackslash{}n"}. They would not conflict. They would be
independent. This avoids lots of errors!

For example, the following code in the example program
\code{badScope.cs} causes an execution error. Read it and try to run it, and
see:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{BadScope}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{;}
      \PYG{n}{f}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//ERROR f doesn't know about the x defined in Main}
   \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The error that Mono gives is pretty clear:
\begin{quote}

The name `x' does not exist in the current context.
\end{quote}

The context for \code{x} is the function \code{f}, not \code{Main}.
We will fix this error below.

If you do want local data from one function to go to another,
define the called function so it includes parameters! Read and
compare and try the program \code{goodscope.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{BadScope}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{;}
      \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{Verbatim}

With parameter passing, the parameter name \code{x} in the function
\code{f} does not need to match the name of the actual parameter in
the calling function \code{Main}. The definition of \code{f} could just as well have been:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{whatever}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{whatever}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\index{global!constant}\index{constant!global}

\section{Static Variables}
\label{staticvariables:index-0}\label{staticvariables:static-variables}\label{staticvariables::doc}\label{staticvariables:id1}
You may define \emph{static variables} (variables defined inside the class,
but outside of any function definition).
These variables are visible inside all of your functions.
Instead of local scope, static variables have \emph{class scope}.
It is good programming practice generally to avoid defining static variables and
instead to put your variables inside functions and explicitly pass
them as parameters where needed. One common exception
will arise when we get to defining objects.  For now a
good reason for static variables is constants:
A \emph{constant} is a name that you give a fixed data value to.
You can then use the name of the fixed data value in
expressions anywhere in the class.
A simple example program is \code{constant.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Constant}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n}{PI} \PYG{p}{=} \PYG{l+m}{3.14159265358979}\PYG{p}{;} \PYG{c+c1}{// constant, value not reset}

   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{circleArea}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{radius}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{PI}\PYG{p}{*}\PYG{n}{radius}\PYG{p}{*}\PYG{n}{radius}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{circumference}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{radius}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{l+m}{2}\PYG{p}{*}\PYG{n}{PI}\PYG{p}{*}\PYG{n}{radius}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"circle area with radius 5: "} \PYG{p}{+} \PYG{n}{circleArea}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"circumference with radius 5:"} \PYG{p}{+} \PYG{n}{circumference}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

See that \code{PI} is used in two functions without being declared locally.

By convention, names for constants are all capital letters.
\phantomsection\label{notusereturn:string-char}
\index{function!scope not use return value}\index{scope!not use return value, function}\index{not use return value!function scope}

\section{Not using Return Values}
\label{notusereturn:index-0}\label{notusereturn::doc}\label{notusereturn:not-using-return-values}
\begin{notice}{note}{Todo}

Andy new
\end{notice}

\index{assignment!functions}

\section{Assignment: Functions}
\label{assignment-functions:index-0}\label{assignment-functions:assignment-functions}\label{assignment-functions::doc}
\begin{notice}{note}{Todo}

George:
? tie into later work; good CS example?
\end{notice}


\chapter{Basic String Operations}
\label{basicstringops:basic-string-operations}\label{basicstringops::doc}\label{basicstringops:basic-string-ops}\phantomsection\label{stringindexing:string-indexing}
\index{string!index}\index{index!string}

\section{String Indexing}
\label{stringindexing:index-0}\label{stringindexing::doc}\label{stringindexing:id1}
Strings are composed of characters, but be careful of the different
kinds of quotes, single for individual characters, double for strings
of 0 or more characters:
`u' (single quotes) is a char type literal, while ``u'' is a string
literal, referencing a string object. While ``you'' is a legal string
literal, `you' generates a compiler error (too many characters - only
one allowed).

Many of the operations on strings depend upon counting positions of characters
in the string. In C\#, positions are counted \emph{starting at 0}, not 1.
The indices of the characters in the string ``coding'' are labeled:

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|}
\hline

Index
 & 
0
 & 
1
 & 
2
 & 
3
 & 
4
 & 
5
\\\hline

Character
 & 
c
 & 
o
 & 
d
 & 
i
 & 
n
 & 
g
\\\hline
\end{tabulary}


The position of a character in a string is usually referred to as the
character's \emph{index}. Note that because the indices start at 0, not 1,
the index of the last character is one less that the length of the
string. This is a common source of errors. Watch out.

You can easily create an expression that refers
to an individual character inside a string.  Use
square braces around the index of the character:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{s} \PYG{p}{=} \PYG{l+s}{"coding"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{[}\PYG{l+m}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{'d'}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{[}\PYG{l+m}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{'c'}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{[}\PYG{l+m}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{'g'}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{greeting} \PYG{p}{=} \PYG{l+s}{"Bonjour"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{greeting}\PYG{p}{[}\PYG{l+m}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{l+s+sc}{'o'}
\end{Verbatim}

Note from the single quotes that the result is a \code{char} in each case.

\index{string!method}\index{method!string}

\section{Some Instance Methods and the Length Property}
\label{stringmethods:index-0}\label{stringmethods::doc}\label{stringmethods:some-instance-methods-and-the-length-property}
Thus far we have not emphasized the use of objects, or even noted
what is an object.  Strings are a special type in C\#. We have
used string literals as parameters to functions and we have used the
special concatenation operator \code{+}.
In fact strings are objects.  Like other objects,
strings have a general notation for functions that are specially tied to the
particular type of object.  These functions are called \emph{instance methods}.
They always act on an object of the particular class, but a reference to the
object is not placed inside the parameter list, but \emph{before} the method name and
a dot as in:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{s} \PYG{p}{=} \PYG{l+s}{"hello"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"HELLO"}
\end{Verbatim}

\code{ToUpper} (converting to upper case) is particular action that makes sense
with strings.  It take s (the string object reference before the dot in this example)
and returns a new string (in upper case).  Since this action
depends only on the string itself, no further parameters are necessary,
and the parentheses after the method name are empty.  The general method syntax is
\begin{quote}

\emph{object-reference}\code{.}\textbf{methodName} \code{(}\emph{further-parameters} \code{)}
\end{quote}

More string methods are listed below, some with further parameters.

Data can also be associated with object \emph{properties}.
A property of a string is its length (an int).  References to property values
use dot notation but do not have a parameter list at the end:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{s} \PYG{p}{=} \PYG{l+s}{"Hello"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{l+m}{5}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{""}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{l+m}{0}
\end{Verbatim}

Be careful: Though 5 is the length of \code{s} in the example above,
the last character in \code{s} is \code{s{[}4{]}}.  Using \code{s{[}5{]}} would generate
an \code{IndexOutOfRangeException}.

String objects have associated string methods which can be used to
manipulate string values.
There are an enormous number of string methods, but here are just a few
of the most common ones to get you started. The
string object to which the method is being applied is referred to as
\textbf{this} string in the descriptions.  After the methods,
the length property is also listed.
In the heading \emph{this} object is not shown explicitly, so be careful
when applying these methods and the length property: In actual use
they must be
preceeded by a reference to a string, followed by a dot, as shown in
all the  examples.  The reference to \emph{this} string can be
a variable name, a literal, or any expression evaluating to a string.


\subsection{Summary of String Length and Some Instance Methods}
\label{stringmethods:string-methods-length}\label{stringmethods:summary-of-string-length-and-some-instance-methods}\begin{description}
\item[{\code{int IndexOf(string target)}}] \leavevmode
Returns the index of the begining of the first occurrence of the
string \code{target}
in \textbf{this} string object. Returns -1 if \code{target} not found. Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{greeting} \PYG{p}{=} \PYG{l+s}{"Bonjour"}\PYG{p}{,} \PYG{n}{part} \PYG{p}{=} \PYG{l+s}{"jo"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{greeting}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{n}{part}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{greeting}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{"jot"}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{-}\PYG{l+m}{1}
\end{Verbatim}

\item[{\code{string Substring(int start)}}] \leavevmode
Returns the substring of \textbf{this} string object starting from index \code{start}
through to the end of the string object.  Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{name} \PYG{p}{=} \PYG{l+s}{"Sheryl Crow"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{name}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{l+m}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"Crow"}
\end{Verbatim}

\item[{\code{string Substring(int start, int len)}}] \leavevmode
Returns the substring of \textbf{this} string object starting from index \code{start},
including a total of \code{len} characters.  Example:

\begin{Verbatim}[commandchars=\\\{\}]
csharp\textgreater{} string name = "Sheryl Crow";{}`{}`
csharp\textgreater{} name.Substring(3,5);
"ryl C"
\end{Verbatim}

\item[{\code{string ToUpper()}}] \leavevmode
Return a string like \textbf{this} string, except all in upper case.  Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"Hi Jane!"}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"HI JANE!"}
\end{Verbatim}

\item[{\code{string ToLower()}}] \leavevmode
Return a string like \textbf{this} string, except all in lower case.  Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"Hi Jane!"}\PYG{p}{.}\PYG{n}{ToLower}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"hi jane!"}
\end{Verbatim}

\item[{\code{int Length}}] \leavevmode
Property referring to the length of \textbf{this} string object. Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{greeting} \PYG{p}{=} \PYG{l+s}{"Bonjour"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{greeting}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}  \PYG{c+c1}{//no parentheses}
\PYG{l+m}{7}
\end{Verbatim}

\end{description}

Further string methods are introduced in {\hyperref[stringmethods2:more-string-methods]{\emph{More String Methods}}}.


\subsection{Testing Strings For Equality}
\label{stringmethods:testing-strings-for-equality}
Strings can be tested for equality like numbers,
with \code{==}: \emph{two} equal signs, not the \emph{one} equal sign used for assignment.
The case of letters matters:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{s} \PYG{p}{=} \PYG{l+s}{"Hello"}\PYG{p}{;} \PYG{c+c1}{// initial value assigned}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{t} \PYG{p}{=} \PYG{l+s}{"HELLO"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s} \PYG{p}{=}\PYG{p}{=} \PYG{n}{t}\PYG{p}{;}  \PYG{c+c1}{// equality test}
\PYG{k}{false}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{ToUpper}\PYG{p}{(}\PYG{p}{)} \PYG{p}{=}\PYG{p}{=} \PYG{n}{t}\PYG{p}{;}
\PYG{k}{true}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{u} \PYG{p}{=} \PYG{l+s}{"High"}\PYG{p}{.}\PYG{n}{Substring}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// assign}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{u} \PYG{p}{=}\PYG{p}{=} \PYG{l+s}{"Hi"}\PYG{p}{;} \PYG{c+c1}{// equality test}
\PYG{k}{true}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{u} \PYG{p}{=}\PYG{p}{=} \PYG{l+s}{"High"}\PYG{p}{;}
\PYG{k}{false}
\end{Verbatim}

Hence string expressions can be used in \code{if} statements.

\index{string!problem solving}\index{problem solving!string}

\section{A Creative Problem Solution}
\label{problem-solving-replace:index-0}\label{problem-solving-replace:a-creative-problem-solution}\label{problem-solving-replace::doc}\label{problem-solving-replace:solve-string-replace}
Thus far the exercises and examples suggested have been of
a very simple form, where the idea of the steps should
have been pretty clear, and the main issue was just
translating syntax into C\#, one instruction at a time.

We still have a lot of syntax to concentrate on,
but still, early on, we wanted to get in some real thought
of problem solving.  To get very interesting you
need a number of options that might be combined in
a variety of ways.  The short list of
string methods just introduced
is likely give us enough to think about....

Here is a basic string manipulation problem:
given a string, like,
\code{"It was the best of times."},
find and replace a specified part of it by another string.
For instance replace \code{"best"} by \code{"worst"}.
In this example we would get the result:
\code{"It was the worst of times."}.

It is very important to give concrete examples to
illustrate the idea desired.  Our human brains may be
very quick to see a solution like this in a very
concrete case, but what about making it general?

First this seems like a basic logical operation worthy
of a function or method, so we need a heading.
(Confession:  there are methods in the class
string for replacement, but this is a good learning exercise,
so we are starting over on our own.)  Since
we cannot change the string class, we will write a
static function to generate the new string.

For simplicity at the moment we will only change
the first occurence, and for now we will assume the
replacement makes sense.  The following heading
(with documentation) should work:

\begin{Verbatim}[commandchars=\\\{\}]
    
    \PYG{c+cm}{/** Return s with the first occurence of target}
\PYG{c+cm}{     *  replaced by replacement.}
\PYG{c+cm}{     */}
    \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{replaceFirst}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{target}\PYG{p}{,}
                               \PYG{k+kt}{string} \PYG{n}{replacement}\PYG{p}{)}
\end{Verbatim}

As soon as we have the calling interface, it is good to be thinking
of the tests it should pass.  Here is a Main program written
to test the function in different ways and display the results:

\begin{Verbatim}[commandchars=\\\{\}]
    \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main} \PYG{p}{(}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{string} \PYG{n}{str1} \PYG{p}{=} \PYG{l+s}{"It was the best of times."}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{str2} \PYG{p}{=} \PYG{l+s}{"Of times it was the best."}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"str1="} \PYG{p}{+} \PYG{n}{str1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"str2="} \PYG{p}{+} \PYG{n}{str2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// to embed a quote inside a string constant, precede it by backslash(\PYGZbs{}).}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Let us do some \PYGZbs{}"cutting and pasting\PYGZbs{}" of strings!"}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{str3} \PYG{p}{=} \PYG{n}{replaceFirst}\PYG{p}{(}\PYG{n}{str1}\PYG{p}{,} \PYG{l+s}{"best"}\PYG{p}{,} \PYG{l+s}{"worse"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"str3 = str1 with best =\textgreater{} worst: "} \PYG{p}{+} \PYG{n}{str3}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{str4} \PYG{p}{=} \PYG{n}{replaceFirst}\PYG{p}{(}\PYG{n}{str2}\PYG{p}{,} \PYG{l+s}{"best"}\PYG{p}{,} \PYG{l+s}{"worse"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"str2 with best =\textgreater{} worst: "} \PYG{p}{+} \PYG{n}{str4}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{string} \PYG{n}{str5} \PYG{p}{=} \PYG{n}{replaceFirst}\PYG{p}{(}\PYG{n}{str3}\PYG{p}{,} \PYG{l+s}{"worse"}\PYG{p}{,} \PYG{l+s}{"best"}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"str3 with worst =\textgreater{} best: "} \PYG{p}{+} \PYG{n}{str5}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Writing tests \emph{first} is a good idea to focus you on what really
needs to be accomplished, and then running tests later is a snap!

The human brain and eys are fabulous in the way they process
many things in parallel and use tools you have accumulated over
a lifetime.  In particular this substitution idea should
seem pretty reasonable, and given any \emph{specific concrete} example,
you are likely to be able to solve it instantly, with very little
conscious effort.  Once it becomes a programming problem, with
parameters stated in general, with just placeholder names
like \code{s} and \code{target}, and given the limited set of approaches
you have in a programming language, the complexion of this
problem changes completely.  Many students guess the general problem will
be nearly as simple as the concrete exmples they do in their heads,
and then get very discouraged when the answer does not flow out of
them.  In fact it takes practice and experience, and it is easier
to handle if you acknowledge that up front!

So let's start in with the practice, and gain some experience.
With \code{s}, \code{target}, and \code{replacement} all being general, this
problem could easily be too much to contemplate at once,
so let us replace concrete examples by generality gradually.
The idea is to get to the end.  Rather than trying to jump a chasm,
we can take small steps and go around.

A basic idea is to make small incremental
changes, test at each stage, and gradually see more of the tests
(that you have already written) be satisfied.  Also, if you make a
mistake and screw up something that worked before, you can generally
focus on the small addition to see where the mistakes were.
\footnote{
We will not go far into the history of software engineering
practice here, but these incremental problem solving methods
were first widely
introduced as a part of \emph{extreme programming}.
That name gives you an idea of the newness at the time.
}

This also avoids you needing to keep too much in your head at once.

We do have code written already:  The test code.  Start by writing
something that will trivially satisfy the first concrete test.
The body of the function can be just:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{return} \PYG{l+s}{"It was the worst of times"}\PYG{p}{;}
\end{Verbatim}

This is a tiny, easy, silly looking step, but it does accomplish
two things:  It makes sure we can produce output
in the proper string form, and the test code runs, passing the
first test.

Now we gradually get more complicated.  We will continue to assume
\code{target} and \code{replacement} are as in the original example,
and \code{target} is in the same place in \code{s},
but suppose we imagine each
of the other characters in \code{s} may be something different:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{"???????????best??????????"}
\end{Verbatim}

Now we have to start thinking about what we have to work with.
We have a string, and we have string methods.
Have a look at the ideas of each method (exact syntax
not important at the moment).  Clearly we are going to have to
deal with parts of strings, and the methods to deal with parts
involve indices, so let us add to our visual model:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Index}\PYG{p}{:} \PYG{l+m}{0}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{l+m}{6}\PYG{l+m}{7}\PYG{l+m}{8}\PYG{l+m}{9}\PYG{l+m}{0}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{l+m}{6}\PYG{l+m}{7}\PYG{l+m}{8}\PYG{l+m}{9}\PYG{l+m}{0}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}
    \PYG{n}{s}\PYG{p}{:} \PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{n}{best}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}\PYG{p}{?}
\end{Verbatim}

Continue in class....  The example program stub is
\code{StringManipStub.cs}.  In general, when given a
program with ``Stub'' in it, save it under a name without the ``Stub'',
and develop that version further.  In stubs where you need to
complete a function with a return value, you will often see
a dummy choice for the return statement, just so the stub compiles.
Where the return type is string \code{"Not implemented"} is a handy
temporary choice.

When you have that function version, test it.
You will need to rename
our incremental variations so the current version has the name
used in Main.

What might further advances toward full generality be,
in small steps?  We pinned \code{best} at a specific location.
We could remove that assumption.  The location will still be
important, but we do not know it ahead of time....

A further advance would be a version that is complete
in all ways, except we still assume \code{target} is in \code{s},
but beyond that, do not assume what the three parameters are.

Finally we should allow \code{s} to not contain \code{target}.

The testing regime in Main is clear to understand and write,
but pretty primitive.  You have to look at a lot of output
every time you test.  We will come up with better testing schemes
later.
\phantomsection\label{lab-string-ops:lab-string-ops}
\index{labs!string manipulations}

\section{Lab: String Operations}
\label{lab-string-ops:index-0}\label{lab-string-ops::doc}\label{lab-string-ops:lab-string-operations}

\subsection{Goals for this lab:}
\label{lab-string-ops:goals-for-this-lab}\begin{enumerate}
\item {} 
Explore some of the properties of the pre-defined String class.

\item {} 
Write conditional statements.

\item {} 
Think about problem solving.

\end{enumerate}

This lab depends on the introductory material in earlier in this
chapter, particularly keep handy {\hyperref[stringmethods:string-methods-length]{\emph{Summary of String Length and Some Instance Methods}}}.
Be mindful of the processes developed in class filling in
{\hyperref[problem-solving-replace:solve-string-replace]{\emph{A Creative Problem Solution}}}.

Design, compile and run a C\# program to accomplish each of
the following tasks. Add one part at a time and test before trying the
next one. The program can just include a Main method, or it is neater to
split things into separate methods (all static void, with names like
ShowLength, SentenceType, LastFirst1, LastFirst),
and have Main call all the ones
you have written so far (or for testing purposes, just the one you
are working on, with the other function calls commented out).
All input from the user should be preceded by a meaningful prompt.
\begin{enumerate}
\item {} 
Read a string from the keyboard
and print the length of the string, with a label.

\item {} 
Read a sentence (string) from a line of input, and print whether
it represents a \emph{declarative} sentence (i.e. ending in a period),
\emph{interrogatory} sentence (ending in a question mark), or an
\emph{exclamation} (ending in exclamation point) or is not a sentence
(anything else).

This may be the first time you write a conditional
statement. It makes sense to only make small changes at once and build
up to final code. First you might just code it to check if a sentence is
declarative or not. Then remember you can test further cases with
\code{else if (...)}.

\item {} 
Read a name from a line of input.  Assume first and last names
are separated by a space.
Print last name first followed by a comma
and a space, followed by the first name.
For example, if the input is
\code{"Marcel Proust"}, the output is \code{"Proust, Marcel"}.

\item {} 
Improve the previous part,
so it also allows a single name without spaces,
like ``Socrates'', and prints the original without change. If there are
two parts of the name, it should work as in the original version.

\end{enumerate}

Run the program (with parts 1, 2 and 4 active)
from a terminal window and show your TA when you are
done.  You should run it twice to show off both paths through
part 4.  Alternately have the main program just call part 4 twice.

\index{if!statement}\index{statement!if}

\chapter{Decisions}
\label{decisions:if-statements}\label{decisions:index-0}\label{decisions::doc}\label{decisions:decisions}

\section{Conditions I}
\label{conditions:conditions-i}\label{conditions:simple-conditions}\label{conditions::doc}
Thus far, within a given function, instructions have been executed
sequentially, in the same order as written.  Of course that is often
appropriate!  On the other hands if you are planning out instructions,
you can get to a place where you say, ``Hm, that depends....'', and
a choice must be made.  The simplest choices are two-way: do one
thing is a condition is true, and another (possibly nothing) if the
condition is not true.

More syntax for conditions will be introduced later,
but for now consider simple arithmetic comparisons that directly
translate from math into C\#. Try each line separately in csharp

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{2} \PYG{p}{\textless{}} \PYG{l+m}{5}\PYG{p}{;}
\PYG{l+m}{3} \PYG{p}{\textgreater{}} \PYG{l+m}{7}\PYG{p}{;}
\PYG{n}{var} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{1}\PYG{p}{;}
\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{p}{;}
\PYG{l+m}{2} \PYG{p}{*} \PYG{n}{x} \PYG{p}{\textless{}} \PYG{n}{x}\PYG{p}{;}
\end{Verbatim}

You see that conditions are either \code{true} or \code{false} (with no
quotes!). These are the only possible \emph{Boolean} values (named after
19th century mathematician George Boole). It is the type of the
results of true-false conditions or tests.

The simplest place to use conditions in a decision made with an
\code{if} statement.

We will consider more complicated conditions later, but this is a
quick start.


\section{Simple \texttt{if} Statements}
\label{ifstatements::doc}\label{ifstatements:simple-if-statements}\label{ifstatements:id1}
Compile and run this example program, \code{Suitcase.cs}.
Try it at least twice, with
inputs: 30 and then 55. As you an see, you get an extra result,
depending on the input. The main code is:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write} \PYG{p}{(} \PYG{l+s}{"How many pounds does your suitcase weigh? "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{double} \PYG{n}{weight} \PYG{p}{=} \PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{weight} \PYG{p}{\textgreater{}} \PYG{l+m}{5}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
           \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"There is a \PYGZdl{}25 charge for luggage that heavy."}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Thank you for your business."}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The lines labeled 3-5 are an \code{if} statement. It reads pretty much
like English. If it is true that the weight is greater than 50,
then print the statement about an extra charge. If it is not true
that the weight is greater than 50, then skip the part
right after the condition about
printing the extra luggage charge.
In any event, when
you have finished with the \code{if} statement (whether it actually does
anything or not), go on to the next statement.
In this case that is the statement
printing ``Thank you''.
An \code{if} statement only breaks the  normal sequential order
\emph{inside} the \emph{if{}`} statement itself.

The general C\# syntax for a simple \code{if} statement is
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \code{if (} \emph{condition} \code{)}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

Often you want multiple statements executed when the condition
is true.  We have used braces before.  We have not said
what they do technically, syntactically:  braces around
a group of statements technically makes a \emph{single}
compound statement.  So the pattern commonly written is:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \code{if (} \emph{condition} \code{) \{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] one or more statements
\end{DUlineblock}
\item[] \code{\}}
\end{DUlineblock}
\end{quote}

If the condition is true, then do the statement(s) in braces. If the
condition is not true, then skip the statements in braces.  The
indentation pattern is also illustrated.  Recall the compiler
does not care about the amount of whitespace, but humans do.
In general indent the statements inside a compound statement.
We will see later that there is good reason to use this format
with braces \emph{even} if there is just one statement inside the braces.

Another fragment as an example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{balance} \PYG{p}{\textless{}} \PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{transfer} \PYG{p}{=} \PYG{p}{-}\PYG{n}{balance}\PYG{p}{;}
    \PYG{c+c1}{// transfer enough from the backup account:}
    \PYG{n}{backupAccount} \PYG{p}{=} \PYG{n}{backupAccount} \PYG{p}{-} \PYG{n}{transfer}\PYG{p}{;}
    \PYG{n}{balance} \PYG{p}{=} \PYG{n}{balance} \PYG{p}{+} \PYG{n}{transfer}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The assumption
in the example above is that if an account goes negative, it is
brought back to 0 by transferring money from a backup account in
several steps.

In the examples above the choice is between doing something (if the
condition is \code{true}) or nothing (if the condition is \code{false}).
Often there is a choice of two possibilities, only one of which
will be done, depending on the truth of a condition....

\index{if-else}

\section{\texttt{if}-\texttt{else} Statements}
\label{ifelse:index-0}\label{ifelse:if-else-statements}\label{ifelse::doc}\label{ifelse:id1}
Run the example program, \code{Clothes.cs}. Try it at least twice, with
inputs 50 and then 80. As you can see, you get different results,
depending on the input. The main code of \code{Clothes.cs} is:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write} \PYG{p}{(} \PYG{l+s}{"What is the temperature? "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{double} \PYG{n}{temperature} \PYG{p}{=} \PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{temperature} \PYG{p}{\textgreater{}} \PYG{l+m}{7}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
           \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Wear shorts."}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{else} \PYG{p}{\PYGZob{}}
          \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Wear long pants."}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Get some exercise outside."}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The lines labeled 3-8 are an \code{if}-\code{else} statement. Again it is
close to English, though you might say ``otherwise'' instead of
``else'' (but else is shorter!). There are two indented statements
in braces:
One, like in the simple \code{if} statement, comes right after the
\code{if} condition and is executed when the condition  is true.
In the \code{if}-\code{else} form this is followed by an
\code{else} (lined up under the \code{if} by convention),
followed by another indented statement enclosed in braces that is only
executed when the original condition is \emph{false}. In an \code{if}-\code{else}
statement exactly one of two possible parts in braces is executed.

A final line is also shown that is not indented, about getting exercise.
The \emph{if} and \emph{else} clauses each only embed a single statement
as option, so the last statement is not part of the \code{if}-\code{else}
statement.  Instead it is a part of the normal sequential
flow of statements.  It is \emph{always} executed after the
\code{if}-\code{else} statement, no matter what happens inside the
\code{if}-\code{else} statement.  Again:  inside the \code{if}-\code{else} there is a
choice made, but the whole \code{if}-\code{else} construction is a single
larger statement, which exists in the normal sequential flow.
The compiler does not require the indentation of the if-true-statement
and the if-false-statement, but it is a standard style convention.

The general C\# \code{if}-\code{else} syntax is
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \code{if (} \emph{condition} \code{) \{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s) for if-true
\end{DUlineblock}
\item[] \code{\}}
\item[] \code{else \{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s) for if-false
\end{DUlineblock}
\item[] \code{\}}
\end{DUlineblock}
\end{quote}

The statements chosen based on the condition
can be any kind of statement.  This is the suggested form, but
as with the plain \code{if} statement, the if-true compound statement or
the if-false compound statement can be replace by a single statement
without braces, except in one otherwise ambiguous situation discussed
later with two \code{if}s and an \code{else}.

\index{double scope!compound statement}\paragraph{More on Compound Statements and Scope}

The section on local scope referred to function and method bodies,
which happen to be enclosed in braces, making a compound statement.
If fact braces limit the scope of things declared inside,
\emph{wherever} they appear.

As a result the following code makes no sense:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{BadScope}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(} \PYG{n}{x} \PYG{p}{\textless{}} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{val} \PYG{p}{=} \PYG{n}{x} \PYG{p}{+} \PYG{l+m}{2}\PYG{p}{;}
   \PYG{k}{else} \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{val} \PYG{p}{=} \PYG{n}{x} \PYG{p}{-} \PYG{l+m}{2}\PYG{p}{:}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{return} \PYG{n}{val}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The \code{if}-\code{else} statement is legal, but useless,
because whichever compound statement gets executed,
\code{val} ceases being defined after the
closing brace of its compound statement,
so the \code{val} in the return statement has
not been declared or given a value.
If we want \code{val} be used inside the braces and
to make sense past the end of the compound statement,
it cannot be declared inside the braces. Instead it must be
declared before the compound statements that are parts of the
\code{if}-\code{else} statement.  The following would work:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{OkScope}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{val}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(} \PYG{n}{x} \PYG{p}{\textless{}} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{val} \PYG{p}{=} \PYG{n}{x} \PYG{p}{+} \PYG{l+m}{2}\PYG{p}{;}
   \PYG{k}{else} \PYG{p}{\PYGZob{}}
      \PYG{n}{val} \PYG{p}{=} \PYG{n}{x} \PYG{p}{-} \PYG{l+m}{2}\PYG{p}{:}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{return} \PYG{n}{val}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\index{boolean expression!condition!comparison}

\section{More Conditional Expressions}
\label{comparisonops:index-0}\label{comparisonops:more-conditional-expressions}\label{comparisonops::doc}\label{comparisonops:id1}
All the usual arithmetic comparisons may be made, but many do not
use standard mathematical symbolism, mostly for lack of proper keys
on a standard keyboard.

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{
Meaning
} & \textbf{
Math Symbol
} & \textbf{
C\# Symbols
}\\\hline

Less than
 & 
$<$
 & 
\code{\textless{}}
\\\hline

Greater than
 & 
$>$
 & 
\code{\textgreater{}}
\\\hline

Less than or equal
 & 
$\leq$
 & 
\code{\textless{}=}
\\\hline

Greater than or equal
 & 
$\geq$
 & 
\code{\textgreater{}=}
\\\hline

Equals
 & 
=
 & 
\code{==}
\\\hline

Not equal
 & 
$\neq$
 & 
\code{!=}
\\\hline
\end{tabulary}


There should not be space between the two-symbol C\#
substitutes.

Notice that the obvious choice for \emph{equals}, a single equal sign,
is \emph{not} used to check for equality. An annoying second equal sign
is required. This is because the single equal sign is already used
for \emph{assignment} in C\#, so it is not available for tests.

\begin{notice}{warning}{Warning:}
It is a common error to use only one equal sign when you mean to \emph{test}
for equality, and not make an assignment!
\end{notice}

Tests for equality do not make an assignment, and they do not
require a variable on the left.

All these tests work for numbers,
and characters.  Strings can be tested for
equality or inequality (!=).

Predict the results and try each line in csharp:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{p}{=} \PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{x}\PYG{p}{;}
\PYG{n}{x} \PYG{p}{=}\PYG{p}{=} \PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{x} \PYG{p}{=}\PYG{p}{=} \PYG{l+m}{6}\PYG{p}{;}
\PYG{n}{x}\PYG{p}{;}
\PYG{n}{x} \PYG{p}{!}\PYG{p}{=} \PYG{l+m}{6}\PYG{p}{;}
\PYG{n}{x} \PYG{p}{=} \PYG{l+m}{6}\PYG{p}{;}
\PYG{l+m}{6} \PYG{p}{=}\PYG{p}{=} \PYG{n}{x}\PYG{p}{;}
\PYG{l+m}{6} \PYG{p}{!}\PYG{p}{=} \PYG{n}{x}\PYG{p}{;}
\PYG{l+s}{"hi"} \PYG{p}{=}\PYG{p}{=} \PYG{l+s}{"h"} \PYG{p}{+} \PYG{l+s}{"i"}\PYG{p}{;}
\PYG{l+s}{"HI"} \PYG{p}{!}\PYG{p}{=} \PYG{l+s}{"hi"}\PYG{p}{;}
\end{Verbatim}

An equality check does not make an assignment. Strings are case
sensitive.

\textbf{Try this}: Following up on the discussion of the \emph{inexactness} of float
arithmetic, confirm that C\#
does not consider .1 + .2 to be equal to .3: Write a simple
condition into csharp to test.
\paragraph{Pay with Overtime Example}

Given a person's work
hours for the week and regular hourly wage, calculate the total pay
for the week, taking into account overtime. Hours worked over 40
are overtime, paid at 1.5 times the normal rate. This is a natural
place for a function enclosing the calculation.

\emph{Read} the setup for the function:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Return the total weekly wages for a worker working totalHours,}
\PYG{c+cm}{    with a given regular hourlyWage.  Include overtime for hours over 40.}
\PYG{c+cm}{   */}
   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{CalcWeeklyWages}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{totalHours}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{hourlyWage}\PYG{p}{)}
\end{Verbatim}

The problem clearly indicates two cases: when no more than 40
hours are worked or when more than 40 hours are worked. In case
more than 40 hours are worked, it is convenient to introduce a
variable overtimeHours. You are encouraged to think about a
solution before going on and examining mine.

You can try running my complete example program, \code{Wages1.cs},
also
shown below. The program uses the keyboard input functions
developed in class.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Wages}
\PYG{p}{\PYGZob{}}        \PYG{c+c1}{//heading chunk}
   \PYG{c+cm}{/** Return the total weekly wages for a worker working totalHours,}
\PYG{c+cm}{    with a given regular hourlyWage.  Include overtime for hours over 40.}
\PYG{c+cm}{   */}
   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{CalcWeeklyWages}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{totalHours}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{hourlyWage}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}     \PYG{c+c1}{//body chunk}
      \PYG{k+kt}{double} \PYG{n}{totalWages}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{totalHours} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{l+m}{4}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{totalWages} \PYG{p}{=} \PYG{n}{hourlyWage}\PYG{p}{*}\PYG{n}{totalHours}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{else} \PYG{p}{\PYGZob{}}
         \PYG{k+kt}{double} \PYG{n}{overtime} \PYG{p}{=} \PYG{n}{totalHours} \PYG{p}{-} \PYG{l+m}{4}\PYG{l+m}{0}\PYG{p}{;}
         \PYG{n}{totalWages} \PYG{p}{=} \PYG{n}{hourlyWage}\PYG{p}{*}\PYG{l+m}{4}\PYG{l+m}{0} \PYG{p}{+} \PYG{p}{(}\PYG{l+m}{1.5}\PYG{p}{*}\PYG{n}{hourlyWage}\PYG{p}{)}\PYG{p}{*}\PYG{n}{overtime}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{totalWages}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
                               \PYG{c+c1}{//}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{double} \PYG{n}{hours} \PYG{p}{=} \PYG{n}{promptDouble}\PYG{p}{(}\PYG{l+s}{"Enter hours worked: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{double} \PYG{n}{wage} \PYG{p}{=} \PYG{n}{promptDouble}\PYG{p}{(}\PYG{l+s}{"Enter dollars paid per hour: "}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{double} \PYG{n}{total} \PYG{p}{=} \PYG{n}{CalcWeeklyWages}\PYG{p}{(}\PYG{n}{hours}\PYG{p}{,} \PYG{n}{wage}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//before chunk2}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}
         \PYG{l+s}{"Wages for \PYGZob{}0\PYGZcb{} hours at \PYGZdl{}\PYGZob{}1:F2\PYGZcb{} per hour are \PYGZdl{}\PYGZob{}2:F2\PYGZcb{}."}\PYG{p}{,}
         \PYG{n}{hours}\PYG{p}{,} \PYG{n}{wage}\PYG{p}{,} \PYG{n}{total}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}                                                \PYG{c+c1}{//after chunk2}

   \PYG{c+cm}{/** Prompt user and return a line read from the keyboard.*/}
   \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{promptLine}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+cm}{/** Prompt user and return a double read from the keyboard.*/}
   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{promptDouble}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{promptLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//assumes legal format for now}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This program also introduces new notation for
displaying decimal numbers:

\begin{Verbatim}[commandchars=\\\{\}]
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}
         \PYG{l+s}{"Wages for \PYGZob{}0\PYGZcb{} hours at \PYGZdl{}\PYGZob{}1:F2\PYGZcb{} per hour are \PYGZdl{}\PYGZob{}2:F2\PYGZcb{}."}\PYG{p}{,}
         \PYG{n}{hours}\PYG{p}{,} \PYG{n}{wage}\PYG{p}{,} \PYG{n}{total}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Inside the format string you see \code{\{1:F2\}} and \code{\{2:F2\}}:  inside
the braces, after the parameter index, you see a new part,
\code{:F2}.
The part after the colon gives optional formatting information.
In this case display with the decimal point
\textbf{f}ixed so  \textbf{2} places beyond the decimal
point are shown.  Also the result is \emph{rounded}.
This is appropriate for money with dollars and cents.
Replace the 2 to display
a different number of digits after the decimal point.
More formatting instructions will be discussed later.

Below is an equivalent alternative version of the body of
\code{CalcWeeklyWages}, used in \code{Wages2.cs}. It uses just one
general calculation formula and sets the parameters for the formula
in the \code{if} statement. There are generally a number of ways you might
solve the same problem!

\begin{Verbatim}[commandchars=\\\{\}]
      \PYG{k+kt}{double} \PYG{n}{regularHours}\PYG{p}{,} \PYG{n}{overtime}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{totalHours} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{l+m}{4}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{regularHours} \PYG{p}{=} \PYG{n}{totalHours}\PYG{p}{;}
         \PYG{n}{overtime} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{else} \PYG{p}{\PYGZob{}}
         \PYG{n}{regularHours} \PYG{p}{=} \PYG{l+m}{4}\PYG{l+m}{0}\PYG{p}{;}
         \PYG{n}{overtime} \PYG{p}{=} \PYG{n}{totalHours} \PYG{p}{-} \PYG{l+m}{4}\PYG{l+m}{0}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{hourlyWage}\PYG{p}{*}\PYG{n}{regularHours} \PYG{p}{+} \PYG{p}{(}\PYG{l+m}{1.5}\PYG{p}{*}\PYG{n}{hourlyWage}\PYG{p}{)}\PYG{p}{*}\PYG{n}{overtime}\PYG{p}{;}
\end{Verbatim}


\subsection{Graduate Exercise}
\label{comparisonops:graduateex}\label{comparisonops:graduate-exercise}
Write a program, \code{Graduate.cs}, that prompts students for how
many credits they have. Print whether of not they have enough
credits for graduation. (At Loyola University Chicago 120 credits
are needed for graduation.)

\index{if-else-if!if}

\section{Multiple Tests and \texttt{if}-\texttt{else} Statements}
\label{ifelsechained:multiple-tests-and-if-else-statements}\label{ifelsechained:multiple-tests}\label{ifelsechained:index-0}\label{ifelsechained::doc}
Often you want to distinguish between more than two distinct cases,
but conditions only have two possible results, \code{true} or \code{false},
so the only direct choice is between two options. As anyone who has
played ``20 Questions'' knows, you can distinguish more cases by
further questions. If there are more than two choices, a single
test may only reduce the possibilities, but further tests can
reduce the possibilities further and further. Since most any kind
of statement can be placed in the sub-statements in
an \code{if}-\code{else} statement, one
choice is a further \code{if} or \code{if}-\code{else} statement.
For instance consider a
function to convert a numerical grade to a letter grade, `A', `B',
`C', `D' or `F', where the cutoffs for `A', `B', `C', and `D' are
90, 80, 70, and 60 respectively. One way to write the function
would be test for one grade at a time, and resolve all the
remaining possibilities inside the next \code{else} clause.
If we do this consistent with our indentation conventions so far:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{char} \PYG{n+nf}{letterGrade}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{score}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{char} \PYG{n}{letter}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{score} \PYG{p}{\textgreater{}}\PYG{p}{=} \PYG{l+m}{9}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{letter} \PYG{p}{=} \PYG{l+s+sc}{'A'}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{else} \PYG{p}{\PYGZob{}}   \PYG{c+c1}{// grade must be B, C, D or F}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{score} \PYG{p}{\textgreater{}}\PYG{p}{=} \PYG{l+m}{8}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{letter} \PYG{p}{=} \PYG{l+s+sc}{'B'}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{else} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// grade must be C, D or F}
         \PYG{k}{if} \PYG{p}{(}\PYG{n}{score} \PYG{p}{\textgreater{}}\PYG{p}{=} \PYG{l+m}{7}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{letter} \PYG{p}{=} \PYG{l+s+sc}{'C'}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
         \PYG{k}{else} \PYG{p}{\PYGZob{}}   \PYG{c+c1}{// grade must D or F}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{score} \PYG{p}{\textgreater{}}\PYG{p}{=} \PYG{l+m}{6}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
               \PYG{n}{letter} \PYG{p}{=} \PYG{l+s+sc}{'D'}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{p}{\PYGZob{}}
               \PYG{n}{letter} \PYG{p}{=} \PYG{l+s+sc}{'F'}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
         \PYG{p}{\PYGZcb{}}   \PYG{c+c1}{//end else D or F}
      \PYG{p}{\PYGZcb{}}      \PYG{c+c1}{// end of else C, D, or F}
   \PYG{p}{\PYGZcb{}}         \PYG{c+c1}{// end of else B, C, D or F}
   \PYG{k}{return} \PYG{n}{letter}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This repeatedly increasing indentation with an \code{if} statement in
the \code{else} clause can be annoying and distracting. Here is a preferred
alternative in this situation, that avoids all this further
indentation:
Combine each \code{else} and following \code{if} onto the same line,
and note that the \code{if} part after an else is just a \emph{single}
(possibly very complicated) statement, allowing some braces to be removed:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Return letter grade for score. */}
   \PYG{k}{static} \PYG{k+kt}{char} \PYG{n+nf}{letterGrade}\PYG{p}{(}\PYG{k+kt}{double} \PYG{n}{score}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{char} \PYG{n}{letter}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{score} \PYG{p}{\textgreater{}}\PYG{p}{=} \PYG{l+m}{9}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{letter} \PYG{p}{=} \PYG{l+s+sc}{'A'}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{score} \PYG{p}{\textgreater{}}\PYG{p}{=} \PYG{l+m}{8}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// grade must be B, C, D or F}
        \PYG{n}{letter} \PYG{p}{=} \PYG{l+s+sc}{'B'}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{score} \PYG{p}{\textgreater{}}\PYG{p}{=} \PYG{l+m}{7}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// grade must be C, D or F}
         \PYG{n}{letter} \PYG{p}{=} \PYG{l+s+sc}{'C'}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{score} \PYG{p}{\textgreater{}}\PYG{p}{=} \PYG{l+m}{6}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// grade must D or F}
         \PYG{n}{letter} \PYG{p}{=} \PYG{l+s+sc}{'D'}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{else} \PYG{p}{\PYGZob{}}
         \PYG{n}{letter} \PYG{p}{=} \PYG{l+s+sc}{'F'}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{letter}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

A program testing the letterGrade function is in
example program \code{Grade1.cs}.

See {\hyperref[ifelsechained:gradeex]{\emph{Grade Exercise}}}.

While an \code{if}-\code{else} statement always chooses an alternative to execute,
a plain \code{if} statement may end up executing no sub-statement.  If
you have a more complicated embedding of \code{if}-\code{else} and \code{if}
statements, you must look carefully to see how many different
sub-statements may be chosen.  For example consider this
fragment \emph{without} a final \code{else}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{weight} \PYG{p}{\textgreater{}} \PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Sorry, we can not take a suitcase that heavy."}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{weight} \PYG{p}{\textgreater{}} \PYG{l+m}{5}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"There is a \PYGZdl{}25 charge for luggage that heavy."}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This statement only prints one of two lines if there is a
problem with the weight of the suitcase.  Nothing is printed if
there is not a problem.


\subsection{Sign Exercise}
\label{ifelsechained:sign-exercise}
Write a program \code{Sign.cs} to ask the user for a number. Print out
which category the number is in: \code{"positive'}, \code{"negative"}, or
\code{"zero"}.


\subsection{Grade Exercise}
\label{ifelsechained:gradeex}\label{ifelsechained:grade-exercise}
Copy \code{Grade1.cs} to \code{Grade2.cs} Modify
\code{Grade2.cs} so it has an equivalent version of the letterGrade
function that tests in the opposite order, first for F, then D, C,
.... Hint: How many tests do you need to do? \footnote{
4 tests to distinguish the 5 cases, as in the previous version
}

Be sure to run your new version and test with different
inputs that test all the different paths through the program.


\subsection{Wages Exercise}
\label{ifelsechained:wages-exercise}
Modify the \code{Wages1.cs} or the \code{Wages2.cs} example to create a
program \code{Wages3.cs} that assumes people are paid double time for
hours over 60. Hence they get paid for at most 20 hours overtime at
1.5 times the normal rate. For example, a person working 65 hours
with a regular wage of \$10 per hour would work at \$10 per hour for
40 hours, at 1.5 * \$10 for 20 hours of overtime, and 2 * \$10 for
5 hours of double time, for a total of
\begin{quote}

10*40 + 1.5*10*20 + 2*10*5 = \$800.
\end{quote}

You may find \code{Wages2.cs} easier to adapt than \code{Wages1.cs}.


\section{If-statement Pitfalls}
\label{ifpitfalls:if-statement-pitfalls}\label{ifpitfalls::doc}
\index{pitfall!semicolon after condition if statement}\index{semicolon after condition!if statement, pitfall}\index{if statement!pitfall semicolon after condition}

\subsection{Dangerous Semicolon}
\label{ifpitfalls:dangerous-semicolon}\label{ifpitfalls:index-0}\label{ifpitfalls:id1}
Regular statements must end with a semicolon.
It turns out that the semicolon is all you need to have a legal statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{;}
\end{Verbatim}

We will see places that it is useful, but
meanwhile it can cause errors: Although you may be hard pressed to
remember to put semicolons at the end of all your statements, and may
get compulsive in response about adding them at the end of statement
lines, be careful NOT to put one at the end of a method heading or
an if condition:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(} \PYG{n}{x} \PYG{p}{\textless{}} \PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// WRONG PROBABLY!}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Remember indentation and newlines are only significant for humans. The
two lines above are equivalent to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(} \PYG{n}{x} \PYG{p}{\textless{}} \PYG{l+m}{0}\PYG{p}{)}
   \PYG{p}{;} \PYG{c+c1}{// Do nothing as statement when the condition is true}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// past if statement - do it always}
\end{Verbatim}

(Whenever you do need an empty statement, you are encouraged to put the
semicolon all by itself on a line, as above.)

This code is deadly, since it compiles and is almost surely
\emph{not} what you mean.

If you always put an open brace at the end of the line of a condition,
you are less likely to make this error.

The corresponding error at the end of a method heading will at least
generate a compiler error, though it may appear crypic:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{badSemicolon}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{n}{x} \PYG{p}{=} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;}
    \PYG{c+c1}{// ...}
\end{Verbatim}

\index{pitfall!dangling else if-else}\index{dangling else!if-else, pitfall}\index{if-else!pitfall dangling else}

\subsection{Match Wrong \texttt{if} With \texttt{else}}
\label{ifpitfalls:match-wrong-if-with-else}\label{ifpitfalls:index-1}
The fact that the else part of an if statement is optional can cause
problems if you do not consistently put the substatements for the true
and false choices inside braces. Even if you do
this consistently, you may well need to read code that does not place
braces around single statements. If C\# understood indentation as
in the recommended formatting style (or as required in Python),
the following would be OK:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{y} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"positive x and y"}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"x not positive, untested y"}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Unfortunately placing the \code{else} under the first \code{if} is not enough to make
them go together (remember the C\# compiler ignores whitespace). The
following is equivalent to the compiler, with the else apparently going
with the second if:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{y} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"positive x and y"}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"x not positive, untested y"}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The compiler is consistent with the latter visual pattern: an \code{else} goes
with the most \emph{recent} \code{if} that could still take an \code{else}.
Hence if \code{x} is 3
and \code{y} is -2, the \code{else} part is executed and statement printed is
incorrect: the else clause is only executed when \code{x} is positive and
\code{y} (is
tested and) is not positive. If you put braces everywhere to reinforce
your indentation, as we suggest, or if you only add the following
one set of braces around the inner if statement:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{y} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"positive x and y"}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"x not positive, untested y"}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

then the braces enclosing the inner \code{if} statement make it impossible for
the inner  \code{if} to continue on to an optional \code{else} part.
The \code{else} must go
with the first \code{if}. Now when the \code{else} part is reached, the statement
printed will be true: \code{x} is not positive, and the test of \code{y} is skipped.

\index{pitfall!need braces if statement}\index{need braces!if statement, pitfall}\index{if statement!pitfall need braces}

\subsection{Missing Braces}
\label{ifpitfalls:index-2}\label{ifpitfalls:missing-braces}
Another place you can fool yourself with nice indenting style is
something like this.  Suppose I start with a perfectly reasonable

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"x is: positive"}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

I may decide to avoid the braces, since there \emph{is} just one statement
that I want as the if-true part, but if I later decide
that I want this on two lines
and change it to

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"x is:"}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"  positive"}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

I am not going to get the behavior I want.
The positive part will \emph{always} be printed.

If I had first taken a bit more effort originally to write

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"x is: positive"}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

then I could have split successfully into

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"x is:"}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"  positive"}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This way I do not have to keep worrying when I revise:
Have I switched to multiple lines after the \code{if}
and need to introduce braces?

All three of the pitfalls mentioned in this section are fixed or
minimized by consistent
use of braces in the sub-statements of \code{if} statements.

\index{\&\&!and boolean operation}\index{and!boolean operation, \&\&}\index{boolean operation!\&\& and}

\section{Compound Boolean Expressions}
\label{compoundconditions:index-0}\label{compoundconditions:compound-boolean-expressions}\label{compoundconditions::doc}\label{compoundconditions:id1}
To be eligible to graduate from Loyola University Chicago, you must
have 120 credits \emph{and} a GPA of at least 2.0. C\# does not use the
word \emph{and}.  Instead it uses \code{\&\&}.  Then the statement
translates directly into C\# as a \emph{compound condition}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{credits} \PYG{p}{\textgreater{}}\PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{0} \PYG{p}{\&}\PYG{p}{\&} \PYG{n}{GPA} \PYG{p}{\textgreater{}}\PYG{p}{=}\PYG{l+m}{2.0}
\end{Verbatim}

This is true if both \code{credits \textgreater{}= 120} is true and
\code{GPA \textgreater{}= 2.0} is
true. A short example function using this would be:

\begin{Verbatim}[commandchars=\\\{\}]
static void checkGraduation(int credits, double GPA)
\PYGZob{}
    if (credits \textgreater{}= 120 \&\& GPA \textgreater{}=2.0) \PYGZob{}
        Console.WriteLine('You are eligible to graduate!')
    \PYGZcb{}
    else \PYGZob{}
        Console.WriteLine('You are not eligible to graduate.')
    \PYGZcb{}
\PYGZcb{}
\end{Verbatim}

The new C\# syntax for the operator \code{\&\&}:
\begin{quote}

\emph{condition1} \code{\&\&} \emph{condition2}
\end{quote}

The compound condition is true if both of the component conditions
are true. It is false if at least one of the conditions is false.

Suppose we want a condition that is true if the mathematical
condition is true: low \textless{} val \textless{} high.  Unfortunately the math is not a
C\# expression.  The operator \code{\textless{}} is binary.  There is a C\# version:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{low} \PYG{p}{\textless{}} \PYG{n}{val} \PYG{p}{\&}\PYG{p}{\&} \PYG{n}{val} \PYG{p}{\textless{}} \PYG{n}{high}
\end{Verbatim}

Now suppose we want the opposite condition:  that val is \emph{not}
strictly between low and high.
There are several approaches.
One is that \code{val} would be less than or equal to low
\emph{or} greater than or equal to \code{high}.  C\# translate \emph{or} into \code{\textbar{}\textbar{}},
so a C\# expression would be:
\begin{quote}

val \textless{}= low \textbar{}\textbar{} val \textgreater{}= high
\end{quote}

The new C\# syntax for the operator \code{\textbar{}\textbar{}}:
\begin{quote}

\emph{condition1} \code{\textbar{}\textbar{}} \emph{condition2}
\end{quote}

The compound condition is true if at least one of the component conditions
are true. It is false if at both conditions are false.

Another logical way to express the opposite of the condition low \textless{} val \textless{} high
is that it is \emph{not} the case
that low \textless{} val \&\& val \textless{}\textless{} high.  C\# translates \emph{not} as \code{!}.  Another way
to state the condition would be

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{!}\PYG{p}{(}\PYG{n}{low} \PYG{p}{\textless{}} \PYG{n}{val} \PYG{p}{\&}\PYG{p}{\&} \PYG{n}{val} \PYG{p}{\textless{}} \PYG{n}{high}\PYG{p}{)}
\end{Verbatim}

The parentheses are needed because the \code{!}
operator has higher precedence than
\code{\textless{}}.

A way to remember this strange \emph{not} operator is to think of the use of \code{!}
in the not-equal operator: \code{!=}

The new C\# syntax for the operator \code{!}:
\begin{quote}

\code{!} \emph{condition}
\end{quote}

This whole expression is true when \emph{condition} is false,
and false when \emph{condition} is true.

Because of the precedence of \code{!}, you are often going to write:
\begin{quote}

\code{!(} \emph{condition} \code{)}
\end{quote}

Remember when such a condition is used in an \code{if} statement, \emph{outer}
parentheses are also needed:
\begin{quote}

\code{if (!(} \emph{condition} \code{)) \{}
\end{quote}

For other examples and different words of introduction to \code{if} statements,
braces, and compound conditions, you might look at
Miles, section 2.3.2.


\subsection{Congress Exercise}
\label{compoundconditions:congress-exercise}\label{compoundconditions:congressex}
A person is eligible to be a US Senator who is at least 30 years
old and has been a US citizen for at least 9 years. Write a version
of a program \code{Congress.cs} to obtain age and length of
citizenship from the user and print out if a person is eligible to
be a Senator or not. A person is eligible to be a US Representative
who is at least 25 years old and has been a US citizen for at least
7 years. Elaborate your program \code{Congress.cs} so it obtains age
and length of citizenship and prints whether a person is eligible
to be a US Representative only, or is eligible for both offices, or
is eligible for neither.

\index{while!loop}\index{loop!while}

\chapter{While Loops}
\label{while:index-0}\label{while::doc}\label{while:while-loops}\label{while:id1}
\index{while!statement}\index{statement!while}

\section{While-Statements}
\label{whilestatements:index-0}\label{whilestatements::doc}\label{whilestatements:while-statements}\label{whilestatements:id1}
We have seen that the sequential flow of a program
can be altered with function calls
and decisions.  The last important pattern is \emph{repetition} or \emph{loops}.
There are several varieties.  The simplest place to start is with
\code{while} loops.

A C\#
\code{while} loop behaves quite similarly to common English usage. If
I say
\begin{quote}

While your tea is too hot, add a chip of ice.
\end{quote}

Presumably you would test your tea. If it were too hot, you would
add a little ice. If you test again and it is still too hot, you
would add ice again. \emph{As long as} you tested and found it was true
that your tea was too hot, you would go back and add more ice.
C\# has a similar syntax:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \code{while (} \emph{condition} \code{)}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement
\end{DUlineblock}
\end{DUlineblock}
\end{quote}

As with an \code{if} statement we will generally assume a compound statement,
after the condition, so the syntax will actually be:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \code{while (} \emph{condition} \code{) \{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s)
\end{DUlineblock}
\item[] \code{\}}
\end{DUlineblock}
\end{quote}

Setting up the English example in a similar format would be:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] while  ( \emph{your tea is too hot} ) \{
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] add a chip of ice
\end{DUlineblock}
\item[] \}
\end{DUlineblock}
\end{quote}

To make things concrete and numerical, suppose the following: The
tea starts at 115 degrees Fahrenheit. You want it at 112 degrees. A
chip of ice turns out to lower the temperature one degree each
time. You test the temperature each time, and also print out the
temperature before reducing the temperature. In C\# you could
write and run the code below, saved in example program Cool.cs:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{k+kt}{int} \PYG{n}{temperature} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{1}\PYG{l+m}{5}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{temperature} \PYG{p}{\textgreater{}} \PYG{l+m}{1}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// first while loop code}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{temperature}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{temperature} \PYG{p}{=} \PYG{n}{temperature} \PYG{p}{-} \PYG{l+m}{1}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"The tea is cool enough."}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

I added a final line after the \code{while} loop to remind you that
execution follows sequentially after a loop completes.

It is extremely important to totally understand how the flow of
execution works with loops.  One way to follow it
closely is to make a table with a line for each instruction
executed, keeping track of all the variables.  We call this
\emph{playing computer}.

Each row shows the line number of the start of the next instruction
executed, and the values of all the variables \emph{after} the instruction
is executed.  The important thing to see with loops is that the same
line can be executed over and over, but with different variable
values.  We leave a column for the line number, each variable
that is involved (particularly any that change) and a place for
comments about what is happening.  The comment line can be used any time
it is helpful.  If should be used in particular when something
is printed and when something is returned, since neither of these
important actions appear int he variable list.

If you play computer and follow the path of execution, you could
generate the following table. Remember, that each time you reach
the end of the block after the \code{while} heading,
execution returns to the \code{while} heading for another test:

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{
Line
} & \textbf{
temperature
} & \textbf{
Comment
}\\\hline

1
 & 
115
 & \\\hline

2
 &  & 
115 \textgreater{} 112 is true, do loop
\\\hline

3
 &  & 
prints 115
\\\hline

4
 & 
114
 & 
115 - 1 is 114, loop back
\\\hline

2
 &  & 
114 \textgreater{} 112 is true, do loop
\\\hline

3
 &  & 
prints 114
\\\hline

4
 & 
113
 & 
114 - 1 is 113, loop back
\\\hline

2
 &  & 
113 \textgreater{} 112 is true, do loop
\\\hline

3
 &  & 
prints 113
\\\hline

4
 & 
112
 & 
113 - 1 is 112, loop back
\\\hline

2
 &  & 
112 \textgreater{} 112 is false, skip loop
\\\hline

6
 &  & 
prints that the tea is cool
\\\hline
\end{tabulary}


Each time the end of the loop body block is reached, execution
returns to the \code{while} loop heading for another test. When the
test is finally false, execution jumps past the indented body of
the \code{while} loop to the next sequential statement.

\index{while!rubric}\index{rubric!while}
The biggest trick with a loop is to make the same code do the next
thing you want each time through.  That generally involves
the use of variables that are modified for each successive time through
the loop.
\begin{quote}

\begin{DUlineblock}{0em}
\item[] initialization
\item[] \code{while (} \emph{continuationCondition} \code{) \{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] do main action to be repeated
\item[] prepare variables for the next time through the loop
\end{DUlineblock}
\item[] \code{\}}
\end{DUlineblock}
\end{quote}

The simple first example follows this pattern directly.  Note
that the variables needed for the test of the condition must be
set up \emph{both} in the initialization \emph{and} inside the loop
(often at the very end).  Without a change inside the loop, the loop would
run forever!

It is a big deal for beginning students, how to manage all this in general.
We will see a number of common patterns in lots of practice.  We will use
the term \emph{successive modification loop} for loops following this pattern.

Test yourself: Follow the code.  Figure out what is printed.
If it helps, get detailed and play computer:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{4}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{l+m}{9}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{i} \PYG{p}{=} \PYG{n}{i} \PYG{p}{+} \PYG{l+m}{2}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Check yourself by running the example program \code{TestWhile1.cs}.

\begin{notice}{note}{Note:}
In C\#, \code{while} is not used \emph{quite} like in English. In
English you could mean to stop \emph{as soon as} the condition you want
to test becomes false. In C\# the test is \emph{only} made when
execution for the loop starts (or starts again),
\emph{not} in the middle of the loop.
\end{notice}

\emph{Predict} what will happen with this slight variation on the
previous example, switching the order in the loop body. Follow it
carefully, one step at a time.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{4}\PYG{p}{;} \PYG{c+c1}{//variation on TestWhile1.cs}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{l+m}{9}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{i} \PYG{p}{=} \PYG{n}{i} \PYG{p}{+} \PYG{l+m}{2}\PYG{p}{;}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Check yourself by running the example program \code{TestWhile2.cs}.

The sequence order is important. The variable \code{i} is increased before
it is printed, so the first number printed is 6. Another common
error is to assume that 10 will \emph{not} be printed, since 10 is
\emph{past} 9, but the test that may stop the loop is \emph{not} made in the
middle of the loop. Once the body of the loop is started, it
continues to the end, even when \code{i} becomes 10.

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{
Line
} & \textbf{
i
} & \textbf{
Comment
}\\\hline

1
 & 
4
 & \\\hline

2
 &  & 
4 \textless{} 9 is true, do loop
\\\hline

3
 & 
6
 & 
4+2=6
\\\hline

4
 &  & 
print 6
\\\hline

2
 &  & 
6 \textless{} 9 is true, do loop
\\\hline

3
 & 
8
 & 
6+2= 8
\\\hline

4
 &  & 
print 8
\\\hline

2
 &  & 
8 \textless{} 9 is true, do loop
\\\hline

3
 & 
10
 & 
8+2=10  \emph{No test here}
\\\hline

4
 &  & 
print 10
\\\hline

2
 &  & 
10 \textless{} 9 is false, skip loop
\\\hline
\end{tabulary}


\textbf{Problem}:  Write a program with a \code{while} loop to print:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] 10
\item[] 9
\item[] 8
\item[] 7
\item[] 6
\item[] 5
\item[] 4
\item[] 3
\item[] 2
\item[] 1
\item[] Blastoff!
\end{DUlineblock}
\end{quote}

\textbf{Analysis}:
We have seen that we can produce a regular sequence of numbers in a loop.
The ``Blastoff!'' part does not fit the pattern, so it must be a \emph{separate}
part after the loop.  We need a name for the number that decreases.  It can
be \code{time}.  Remember the general rubric for a \code{while} loop:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] initialization
\item[] \code{while (} \emph{continuationCondition} \code{) \{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] do main action to be repeated
\item[] prepare variables for the next time through the loop
\end{DUlineblock}
\item[] \code{\}}
\end{DUlineblock}
\end{quote}

You can consider each part separately.  Where to start is partly a
matter of taste.

The main thing to do is print the time over and over.
The initial value of the time is 10.  We are going to want to keep printing
until the time is down to 1, so we \emph{continue} while the time is at least 1,
meaning the continuationCondition can be \code{time \textgreater{}= 1},
or we could use \code{time \textgreater{} 0}.

Finally we need to get ready to print a different time in
the next pass through the loop.
Since each successive time is one less than the previous one, the
preparation for the next value of time is:  \code{time = time - 1}.

Putting that all together, and remembering the one thing we noted
to do after the loop,
we get \code{Blastoff.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{Blastoff}
\PYG{p}{\PYGZob{}}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Main}\PYG{p}{(}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{time} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{time} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{time}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{time} \PYG{p}{=} \PYG{n}{time} \PYG{p}{-} \PYG{l+m}{1}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Blastoff!"}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Look back and see how we fit the general rubric.
There are a bunch of things to think about with a while loop, so
going one step at a time, thinking of the rubric and the specific
needs of the current problem, helps.

There are many different (and more exciting) patterns of change coming
for loops,
but the simple examples so far get us started.

\index{while!questions}\index{questions!while}
Looking ahead to more complicated and interesting problems,
here is a more complete list of questions to ask yourself when
designing a function with a \code{while} loop:
\begin{itemize}
\item {} 
What variables do I need?

\item {} 
What needs to be initialized and how? This certainly includes any
variable tested in the condition.

\item {} 
What is the condition that will allow the loop to continue?

\item {} 
What is the code that should only be executed once? What action do I want to
repeat? Where does the repetition come in the overall sequence of
operations?

\item {} 
How do I write the action so I can modify it for the next time
through the loop?

\item {} 
What code is needed to do modifications to make the same code work
the next time through the loop?

\item {} 
Have I thought of variables needed in the middle and declared them;
do other things need initialization?

\item {} 
Will the continuation condition eventually fail?

\item {} 
Separate thing to be done once before the repetition (code before the
loop) from repetitive actions (in loop) from actions not repeated but
done after the loop (code after the loop). Missing this distinction
is a \emph{common error}!

\end{itemize}
\phantomsection\label{whilestatements:sumton}\paragraph{Sum To \code{n}}

Let us write a function to sum the numbers from 1 to \code{n}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** Return the sum of the numbers from 1 through n. */}
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{SumToN}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

For instance SumToN(5) calculates 1 + 2 + 3 + 4 + 5 and returns 15.
We know how to generate a sequence of integers, but this is a place
that a programmer gets tripped up by the speed of the human mind.
You are likely
so quick at this that you just see it all at once, with the answer.

\index{concrete example}
In fact, you and the computer need to do this in steps.  To help see, let
us take a concrete example like the one above for SumToN(5), and write out a
detailed sequence of steps like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{3} \PYG{p}{=} \PYG{l+m}{1} \PYG{p}{+} \PYG{l+m}{2}
\PYG{l+m}{6} \PYG{p}{=} \PYG{l+m}{3} \PYG{p}{+} \PYG{l+m}{3}
\PYG{l+m}{1}\PYG{l+m}{0} \PYG{p}{=} \PYG{l+m}{6} \PYG{p}{+} \PYG{l+m}{4}
\PYG{l+m}{1}\PYG{l+m}{5} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0} \PYG{p}{+} \PYG{l+m}{5}
\end{Verbatim}

You could put this in code directly for a specific sum, but if n is general,
we need a loop, and hence we must see a pattern in code that we can repeat.

Each of the second terms in the additions is a successive integer,
that we can generate.  Starting in the second line, the first number
in each addition
is the sum from the previous line.  Of course the next integer and the next
partial sum change from step to step, so in order to use the same code over and
over we will need changeable variables, with names.  We can make the partial
sum be \code{sum} and we can call the next integer \code{i}.  Each addition can be
in the form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sum} \PYG{p}{+} \PYG{n}{i}
\end{Verbatim}

We need to remember that result, the new sum.  you might first think to introduce
such a name:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{newSum} \PYG{p}{=} \PYG{n}{sum} \PYG{p}{+} \PYG{n}{i}\PYG{p}{;}
\end{Verbatim}

This will work.  We can go through the \code{while} loop rubric:

The variables are \code{sum}, \code{newSum} and \code{i}.

To evaluate
\begin{quote}

newSum = sum + i;
\end{quote}

the first time in the loop, we need \emph{initial} values for sum and i.
Our concrete example leads the way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{sum} \PYG{p}{=} \PYG{l+m}{1}\PYG{p}{,} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;}
\end{Verbatim}

We need a \code{while} loop heading with a continuation condition.  How
long do we want to add the next \code{i}?  That is for all the value up to and
including n:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\end{Verbatim}

There is one more important piece - making sure the same code
\begin{quote}

newSum = sum + i;
\end{quote}

works for the \emph{next} time through the loop.  We have dealt before with
the idea of the next number in sequence:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{p}{=} \PYG{n}{i} \PYG{p}{+} \PYG{l+m}{1}\PYG{p}{;}
\end{Verbatim}

What about \code{sum}?  What was the \code{newSum} on one line becomes the old or
just plain \code{sum} on the next line, so we can make an assignment:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{sum} \PYG{p}{=} \PYG{n}{newSum}\PYG{p}{:}
\end{Verbatim}

All together we calculate the sum with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{sum} \PYG{p}{=} \PYG{l+m}{1}\PYG{p}{,} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{newSum} \PYG{p}{=} \PYG{n}{sum} \PYG{p}{+} \PYG{n}{i}\PYG{p}{;}
   \PYG{n}{i} \PYG{p}{=} \PYG{n}{i} \PYG{p}{+} \PYG{l+m}{1}\PYG{p}{;}
   \PYG{n}{sum} \PYG{p}{=} \PYG{n}{newSum}\PYG{p}{:}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This exactly follows our general rubric, with preparation for the next time
through the loop at the end of the loop.
We can condense it in this case: Since \code{newSum} is only used
once, we can do away with it, and directly change the value of sum:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{sum} \PYG{p}{=} \PYG{l+m}{1}\PYG{p}{,} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{sum} \PYG{p}{=} \PYG{n}{sum} \PYG{p}{+} \PYG{n}{i}\PYG{p}{;}
   \PYG{n}{i} \PYG{p}{=} \PYG{n}{i} \PYG{p}{+} \PYG{l+m}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Finally this was supposed to fit in a function.  The ultimate purpose
was to \emph{return} the sum, which is the final value of the
variable \code{sum}, so the whole function is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** Return the sum of the numbers from 1 through n. */}
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{SumToN}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{sum} \PYG{p}{=} \PYG{l+m}{1}\PYG{p}{,} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;}
   \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{sum} \PYG{p}{=} \PYG{n}{sum} \PYG{p}{+} \PYG{n}{i}\PYG{p}{;}
      \PYG{n}{i} \PYG{p}{=} \PYG{n}{i} \PYG{p}{+} \PYG{l+m}{1}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{return} \PYG{n}{sum}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

\index{testing!edge case}\index{edge case!testing}\index{testing!range testing}\index{range testing!testing}\index{edge case!range testing}\index{range testing!edge case}
The comment before the function definition does not give a clear idea of the
range of possible values for n.  How small makes sense for the comment?
What actually works in the function?  The smallest expression
starting with 1 would just be 1: (n = 1).  Does that work in the function?
You were probably not thinking of that when developing the function!
Now look back now at this \emph{edge case}.  You can play computer on the code
or directly test it.  In this case the initialization of \code{sum} is 1,
and the body of the loop \emph{never} runs (2 \textless{}= 1 is false).  The function
execution jumps right to the return statement, and
does return 1, and everything is fine.

Now about large n....

\index{big oh!order of n}\index{order of n!big oh}
With loops we can make programs run for a long time.
The time taken becomes an issue.  In this case we go though the loop
n-1 times, so the total time is approximately proportional to n.
We write that the time is O(n), spoken ``oh of n'', or ``big oh of n'' or
``order of n''.

\index{pitfall!limit on number size}\index{limit on number size!pitfall}
Computers are pretty fast, so you can try the testing program
\code{SumToNTest.cs}
and it will go by so fast, that you will hardly notice.  Try these specific
numbers in tests: 5, 6, 1000, 10000, 98765.  All look OK?  Now try 66000.
On many systems you will get quite a surprise!
This is the first place we have to deal with the limited
size of the \code{int} type.
On many systems the limit is a bit over 2 billion.
You can check out the size of \code{int.MaxValue} in csharp.
The answer for 66000,
and \emph{also} 98765, is bigger than the upper limit.
Luckily the obviously wrong negative answer
for 66000 pops out at you.  Did you guess before you saw the answer for
66000, that there was an issue for
98765?  It is a good thing that no safety component in a big bridge was being
calculated!  It is a big deal that the system fails \emph{silently}
in such situations.  \emph{Think} how large the data may be that you deal with!

Now look at, compile, and run \code{SumToNLong.cs}.  The sum is
a \code{long} integer here. Check out in csharp how big
a \code{long} can be (\code{long.MaxValue}).  This version of the program
works for 100000 and for 98765.  We can get correct
answers for things that will take perceptible time.  Try working up to
1 billion (1000000000, nine 0's).  It takes a while: O(n) can be slow!

\index{Gauss!sum through n}\index{sum through n!Gauss}
By hand it is a lot slower, unless you totally change the algorithm:
There is a classic story about how a calculation like this
was done in gradeschool (n=100) by the famous
mathematician Gauss. His teacher was trying to keep him busy.
Gauss discovered the general, exact, mathematical formula:
\begin{quote}

1 + 2 + 3 + ... + n = n(n+1)/2.
\end{quote}

That is the number of terms (n), times the average term (n+1)/2.

\index{big oh!constant order}\index{constant order!big oh}
Our loop was instructive, but not the fastest approach.  The simple exact
formula takes about the same time for any n.
(That is as long as the result fits in
a standard type of computer integer!)
This is basically constant time.  In discussing
how the speed relates to the size of n, we say it is O(1).
The point is here that 1 is a constant.  The time is of \emph{constant order}.

\index{pitfall!division}\index{division!pitfall}
We can write a ridiculously short
function following Gauss's model.  Here I introduce the variable average,
as in the motivation for Gauss's answer:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Return the sum of the numbers from 1 through n. */}
   \PYG{k}{static} \PYG{k+kt}{long} \PYG{n+nf}{SumToN}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}  \PYG{c+c1}{//CHANGED:  quick and WRONG}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{average} \PYG{p}{=} \PYG{p}{(}\PYG{n}{n}\PYG{p}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{/}\PYG{l+m}{2}\PYG{p}{;}    \PYG{c+c1}{//from Gausse's motivation}
      \PYG{k}{return} \PYG{n}{n}\PYG{p}{*}\PYG{n}{average}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Compile and test the example program containing it: \code{SumToNLongBad.cs}.

Test it with 5, and then try 6. ???

``Ridiculously short'' does not imply correct!  The problem goes back
to the fact that Gauss was in \emph{math class} and you are doing
Computer Science.  Think of a subtle difference that might come in here:
Though (n+1)/2 is fine as math, recall the division operator does not
always give correct answers in C\#.  You get an integer answer from the
integer (or long) operands.  Of course the exact mathematical final answer
is an integer when \emph{adding} integers, but splitting it according to
Gausss's motivation can put a mathematical non-integer in the middle.

The C\# fix: The final answer is clearly an integer, so if we do the division
last, when we know the answer will be an integer, things should be better:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{return} \PYG{n}{n}\PYG{p}{*}\PYG{p}{(}\PYG{n}{n}\PYG{p}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{/}\PYG{l+m}{2}\PYG{p}{;}
\end{Verbatim}

\index{pitfall!cast}\index{cast!pitfall}
Here is a shot at the whole function:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Return the sum of the numbers from 1 through n. */}
   \PYG{k}{static} \PYG{k+kt}{long} \PYG{n+nf}{SumToN}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}  \PYG{c+c1}{//CHANGED:  quick and still WRONG}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{long} \PYG{n}{sum} \PYG{p}{=} \PYG{n}{n}\PYG{p}{*}\PYG{p}{(}\PYG{n}{n}\PYG{p}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{/}\PYG{l+m}{2}\PYG{p}{;}  \PYG{c+c1}{// final division will produce an integer}
      \PYG{k}{return} \PYG{n}{sum}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

Compile and test the example program containing it: \code{SumToNLongBad2.cs}.

Test it with 5, and then try 6. Ok so far, but go on to long integer range:
try 66000 that messed us up before.  ??? You get an answer that is not
a multiple of 1000: not what we got before!  What other issues do we have
between math and C\#?

Further analysis:  To make sure the function always worked, it made sense
to leave the parameter \code{n} an \code{int}.  The function would not work
with \code{n} as the largest \code{long}.  The result can still be big enough
to only fit in a \code{long}, so the return value is a \code{long}.  All
this is reasonable but the C\# result is still wrong!  Look deeper.
While the result of \code{n*(n+1)/2} is \emph{assigned} to a \code{long} variable,
the \emph{calculation} \code{n*(n+1)/2} is done with \code{int}s not mathematical
integers.  By the same general type rule that led to the (n+1)/2 error
earlier, these operations on \code{int}s produce an \code{int} result, even
when wrong.

We need to force the \emph{calculation} to produce a \code{long}.
In the correct looping version \code{sum} was a \code{long}, and that
forced all the later arithmentic to be with longs.  Here are two variations
that work:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{long} \PYG{n}{nLong} \PYG{p}{=} \PYG{n}{n}\PYG{p}{;}
\PYG{k}{return} \PYG{n}{nLong}\PYG{p}{*}\PYG{p}{(}\PYG{n}{nLong}\PYG{p}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{/}\PYG{l+m}{2}\PYG{p}{;}
\end{Verbatim}

or we can avoid a new variable name by doing a cast to \code{long}, convering
the first (left) operand to \code{long}, so all the later left-to-right
operations are forced to be \code{long}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{return} \PYG{p}{(}\PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{n}\PYG{p}{*}\PYG{p}{(}\PYG{n}{n}\PYG{p}{+}\PYG{l+m}{1}\PYG{p}{)}\PYG{p}{/}\PYG{l+m}{2}\PYG{p}{;}
\end{Verbatim}

You can try example \code{SumToNLongQuick.cs} to finally get a result that
is dependably fast and correct.

Important lessons from this humble summation problem:
\begin{itemize}
\item {} 
\emph{Working} and being \emph{efficient} are two different things in general.

\item {} 
\emph{Math} operations and C\# operations are not always the same.
Knowing this in theory is not the same as remembering it in practice.

\end{itemize}

\index{while!index sequence}\index{index!sequence, while}\index{sequence!while index}

\section{While-Statements with Sequences}
\label{while-with-sequence:while-sequence}\label{while-with-sequence:index-0}\label{while-with-sequence::doc}\label{while-with-sequence:while-statements-with-sequences}
We will process many sequences or collections.  At this point
the only collection we have discussed is a string - a sequence of
characters that we can index.
\phantomsection\label{while-with-sequence:onecharperline}
\index{example!OneCharPerLine}\index{OneCharPerLine!example}
Consider the following silly function description and heading as a start:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Print the characters of s, one per line. */}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{OneCharPerLine}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
\end{Verbatim}

\code{OneCharPerLine("bug")} would print:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] b
\item[] u
\item[] g
\end{DUlineblock}
\end{quote}

We are accessing one character at a time.  We can do that with
the indexing notation.  Thinking concretely about the example above,
we are looking to print, \code{s{[}0{]}}, \code{s{[}1{]}}, \code{s{[}2{]}}.
This requires a loop.
For now our only option is a \code{while} loop.  We can follow
our basic rubric, one step at a time:
The index is changing in a simple repetitive sequence.
We can call the
index \code{i}.  Its initial value is clearly 0.
That is our initialization.  We need a \code{while} loop continuation
condition.
For the 3-character string example, the last index above is 2.
In general we want \emph{all} the characters.  Recall the index of the last
character is the length - 1, or with our parameter{}`{}`s{}`{}`, \code{s.length - 1}
The \code{while} loop condition needs to allow indices through
\code{s.length - 1}.  We could write a condition with \code{\textless{}=} or more
concisely:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\end{Verbatim}

In the bode of the loop, the main thing is to print the next character,
and the next character is \code{s{[}i{]}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

We also need to remember the part to get ready for the next time
through the loop.  We have dealt with regular sequence of values
before.  We change \code{i} with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{p}{=} \PYG{n}{i}\PYG{p}{+}\PYG{l+m}{1}\PYG{p}{;}
\end{Verbatim}

This change is so common, there is a simpler syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
\end{Verbatim}

This increases the value of the numeric variable i by 1.
(The reverse is \code{i-{-};})

So all together:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Print the characters of s, one per line. */}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{OneCharPerLine}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

You can test this with example \code{CharLoop1.cs{}`}.

This is a very common pattern.
We could do anything we want with each individual character,
no just print it.

\index{string!PrintVowels}\index{PrintVowels!string}\phantomsection\label{while-with-sequence:printvowels}\paragraph{PrintVowels}

Let us get more complicated.  Consider the function described:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Print the vowels (aeiou) in s, one per line. */}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{PrintVowels}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
\end{Verbatim}

For instance PrintVowels(``hello'') would print:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] e
\item[] o
\end{DUlineblock}
\end{quote}

We have seen that we can go through the whole string and do the same
thing each time through the loop, use \code{s{[}i{]}} in some specific way.

This new description seems like a problem.  We do \emph{not} appear to want to do
the same thing each time:  We only want to print \emph{some} of the
characters.  Again your eyes and mind are so fast, you likely miss what you
need to do when go through \code{PrintVowels} by hand.  Your
eyes let you just grab the vowels easily, but think, what is actually
happening?  You are checking each character to see if it is a vowel,
and printing it if it is:  You are doing the same thing each time -
\emph{testing} \textbf{if} the character is a vowel.  The pseudocode is

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{is} \PYG{n}{a} \PYG{n}{vowel}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{print} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

We do want to do this each time through the loop.  We \emph{can} use
a \code{while} statement.

Next problem:  convert the pseudocode ``s{[}i{]} is a vowel'' to C\#.

There are multiple approaches.  The one you get by following your
nose is just to consider all the cases where it is true:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{=}\PYG{p}{=} \PYG{l+s+sc}{'a'}
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{=}\PYG{p}{=} \PYG{l+s+sc}{'e'}
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{=}\PYG{p}{=} \PYG{l+s+sc}{'i'}
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{=}\PYG{p}{=} \PYG{l+s+sc}{'o'}
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{=}\PYG{p}{=} \PYG{l+s+sc}{'u'}
\end{Verbatim}

How do you combine them into a condition?
The letter can be a \emph{or} e \emph{or} i \emph{or} o \emph{or} u.  We get the code:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Print the vowels (aeiou) in s, one per line. */}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{PrintVowels}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{k}{if} \PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{=}\PYG{p}{=} \PYG{l+s+sc}{'a'} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{=}\PYG{p}{=} \PYG{l+s+sc}{'e'} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{=}\PYG{p}{=} \PYG{l+s+sc}{'i'} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}}
             \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{=}\PYG{p}{=} \PYG{l+s+sc}{'o'} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{=}\PYG{p}{=} \PYG{l+s+sc}{'u'}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
         \PYG{n}{i} \PYG{p}{=} \PYG{n}{i}\PYG{p}{+}\PYG{l+m}{1}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

That has a long condition!  Here is a nice trick to shorten that:
We want to check if a character is in a group of letters.  We have
already seen the string method IndexOf.  Recall we can use it to see if
a character is in or not in a string.  We can use \code{"aeiou".IndexOf(s{[}i{]})}.
We do not care where \code{s{[}i{]}} comes in the string of vowels.
All we care is that \code{"aeiou".IndexOf(s{[}i{]}) \textgreater{}= 0}.

\index{string!Contains}\index{Contains!string}
This is still a bit of a mouthful.  Often it is just important if a
character or string is \emph{contained} in another string, not where it appears,
so it is easier to
use the string method \code{Contains}.  Though IndexOf takes either a string
or a character as parameter, \code{Contains} only takes a string.  There is a
nice quick idiom to convert anything to a string:  use \code{""+}.
The condition could be \code{"aeiou".Contains(""+s{[}i{]})}.
This adds
the string version of \code{s{[}i{]}} to the empty string.

The function is still not as general as it might be:
Only lowercase vowels are listed.  We could do something with
\code{ToLower}, or just use the condition: \code{"aeiouAEIOU".Contains(""+s{[}i{]})}

This variation is in example \code{Vowels2.cs}.

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Print the vowels (aeiou) in s, one per line. */}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{PrintVowels}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
      \PYG{k+kt}{string} \PYG{n}{vowels} \PYG{p}{=} \PYG{l+s}{"aeiouAEIOU"}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{k}{if} \PYG{p}{(}\PYG{n}{vowels}\PYG{p}{.}\PYG{n}{Contains}\PYG{p}{(}\PYG{l+s}{""}\PYG{p}{+}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
         \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

\index{double example!IsDigits}\phantomsection\label{while-with-sequence:isdigits}\paragraph{IsDigits}

Consider a variation, determining if \emph{all} the characters
in a string are vowels.  We could work on that, but it is
nit very useful.  Instead let us consider if all the
characters are digits.  This is a true-false question, so function
to determine this would return a Boolean result:

There are several ways to check if a character is a digit.  We could use the
\code{Contains} idiom from above, but here is another option:
The codes for digits are sequential,
and since characters are technically a kind of integer, we can
compare:  \code{s{[}i{]}} is a digit if it is in the range from \code{'0'}
to \code{'9'}, so the condition can be written:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sc}{'0'} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\&}\PYG{p}{\&} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{l+s+sc}{'9'}
\end{Verbatim}

Similarly  the condition \code{s{[}i{]}} is not a digit, can be written
negating the condition above or using the sam ideas as when we
considered out of range values:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textless{}} \PYG{l+s+sc}{'0'} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textgreater{}} \PYG{l+s+sc}{'9'}
\end{Verbatim}

If you think of going through by hand and checking,
you would check through the
characters sequentially and if you find a non-digit,
you would want to remember that the string is not only digits.

One way to do this is have a variable holding an answer so far:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Boolean} \PYG{n}{allDigitsSoFar} \PYG{p}{=} \PYG{k}{true}\PYG{p}{;}
\end{Verbatim}

Of course initially, you have not found any non-digits, so it starts off true.
As you go through
the string, you want to make sure that answer is changed to \code{false}
if a non-digit is encountered:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{if} \PYG{p}{(}\PYG{l+s+sc}{'0'} \PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textgreater{}} \PYG{l+s+sc}{'9'}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{allDigitsSoFar} \PYG{p}{=} \PYG{k}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

When we get all the way through the string, the answer so far is the
final answer to be returned:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** Return true if s contains one or more digits}
\PYG{c+cm}{ * and nothing else. Otherwise return false. */}
\PYG{k}{static} \PYG{n}{Boolean} \PYG{n+nf}{IsDigits}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{n}{Boolean} \PYG{n}{allDigitsSoFar} \PYG{p}{=} \PYG{k}{true}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
   \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textless{}} \PYG{l+s+sc}{'0'} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textgreater{}} \PYG{l+s+sc}{'9'}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{allDigitsSoFar} \PYG{p}{=} \PYG{k}{false}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{return} \PYG{n}{allDigitsSoFar}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Remember something to always consider:  edge cases.
In the description it says it is true for a string of \emph{one or more} digits.

Check examples of length 1 and 0.
Length 1 is fine, but it fails for the empty string,
since the loop is skipped and the initial answer, \code{true} is returned.

There are many ways to fix this.  We will know right up front that the answer
is false if the length is 0, and we could immediately set
\code{allDigitsSoFar} to false.  We would need to change the initialization
so it checks the length and chooses the right value for \code{allDigitsSoFar},
true or false, appropriate.  since we are selecting between two values,
an \code{if} statement should occur to you:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Boolean} \PYG{n}{allDigitsSoFar}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{allDigitsSoFar} \PYG{p}{=} \PYG{k}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{p}{\PYGZob{}}
    \PYG{n}{allDigitsSoFar} \PYG{p}{=} \PYG{k}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

If we substitute this initialization for \code{allDigitsSoFar},
the code will satisfy the edge case, and the code will always
work.

Examine the \code{if} statement more closely:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] if the condition is  \code{true}, \code{allDigitsSoFar} is \code{true};
\item[] if the condition is \code{false}, \code{allDigitsSoFar} is \code{false};
\end{DUlineblock}
\end{quote}

See the symmetry: the value assigned to \code{allDigitsSoFar} is always
the \emph{value of the condition}.

A \emph{much} more concise and still equivalent initialization is just:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Boolean} \PYG{n}{allDigitsSoFar} \PYG{p}{=} \PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

In more generality this
conciseness comes from the fact that it is a \emph{Boolean} value that
you are trying to set, based on a \emph{Boolean} condition:  You do not
need to do that with an \code{if} statement!  You just need an
assignment statement!  If you use an \code{if} statement in such a situation,
you mark yourself as a novice.

It could even be slightly more concise:  The precedence of assignment is
very low, lower than the comparison \code{\textgreater{}},
so the parentheses could be omitted.  We think the
code is easier to read with the parentheses left in, as written above,
and below.

The whole function would be:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Return true if s contains one or more digits}
\PYG{c+cm}{    * and nothing else. Otherwise return false. */}
   \PYG{k}{static} \PYG{n}{Boolean} \PYG{n+nf}{IsDigits}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Boolean} \PYG{n}{allDigitsSoFar} \PYG{p}{=} \PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{k}{if} \PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textless{}} \PYG{l+s+sc}{'0'} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textgreater{}} \PYG{l+s+sc}{'9'}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{allDigitsSoFar} \PYG{p}{=} \PYG{k}{false}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
         \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{allDigitsSoFar}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

You can try this code in example \code{CheckDigits1.cs}.

\index{return!from inside loop}
We are not done.  This code is still inefficient.  If an early
character in a long string is not a digit, we already know the
final answer, but this code goes through and still checks all the
other characters in the string!  People checking by hand
would stop as soon as they found a
non-digit.  We can do that in several ways with C\#, too.
Since this is a function, and we would know the final answer
where we find a non-digit,
the simplest thing is to use the fact that a return statement
\emph{immediately terminates} the function (even if in a loop).

Instead of setting a variable to \code{false} to \emph{later} be returned,
we can return right away, using the loop:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textless{}} \PYG{l+s+sc}{'0'} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textgreater{}} \PYG{l+s+sc}{'9'}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{k}{false}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

What if the loop terminates normally (no return from inside)?
That means no
non-digit was found, so if there are any characters at all,
they are all digits. There are
\emph{one or more} digits as long as the string length is \emph{positive}.
Again we do not need an \code{if} statement for a check.  Look in the full
code for the function:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Return true if s contains one or more digits}
\PYG{c+cm}{    * and nothing else. Otherwise return false. */}
   \PYG{k}{static} \PYG{n}{Boolean} \PYG{n+nf}{IsDigits}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{k}{if} \PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textless{}} \PYG{l+s+sc}{'0'} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{p}{\textgreater{}} \PYG{l+s+sc}{'9'}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{k}{false}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
         \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

The full code with a \code{Main} testing program is in
example \code{CheckDigits2.cs}.

Returning put of a loop
is a good pattern to remember for when you are searching for something,
and you know the final answer for your function as soon as you find it.

\index{interactive!loop while}\index{loop!while, interactive}\index{while!interactive loop}

\section{Interactive \texttt{while} Loops}
\label{whileinteractive:index-0}\label{whileinteractive::doc}\label{whileinteractive:interactive-while-loops}\label{whileinteractive:id1}
Next we consider a particular form of \code{while} loops, interactive ones,
involving input from the user each time through.
We consider them now for three reasons:
\begin{itemize}
\item {} 
Interactive \code{while} loops have one special `gotcha'
worth illustrating.

\item {} 
We will illustrate some general techniques for understanding and developing
\code{while} loops.

\item {} 
As a practical matter,
we can greatly improve the utilty input functions we have been using, and
add some more.

\end{itemize}

We alredy have discussed the InputInt function.  The user can choose
any int.  Sometimes we only want an integer in a certain range.
Miles has examples that handle this by just silently changing
a bad value to one at the end of the allowed range.
Another approach is to not accept a bad value, and get the user to explicitly
enter a value in the right range.  In theory the user could make errors
for some time, so a loop makes sense.  For instance we might have a slow
user, and there could be an exchange like the following
when you want a number from 0 to 100.  For illustration, user input is shown
in boldface:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Enter a score: (0 to 100) \textbf{233}
\item[] 233 is out of range!
\item[] Enter a score: (0 to 100) \textbf{101}
\item[] 101 is out of range!
\item[] Enter a score: (0 to 100) \textbf{-1}
\item[] -1 is out of range!
\item[] Enter a score: (0 to 100) \textbf{100}
\end{DUlineblock}
\end{quote}

and the value 100 would be accepted.

This is a well-defined idea.  A function makes sense.  Its heading
includes a prompt and low and high limits of the allowed range:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Continue to obtain a value from the user until it is in the}
\PYG{c+cm}{    * range [lowLim, highLim].  Then return the value in range.}
\PYG{c+cm}{    * Use the specified prompt, adding a reminder of the allowed range. */}
   \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{InputIntInRange}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{lowLim}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{highLim}\PYG{p}{)}
\end{Verbatim}

There is no need to put the limits in the prompt, since the function can
create that part from the limit parameters.  For example to generate
sequence above, the call would be:
\begin{quote}

\code{InputIntInRange("Enter a score: ", 0, 100)}
\end{quote}

\index{concrete example!splitting a loop}\index{splitting a loop!concrete example}
There is an issue with the common term ``loop'' in programming.
In normal English, a loop has no beginning and no end, like a circle.
C\# loops have a sequence of statements with a definite beginning and end.

Consider the sequence above in pseudocode.
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Input a number with prompt (233)
\item[] Print error message
\item[] Input a number with prompt (101)
\item[] Print error message
\item[] Input a number (-1)
\item[] Print error message
\item[] Input a number with prompt (100)
\item[] Return 100
\end{DUlineblock}
\end{quote}

We can break into a repeating
pattern in two ways.  The most obvious is theofllowing,
with three repetitions of a basic pattern,
with the last two line not in the same pattern
(so they would go after the loop).  :
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Input a number with prompt (233)
\item[] Print error message
\item[] 
\item[] Input a number with prompt (101)
\item[] Print error message
\item[] 
\item[] Input a number (-1)
\item[] Print error message
\item[] 
\item[] Input a number with prompt (100)
\item[] Return 100
\end{DUlineblock}
\end{quote}

Another choice, since
you can split a loop at any point, would be the following, with the first and
last lines not in the  pattern repeating three times in the middle:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Input a number with prompt (233)
\item[] 
\item[] Print error message
\item[] Input a number with prompt (101)
\item[] 
\item[] Print error message
\item[] Input a number (-1)
\item[] 
\item[] Print error message
\item[] Input a number with prompt (100)
\item[] 
\item[] Return 100
\end{DUlineblock}
\end{quote}

When you consider \code{while} loops, there is a problem with the first version:
Before the first pass through the loop and at the end of the block of code
in the body of the loop, you must be \emph{able} to run the test in the
while heading.  We will be testing the latest input from the user.

It is the second version that has us getting new input
\emph{before the first} loop and at the \emph{end of each} loop!

Now we can think more of the basic process to turn this into a C\# solution:
What variables do we need?   We will call the user's response \code{number}.

What is the test in the while loop heading?
The easilest thing to think of is that we are done when
we get something correct.  That, however, is a \emph{termination} condition.
We need to reverse it to get the \emph{continuation condition}, that the answer is
out of range.  There are two ways to be out of range:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{number} \PYG{p}{\textless{}} \PYG{n}{lowLim}
\PYG{n}{number} \PYG{p}{\textgreater{}} \PYG{n}{highLim}
\end{Verbatim}

How do we combine them?  Either one rules out a correct answer,
so \code{number} is out of range
if too high OR too low.  Remember the C\# symbolism for ``or'': \code{\textbar{}\textbar{}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{number} \PYG{p}{\textless{}} \PYG{n}{lowLim} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{number} \PYG{p}{\textgreater{}} \PYG{n}{highLim}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\end{Verbatim}

Following the sequence in the concrete example we had above,
we can see how to put things
together.
We need to get input from the user \emph{before} first beginning
the \code{while} loop, so we immediately have something to test
in the \code{while} heading's condition.

Do not reinvent the wheel!
We can use our earlier general \code{IntInput} function.  It needs a prompt.
As a first version, we can use the parameter \code{prompt}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{number} \PYG{p}{=} \PYG{n}{InputInt}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

That is the initialization step before the loop.

\index{pitfall!repeat interactive input}\index{repeat interactive input!pitfall}
If we get into the body of the loop, it means there is an error,
and the concrete example indicates we print a warning message.
The concrete example \emph{also} shows another step in the loop, asking
the user for input.  It is
easy to think
``I already have the code included to read a value from the user,
so there is nothing really to do.''  WRONG!  The intitialization code with
the input from the user is \emph{before} the loop.  C\# execution approaches the
test in the \code{while} headings from \emph{two} places:
the initialization \emph{and} coming back
from the bottom of the loop.  To get a \emph{new} value to test, we must
\emph{repeat} getting input from the user at the bottom of the loop body.

\index{pitfall!repeat declaration}\index{repeat declaration!pitfall}
You might decide to be quick
and just copy the initialization line into the bottom of the
loop (and indent it):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{number} \PYG{p}{=} \PYG{n}{InputInt}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Luckily you will get a compiler error in that situation, avoiding
more major troubleshooting:
The complete copy of the line copies the declaration
part as well as the assignment part, and mono sees the declaration of
\code{number} already there
from the scope outside the while block, and complains.

Hence copy the line, \emph{minus} the {}`{}` int{}`{}` declaration:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{number} \PYG{p}{=} \PYG{n}{InputInt}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

When the loop condition becomes false, and you get past the loop,
you have a correct value in \code{number}.  You have done all the hard work.
Do not forget to return it at the end.

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Continue to obtain a value from the user until it is in the}
\PYG{c+cm}{    * range [lowLim, highLim].  Then return the value in range.}
\PYG{c+cm}{    * Use the specified prompt, adding a reminder of the allowed range. */}
   \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{InputIntInRange}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{lowLim}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{highLim}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{number} \PYG{p}{=} \PYG{n}{InputInt}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{number} \PYG{p}{\textless{}} \PYG{n}{lowLim} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{number} \PYG{p}{\textgreater{}} \PYG{n}{highLim}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} is out of range!"}\PYG{p}{,} \PYG{n}{number}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{number} \PYG{p}{=} \PYG{n}{InputInt}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{number}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

You can try this full example, \code{PromptUserLoop1.cs}.  Look at it
and then try compiling and running.  If you ran it without looking
at the Main code, you might be confused about what values it would accept.

There are two approaches here:  The caller could give a more explicit
prompt.  Since the limits are given as parameters, anyway, we prefer
to have the program elaborate the prompt.  If the limits are -10 and 10,
automatically add to the prompt something like (-10 through 10).

We could use

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{" (\PYGZob{}0\PYGZcb{} through \PYGZob{}1\PYGZcb{}) "}\PYG{p}{,} \PYG{n}{lowLim}\PYG{p}{,} \PYG{n}{highLim}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

but we need the code twice, and it is quite a mouthful.
Thus far we have only seen the use of format strings when immediately
printing with \code{Console.Write} (or \code{WriteLine}).
Here we would like to generate a string, for \emph{use later}.

\index{string!Format}\index{Format!string}
We introduce
the C\# library function  \code{string.Format}, which does just what we want:
The parameters
have the same form as for \code{Console.Write}, but the formatted string is
\emph{returned}.

Here is a revised version, in example \code{PromptUserLoop2.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Continue to obtain a value from the user until it is in the}
\PYG{c+cm}{    * range [lowLim, highLim].  Then return the value in range.}
\PYG{c+cm}{    * Use the specified prompt, adding a reminder of the allowed range. */}
   \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{InputIntInRange}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{lowLim}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{highLim}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{longPrompt} \PYG{p}{=} \PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} (\PYGZob{}1\PYGZcb{} through \PYGZob{}2\PYGZcb{}) "}\PYG{p}{,}
                                        \PYG{n}{prompt}\PYG{p}{,} \PYG{n}{lowLim}\PYG{p}{,} \PYG{n}{highLim}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{number} \PYG{p}{=} \PYG{n}{InputInt}\PYG{p}{(}\PYG{n}{longPrompt}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{number} \PYG{p}{\textless{}} \PYG{n}{lowLim} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{number} \PYG{p}{\textgreater{}} \PYG{n}{highLim}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} is out of range!"}\PYG{p}{,} \PYG{n}{number}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{number} \PYG{p}{=} \PYG{n}{InputInt}\PYG{p}{(}\PYG{n}{longPrompt}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{number}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

The only caveat with \code{string.Format} is that
there is \emph{no} special function corresponding to \code{Console.WriteLine}.
You can generate a newline with string.Format:  Remember the
escape code \code{"\textbackslash{}n"}.  Put it at the end to go on to a newline.

This time around we did the user input correctly, with the
request for new input \emph{repeated} at the end of the loop.
That repetition \emph{is} easy to forget.  Before we see what happens, note:

\index{pitfall!infinite loop}\index{infinite loop!pitfall}
\begin{notice}{warning}{Warning:}
A \code{while} loop may be written so the continuation condition is
\emph{always} true, and the loop \emph{never} stops by itself.
This is an \emph{infinite loop}.
In practice, in many operating environments, particularly
where you are geting input from the user,
you can abort the execution of a program in
an infinite loop by entering
\code{Ctrl-C}.
\end{notice}

In particular you get an infinite loop
if you fail to get new input from the user at the
end of the loop.  The condition uses the bad
original choice forever.  Here is the mistaken version,
from example  \code{PromptUserLoop2Bad.cs}:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Continue to obtain a value from the user until it is in the}
\PYG{c+cm}{    * range [lowLim, highLim].  Then return the value in range.}
\PYG{c+cm}{    * Use the specified prompt, adding a reminder of the allowed range. */}
   \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{InputIntInRange}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{lowLim}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{highLim}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{longPrompt} \PYG{p}{=} \PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} (\PYGZob{}1\PYGZcb{} through \PYGZob{}2\PYGZcb{}) "}\PYG{p}{,}
                                        \PYG{n}{prompt}\PYG{p}{,} \PYG{n}{lowLim}\PYG{p}{,} \PYG{n}{highLim}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{number} \PYG{p}{=} \PYG{n}{InputInt}\PYG{p}{(}\PYG{n}{longPrompt}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{number} \PYG{p}{\textless{}} \PYG{n}{lowLim} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{number} \PYG{p}{\textgreater{}} \PYG{n}{highLim}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} is out of range!"}\PYG{p}{,} \PYG{n}{number}\PYG{p}{)}\PYG{p}{;}
         \PYG{c+c1}{// number = InputInt(longPrompt);  //comentted out new input}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{number}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

You can run it.  Remember \code{Ctrl-C} !
There are two tests in \code{Main}.
If you give a legal answer immediately in the first test,
it works fine (never getting into the loop body).  If you
give a bad input in the second test, you see that you can never fix it!
Remember \code{Ctrl-C} !

A more extreme abort is to close the entire console/terminal window
running the program.

\index{exercise!Agree}\index{Agree!exercise}

\subsection{Agree Function Exercise}
\label{whileinteractive:index-6}\label{whileinteractive:agree-function-exercise}\label{whileinteractive:id2}
Save example \code{PrompUserLoop4Stub.cs} as \code{PromptUserLoop4.cs}.

Yes-no (true/false) questions are common.
How might you write an input utility function \code{Agree}?
You can speed things
up by considering only the first letter of responses.
If it is important that the user enter correctly, you should
consider three categories of answer:  ones accepted as true,
ones accepted as false, and ambiguous ones.
You need to allow for
the possibility that the user keeps
giving ambiguous answers....


\subsection{Interactive Sum Exercise}
\label{whileinteractive:interactive-sumex}\label{whileinteractive:interactive-sum-exercise}
Write a program \code{SumAll.cs} that prompts the user to enter
numbers, one per line, ending with a line containing 0, and keep a
running sum of the numbers. Only print out the sum after all the
numbers are entered (at least in your \emph{final} version).


\subsection{Safe Whole Number Input Exercise}
\label{whileinteractive:safe-whole-number-input}\label{whileinteractive:safe-whole-number-input-exercise}
Save example \code{TestInputWholeStub.cs} as
\code{TestInputWhole.cs} that tests
a function \code{InputWhole}, as described below.

There is an issue with reading in numbers with the InputInt function.
If you make a typo and enter something that cannot be converted from a
string to the right kind of number, a naive program will bomb.
This is avoidable if you test the string and repeat if the string is illegal.
Places where more complicated tests for illegality are needed are
considered in {\hyperref[stringmethods2:safe-input-number]{\emph{Safe InputInt and InputDouble Exercise}}}.  For now we just consider
reading in whole numbers (integers greater than or equal to 0).
Note that such
a number is written as just a sequence of digits.
Follow the interactive model of InputIntInRange, looping until
the user enters something that is legal: in this case, all digits.

\index{\&\&!short- circuit}\index{short- circuit!\&\&}\index{\textbackslash{}\textbar{}\textbackslash{}\textbar{}!short- circuit}\index{short- circuit!\textbackslash{}\textbar{}\textbackslash{}\textbar{}}

\section{Short-Circuiting \&\& and \textbar{}\textbar{}}
\label{condition-short-circuit:short-circuiting-and}\label{condition-short-circuit:short-circuit}\label{condition-short-circuit:index-0}\label{condition-short-circuit::doc}
Follow along with the following silly, but illustrative csharp sequence:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{int} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{5}\PYG{p}{,} \PYG{n}{y} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{,} \PYG{n}{z} \PYG{p}{=} \PYG{l+m}{1}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{y}\PYG{p}{/}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{n}{z} \PYG{p}{\&}\PYG{p}{\&} \PYG{n}{x} \PYG{p}{!}\PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
\PYG{k}{false}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;} \PYG{n}{y} \PYG{p}{=} \PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{y}\PYG{p}{/}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{n}{z} \PYG{p}{\&}\PYG{p}{\&} \PYG{n}{x} \PYG{p}{!}\PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
\PYG{k}{true}
\end{Verbatim}

The compound condition includes \code{x != 0},
so what happens if we change x to 0 and
try the condition again.  Will you get \code{false}?

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{x} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{y}\PYG{p}{/}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{n}{z} \PYG{p}{\&}\PYG{p}{\&} \PYG{n}{x} \PYG{p}{!}\PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{System}\PYG{p}{.}\PYG{n}{DivideByZeroException}\PYG{p}{:} \PYG{n}{Division} \PYG{n}{by} \PYG{n}{zero}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{Verbatim}

No, one of the parts invoves dividing by zero, and you see the result.
What if we swap the two conditions to get the \emph{logically equivalent}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{x} \PYG{p}{!}\PYG{p}{=} \PYG{l+m}{0} \PYG{p}{\&}\PYG{p}{\&} \PYG{n}{y}\PYG{p}{/}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{n}{z}\PYG{p}{;}
\PYG{k}{false}
\end{Verbatim}

Something is going on here besides pure mathematical logic.
Remember the final version in {\hyperref[while-with-sequence:isdigits]{\emph{IsDigits}}}.  We did not
need to continue processing when we knew the final answer
already.  The \code{\&\&} and \code{\textbar{}\textbar{}} operators work the same way,
evaluating from left to right.  If \code{x != 0} is \code{false},
then \code{x != 0 \&\& y/x \textgreater{} z} starts off being evaluated like
\code{false \&\& ??}.  We do no need the second part evaluated to
know the overall result is \code{false}, so C\#
\emph{does not evaluate further}.  This behavior has
acquired the jargon \emph{short-circuiting}.  Many computer languages share
this feature.

It also applies to \code{\textbar{}\textbar{}}.  In what situation do you know
what the final result is after evaluating
the first conditon?  In this case you know:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{true} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{p}{?}\PYG{p}{?}
\end{Verbatim}

evaluates to true.  Continuing with the same csharp sequence above
(where x is 0, y is 5, and z is 1):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{x} \PYG{p}{=}\PYG{p}{=} \PYG{l+m}{0} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{y}\PYG{p}{/}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{n}{z}\PYG{p}{;}
\PYG{k}{true}
\end{Verbatim}

The division by 0 in the second condition \emph{never happens}.
It is short-circuited.

For completeness, try the other order:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{y}\PYG{p}{/}\PYG{n}{x} \PYG{p}{\textgreater{}} \PYG{n}{z} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{x} \PYG{p}{=}\PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
\PYG{n}{System}\PYG{p}{.}\PYG{n}{DivideByZeroException}\PYG{p}{:} \PYG{n}{Division} \PYG{n}{by} \PYG{n}{zero}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{Verbatim}

This idea is useful in the \code{Agree} function, where you
want to deal with the first character in the user's answer.

In situations where you want to
test conditionThatWillBombWithBadData, you want to avoid
causing an Exception.
When there is good data, you want the result to actually
come from conditionThatWillBombWithBadData.  There are two cases,
however, depending on what result
you want if the data for this condition \emph{is bad}, so you cannot evaluate it:
\begin{itemize}
\item {} 
If you want ther result to be \code{false} with bad data for the dangerous
condition, use
\begin{quote}

falseConditionIfDataBad \code{\&\&} conditionThatWillBombWithBadData
\end{quote}

\item {} 
If you want the result to be \code{true} with bad data for
the dangerous condition, use
\begin{quote}

trueConditionIfDataBad \code{\textbar{}\textbar{}} conditionThatWillBombWithBadData
\end{quote}

\end{itemize}


\section{While Examples}
\label{whileexamples:while-examples}\label{whileexamples::doc}
\begin{notice}{note}{Todo}

``bisection method''
\end{notice}


\subsection{Savings Exercise}
\label{whileexamples:savings-exercise}
The idea here is to see how many years it will take a bank account to grow
to at least a given value, assuming a fixed annual interest.
Write a program \code{Savings.cs}.
Prompts the user for three numbers: an initial balance, the annual percentage
for interest as a decimal. like .04 for 4\%, and the final balance desired.
Print the initial balance, and the balance each year until
the desired amount is reached. Round displayed amounts
to two decimal places, as usual.

The math:  The amount next year is the amount now times
(1 + interest fraction),
so if I have \$500 now and the interest rate is .04,
I have \$500*(1.04) = \$520 after one year, and after two years I have,
\$520*(1.04) = \$540.80.
If I enter into the program a \$500 starting balance, .04 interest rate and
a target of \$550, the program prints:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{5}\PYG{l+m}{0}\PYG{l+m}{0.00}
\PYG{l+m}{5}\PYG{l+m}{2}\PYG{l+m}{0.00}
\PYG{l+m}{5}\PYG{l+m}{4}\PYG{l+m}{0.80}
\PYG{l+m}{5}\PYG{l+m}{6}\PYG{l+m}{3.42}
\end{Verbatim}


\subsection{Strange Sequence Exercise}
\label{whileexamples:strange-sequence-exercise}\label{whileexamples:strange-seq-ex}
Save the example program \code{StrangeSeqStub.cs} as \code{StrangeSeq.cs},

There are three functions to complete.  Do one at a time and test.

\code{Jump}: First complete the definitions of function \code{Jump}.
For any integer \code{n}, \code{Jump(n)} is \code{n/2} if \code{n} is even,
and \code{3*n+1} if \code{n} is odd.
In the \code{Jump} function definition use an \code{if}-\code{else}
statement.  Hint \footnote{
If you divide an even number by 2, what is the remainder?  Use this idea
in your \code{if} condition.
}

\code{PrintStrangeSequence}:
You can start with one number, say n = 3, and \emph{keep} applying the
\code{Jump} function to the \emph{last} number given,
and see how the numbers jump around!

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{3}\PYG{p}{)} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{*}\PYG{l+m}{3}\PYG{p}{+}\PYG{l+m}{1} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{p}{;} \PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{1}\PYG{l+m}{0}\PYG{p}{)} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{p}{/}\PYG{l+m}{2} \PYG{p}{=} \PYG{l+m}{5}\PYG{p}{;}
\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{)} \PYG{p}{=} \PYG{l+m}{3}\PYG{p}{*}\PYG{l+m}{5}\PYG{p}{+}\PYG{l+m}{1} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{6}\PYG{p}{;} \PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{1}\PYG{l+m}{6}\PYG{p}{)} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{6}\PYG{p}{/}\PYG{l+m}{2} \PYG{p}{=} \PYG{l+m}{8}\PYG{p}{;}
\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{8}\PYG{p}{)} \PYG{p}{=} \PYG{l+m}{8}\PYG{p}{/}\PYG{l+m}{2}  \PYG{p}{=}   \PYG{l+m}{4}\PYG{p}{;} \PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{4}\PYG{p}{)} \PYG{p}{=}   \PYG{l+m}{4}\PYG{p}{/}\PYG{l+m}{2} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;}
\PYG{n}{Jump}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{)} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{/}\PYG{l+m}{2}  \PYG{p}{=}   \PYG{l+m}{1}
\end{Verbatim}

This process of repeatedly applying the same function to the most recent result
is called function \emph{iteration}.  In this case you see that iterating the
\code{Jump} function, starting from n=3, eventually reaches the value 1.

It is an \emph{open research question} whether iterating the Jump function
from an integer \code{n} will eventually reach 1,
for \emph{every} starting integer \code{n} greater than 1.
Researchers have only found examples of \code{n} where it is true.
Still, no general argument has been made to apply to the
\emph{infinite} number of possible starting integers.

In the PrintStrangeSequence you iterate the \code{Jump} function
starting from parameter value \code{n}, until the result is 1.

\code{CountStrangeSequence}:  Iterate the \code{Jump} function as in
\code{PrintStrangeSequence}.  Instead of printing each number in the sequence,
just count them, and return the count.

\index{string!methods}

\section{More String Methods}
\label{stringmethods2:more-string-methods}\label{stringmethods2:index-0}\label{stringmethods2::doc}\label{stringmethods2:id1}
Before we do more elaborate things with strings, some more string methods
will be helpful.  Be sure you are familiar with the earlier discussion of
strings in
{\hyperref[basicstringops:basic-string-ops]{\emph{Basic String Operations}}}.

Play with the new string methods in csharp!

This variation of \code{IndexOf} has a second parameter:

\index{string!IndexOf}\index{IndexOf!string}\begin{description}
\item[{\code{int IndexOf(string target, int start)}}] \leavevmode
Returns the index of the beginning of the first occurrence of the string
\code{target}
in \textbf{this} string object, starting at index \code{start} or after.
Returns -1 if \code{target} is not found. Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{state} \PYG{p}{=} \PYG{l+s}{"Mississippi"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{print}\PYG{p}{(}\PYG{l+s}{"01234567890\PYGZbs{}n"}\PYG{p}{+}\PYG{n}{state}\PYG{p}{)} \PYG{c+c1}{// to see indices}
\PYG{l+m}{0}\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{l+m}{6}\PYG{l+m}{7}\PYG{l+m}{8}\PYG{l+m}{9}\PYG{l+m}{0}
\PYG{n}{Mississippi}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{state}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{"is"}\PYG{p}{,} \PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// same as state.IndexOf("is");}
\PYG{l+m}{1}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{state}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{"is"}\PYG{p}{,} \PYG{l+m}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{4}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{state}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{"is"}\PYG{p}{,} \PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{-}\PYG{l+m}{1}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{state}\PYG{p}{.}\PYG{n}{IndexOf}\PYG{p}{(}\PYG{l+s}{"i"}\PYG{p}{,} \PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{7}
\end{Verbatim}

\end{description}

\index{string!Trim}\index{Trim!string}\begin{description}
\item[{\code{string Trim()}}] \leavevmode
Returns a string formed from \textbf{this} string object, but
with leading and trailing whitespace removed. Example:

\begin{Verbatim}[commandchars=\\\{\}]
csharp\textgreater{} string s = "\PYGZbs{}n  123    ";
csharp\textgreater{} "\#" + s + "\#";
\#
  123   \#
csharp\textgreater{} "\#" + s.Trim() + "\#";
\#123\#
\end{Verbatim}

\end{description}

\index{string!Replace}\index{Replace!string}\begin{description}
\item[{\code{string Replace(string target, string replacement)}}] \leavevmode
Returns a string formed from \textbf{this} string by replacing
all occurrences of the substring \code{target} by \code{replacement}.
Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{k+kt}{string} \PYG{n}{s} \PYG{p}{=} \PYG{l+s}{"This is it!"}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{Replace}\PYG{p}{(}\PYG{l+s}{" "}\PYG{p}{,} \PYG{l+s}{"/"}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"This/is/it!"}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{Replace}\PYG{p}{(}\PYG{l+s}{"is"}\PYG{p}{,} \PYG{l+s}{"at"}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"That at it!"}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"oooooh"}\PYG{p}{.}\PYG{n}{Replace}\PYG{p}{(}\PYG{l+s}{"oo"}\PYG{p}{,} \PYG{l+s}{"ah"}\PYG{p}{)}\PYG{p}{;}
\PYG{l+s}{"ahahoh"}
\end{Verbatim}

\end{description}

\index{string!StartsWith}\index{StartsWith!string}\begin{description}
\item[{\code{Boolean StartsWith(string prefix)}}] \leavevmode
Returns \code{true} if  \textbf{this} string object starts
with string \code{prefix}, and \code{false} otherwise.
Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"-123"}\PYG{p}{.}\PYG{n}{StartsWith}\PYG{p}{(}\PYG{l+s}{"-"}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{true}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"downstairs"}\PYG{p}{.}\PYG{n}{StartsWith}\PYG{p}{(}\PYG{l+s}{"down"}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{true}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"1 - 2 - 3"}\PYG{p}{.}\PYG{n}{StartsWith}\PYG{p}{(}\PYG{l+s}{"-"}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{false}
\end{Verbatim}

\end{description}

\index{string!EndsWith}\index{EndsWith!string}\begin{description}
\item[{\code{Boolean EndsWith(string suffix)}}] \leavevmode
Returns \code{true} if  \textbf{this} string object ends
with string \code{suffix}, and \code{false} otherwise.
Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"-123"}\PYG{p}{.}\PYG{n}{EndsWith}\PYG{p}{(}\PYG{l+s}{"-"}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{false}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"downstairs"}\PYG{p}{.}\PYG{n}{EndsWith}\PYG{p}{(}\PYG{l+s}{"airs"}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{true}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{l+s}{"downstairs"}\PYG{p}{.}\PYG{n}{EndsWith}\PYG{p}{(}\PYG{l+s}{"air"}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{false}
\end{Verbatim}

\end{description}

\index{exercise!CountRep}\index{CountRep!exercise}

\subsection{Count Repetitions in a String}
\label{stringmethods2:index-6}\label{stringmethods2:count-repetitions-in-a-string}\label{stringmethods2:countrep}
Write a program \code{TestCountRep.cs}, with a Main testing method,
that tests a function with the following heading:

\begin{Verbatim}[commandchars=\\\{\}]
 \PYG{c+cm}{/**Return the number of separate repetitions of target}
\PYG{c+cm}{  * in s. */}
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{CountRep}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{target}\PYG{p}{)}
\end{Verbatim}

For example here is what \code{CountRep( "Mississippi", target)}
would return with various values for \code{target}:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \code{"i"}: 4
\item[] \code{"is"}: 2
\item[] \code{"sss"}: 0
\end{DUlineblock}
\end{quote}

Assume each repetition is completely separate, so
\code{CountRep("Wheee!", "ee")} returns 1.  The last
two e's do not count, since the middle e is already
used int he match of the first two e's.

\index{exercise!safe InputInt}\index{safe InputInt!exercise}\index{exercise!safe InputDouble}\index{safe InputDouble!exercise}

\subsection{Safe InputInt and InputDouble Exercise}
\label{stringmethods2:safe-inputint-and-inputdouble-exercise}\label{stringmethods2:index-7}\label{stringmethods2:safe-input-number}
Save the example \code{SafeNumberInputStub.cs} as \code{SafeNumberInput.cs}.

The idea is to write safe versions of the utility functions
InputInt and InputDouble (which can then be used in further
places like InputIntInRange).

Be sure you are familiar with {\hyperref[whileinteractive:safe-whole-number-input]{\emph{Safe Whole Number Input Exercise}}},
and the development of its \code{InputWhole} function.

A legal whole number string consists entirely of digits.  We have
already written example \code{IsDigits} to identify a string for a
whole number.

The  improvements to InputInt and InputDouble are
very similar and straightforward \emph{if} you have developed the two main
Boolean support functions,
\code{IsIntString} and{}`{}`IsDecimalString{}`{}` respectively.

The issue with integer and decimal strings
is that they may include parts other than
digits.  An integer may start with a minus sign.  A
decimal number can also contain a decimal point in an appropriate
place.  The suggestion is to confirm that these other characters appear in
legal places, remove them, and see that what is left is digits.
The recently introduced string methods should help....

Develop the functions in order and test after each one:
write \code{IsIntString}, revise \code{InputInt},
write \code{IsDecimalString}, and revise \code{InputDouble}.

Be sure to test carefully.  Not only confirm that all
appropriate strings return \code{true}:
Also be sure to test that you return \code{false"}
for \emph{all} sorts of bad strings.

Hopefully
you learned something from writing the earlier InputWhole.
Probably it is not worth keeping in our utility library
any longer, since we have
the more general and safe InputInt, and we can
restrict to many ranges with InputIntInRange.


\section{More While Examples}
\label{gcdexamples:more-while-examples}\label{gcdexamples::doc}
\index{\%!binary operation}\index{binary operation!\%}\index{\%!remainder}\index{remainder!\%}\index{remainder!binary operation}\index{binary operation!remainder}\index{PF4!recursion}\index{recursion!PF4}\index{SP1!history}\index{history!SP1}\index{history!Euclid}\index{Euclid!history}

\subsection{Greatest Common Divisor}
\label{gcdexamples:index-0}\label{gcdexamples:greatest-common-divisor}
The greatest common divisor of two non-zero integers is a great
example to illustrate the power of loops. Everyone learns about the
\emph{concept} of a greatest common divisor when faced with a fraction that
is not in \emph{reduced} form.

Consider the fraction $\frac{2}{4}$, which is the same as
$\frac{1}{2}$. This fraction can be reduced, because the
numerator and denominator both have greatest common factor of 2. That
is, $\frac{2}{4} = \frac{1 \cdot 2}{2 \cdot 2}$. So the factor of 2 can
be canceled from both the numerator and the denominator.

Euclid (the mathematician from classic times and author of \emph{Elements})
is credited with having come up with a clever algorithm for how to
compute the greatest common divisor efficiently. It is written as
follows, where $a \bmod b$ means \code{a \% b} in C\#.
\begin{gather}
\begin{split}gcd(a, b) = gcd(b, a \bmod b)\end{split}\notag\\\begin{split}gcd(a, 0) = a\end{split}\notag
\end{gather}
It is common in mathematics to list functions as one or more
\emph{cases}. The way you read this is as follows:
\begin{itemize}
\item {} 
In general, the greatest common divisor of \code{a} and \code{b} is the
same as computing the greatest common divisor of \code{b} and the
remainder of \code{a} divided by \code{b}.

\item {} 
In the case where \code{b} is zero, the result is \code{a}. This makes
sense because \code{a} divides itself and 0.

\end{itemize}

To gain some appreciation of how the definition \emph{always} allows you to
compute the greatest common divisor, it is worthwhile to try it out
for a couple of numbers where you \emph{know} the greatest common
divisor. For example, we already know that the greatest common divisor
of 10 and 15 is 5. Let's use Euclid's method to verify this:
\begin{itemize}
\item {} 
$gcd(10, 15) = gcd(15, 10 \bmod 15) = gcd(15, 10)$

\item {} 
$gcd(15, 10) = gcd(10, 15 \bmod 10) = gcd(10, 5)$

\item {} 
$gcd(10, 5) = gcd(5, 10 \bmod 5) = gcd(5, 0)$

\item {} 
$gcd(5, 0) = 5$

\end{itemize}

Notice that in the example above, the first number (10) was smaller than
the second (15), and the first transformation just swapped the numbers,
so the larger number was first.  Thereafter the first number is always
larger.

In other words, Euclid's method is smart enough to work for 10 and 15
and 15 and 10. And it must. After all, the greatest common divisor of
these two numbers is always 5 as the order doesn't matter.


\subsection{GCD ``Brute Force'' Method}
\label{gcdexamples:gcd-brute-force-method}
Now that we've gotten the preliminaries out of the way and have a basic
mathematical explanation for how
to calculate the greatest common divisor,
we'll take a look at how to translate this into code using the
machinery of while loops that you've recently learned.

The way GCD is formulated above is, indeed, the most clever way to
calculate the greatest common divisor.
Yet the way we learn about the greatest common divisor in elementary
school (at least at first) is to
learn how to factor the numbers a and b, often in a brute force way.
So for example, when calculating the
greatest common divisor of 10 and 15, we can immediately see it,
because we know that both of these
numbers are divisible by 5 (e.g. 5 * 2 = 10 and 5 * 3 = 15).
So the greatest common divisor is 5.

But if we had something more tricky to do like 810 and 729,
we might have to think a bit more.

Before we learn to find the factors of numbers,
we will often just ``try'' numbers until we get the
greatest common divisor. This sort of trial process can take place in a loop,
where we start at 1 and end at min(a, b)? Why the minimum?
Well, we know that none of the values after the minimum can divide both a and b
(in integer division) because either a / b = 0 or b / a = 0, if a != b.

You can verify this by picking any two different values of a and b.
For example 810/729 \textgreater{} 0 and 729/810 = 0.

Without further ado, let's take a look at a basic version of GCD:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{k}{public} \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{GreatestCommonDivisor} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{n} \PYG{p}{=} \PYG{n}{Math}\PYG{p}{.}\PYG{n}{Min} \PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
         \PYG{k+kt}{int} \PYG{n}{gcd}\PYG{p}{,} \PYG{n}{i}\PYG{p}{;}

         \PYG{n}{i} \PYG{p}{=} \PYG{n}{gcd} \PYG{p}{=} \PYG{l+m}{1}\PYG{p}{;}
         \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{a} \PYG{p}{\PYGZpc{}} \PYG{n}{i} \PYG{p}{=}\PYG{p}{=} \PYG{l+m}{0} \PYG{p}{\&}\PYG{p}{\&} \PYG{n}{b} \PYG{p}{\PYGZpc{}} \PYG{n}{i} \PYG{p}{=}\PYG{p}{=} \PYG{l+m}{0}\PYG{p}{)}
               \PYG{n}{gcd} \PYG{p}{=} \PYG{n}{i}\PYG{p}{;}
            \PYG{n}{i} \PYG{p}{=} \PYG{n}{i} \PYG{p}{+} \PYG{l+m}{1}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
         \PYG{k}{return} \PYG{n}{gcd}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
\end{Verbatim}

This code works as follows:
\begin{itemize}
\item {} 
We begin by finding \code{Math.Min(a, b)}.
This is how to compute the minimum of any two
values in C\#. Technically, we don't need to use the minimum of a and b,
but there is no
point in doing any more work than necessary.
We'll use the variable \code{i} as the loop index
and the variable \code{gcd} will hold the currently known value of the GCD.

\item {} 
The line \code{i = gcd = 1} means we'll start i at 1
and assume that the GCD is one until
we find a higher value that also divides a and b.

\item {} 
The line \code{while (i \textless{}= n)} is used to indicate that we are
iterating the values of
\code{i} until the minimum of \code{a} and \code{b} (computed earlier) is reached.

\item {} 
The line \code{if (a \% i == 0 \&\& b \% i == 0)}
is used to check whether we have found a
new value that replaces our previous \emph{candidate} for the GCD.
A value can only be
a candidate for the GCD if it divides a and b without a remainder.
The modulus
operator \code{\%} is our way of determining whether there is a
remainder from the
division operation \code{a / i} or \code{b / i}.

\item {} 
The line \code{i = i + 1} is our way of going to the next value of \code{i}
to be tested as the new GCD.

\item {} 
When this loop terminates, the greatest common divisor has been found.

\end{itemize}

So this gives you a relatively straightforward way of calculating the
greatest common divisor. While simple, it is not necessarily the most
efficient way of determining the GCD? If you think about what is going on,
this loop could run a significant number of times.
For example, if you were calculating the GCD two very large numbers, say,
one billion (1,000,000,000) and two billion (2,000,000,000)
it is painfully evident that you would consider a large number of values
(a billion, in fact) before obtaining
the candidate GCD, which we know is 1,000,000,000.


\subsection{GCD Subtraction Method}
\label{gcdexamples:gcd-subtraction-method}
\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{k}{public} \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{GreatestCommonDivisor} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{c}\PYG{p}{;}
         \PYG{k}{while} \PYG{p}{(}\PYG{n}{a} \PYG{p}{!}\PYG{p}{=} \PYG{n}{b}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{while} \PYG{p}{(}\PYG{n}{a} \PYG{p}{\textgreater{}} \PYG{n}{b}\PYG{p}{)} \PYG{p}{\PYGZob{}}
               \PYG{n}{c} \PYG{p}{=} \PYG{n}{a} \PYG{p}{-} \PYG{n}{b}\PYG{p}{;}
               \PYG{n}{a} \PYG{p}{=} \PYG{n}{c}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{while} \PYG{p}{(}\PYG{n}{b} \PYG{p}{\textgreater{}} \PYG{n}{a}\PYG{p}{)} \PYG{p}{\PYGZob{}}
               \PYG{n}{c} \PYG{p}{=} \PYG{n}{b} \PYG{p}{-} \PYG{n}{a}\PYG{p}{;}
               \PYG{n}{b} \PYG{p}{=} \PYG{n}{c}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
         \PYG{p}{\PYGZcb{}}
         \PYG{k}{return} \PYG{n}{a}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Preview: Recursive GCD}
\label{gcdexamples:preview-recursive-gcd}
As it turns out, we can transform the earlier definition of greatest
common divisor (as formulated by Euclid) directly into C\# using a
technique known as \emph{recursion}, where a function calls \emph{itself}
inside its definition. We don't expect you to master this
technique immediately but do feel that it is important you at least
\emph{hear} about it and see its tremendous power:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{k}{public} \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{GreatestCommonDivisor} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{)}
      \PYG{p}{\PYGZob{}}
         \PYG{k}{if} \PYG{p}{(}\PYG{n}{b} \PYG{p}{=}\PYG{p}{=} \PYG{l+m}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}\PYG{l+s}{"gcd(\PYGZob{}0\PYGZcb{}, \PYGZob{}1\PYGZcb{}) = \PYGZob{}0\PYGZcb{}"}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return} \PYG{n}{a}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
            \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine} \PYG{p}{(}
            \PYG{l+s}{"gcd(\PYGZob{}0\PYGZcb{}, \PYGZob{}1\PYGZcb{}) = gcd(\PYGZob{}1\PYGZcb{}, \PYGZob{}0\PYGZcb{} mod \PYGZob{}1\PYGZcb{} = gcd(\PYGZob{}1\PYGZcb{}, \PYGZob{}2\PYGZcb{})"}\PYG{p}{,}
             \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{p}{\PYGZpc{}} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{return} \PYG{n+nf}{GreatestCommonDivisor} \PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{p}{\PYGZpc{}} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{Verbatim}
\begin{itemize}
\item {} 
Recalling our earlier definition, the case $gcd(a, 0) = a$ is
handled by lines 3-6.

\item {} 
And the case $gcd(a, b) = gcd(b, a \bmod b)$ is handled by
line 11.

\item {} 
Lines 4 and 8-10 exist to show you all of the \emph{steps} that Euclid's
algorithm takes to compute the greatest common divisor.

\end{itemize}

The mathematical definition of gcd \emph{refers to itself} in its own definition.
The recursive version of the \code{gcd} function \emph{refers to itself}
by \emph{calling} itself.  Though this seems circular, you can see
from the examples that it works very well.  The important point is that
the calls to the same function are not completely the same:
\emph{Successive} calls have \emph{smaller} second numbers, and the second
number eventually reaches 0, and in that case
there is a direct final answer.

\index{statement!do while}\index{do while!statement}

\section{Do-While Loops}
\label{do-while:index-0}\label{do-while:do-while}\label{do-while::doc}\label{do-while:do-while-loops}
Suppose you want the user to enter three integers for sides of a
right triangle.  If they do not make a right triangle, say so
and make the user try again.

One way to look at the while statement rubric is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{set} \PYG{n}{data} \PYG{k}{for} \PYG{n}{conditions}
\PYG{n+nf}{while} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{accomplish} \PYG{n}{something}
   \PYG{k}{set} \PYG{n}{data} \PYG{k}{for} \PYG{n}{condition}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

As we have pointed out before this involves setting data in two places.
With the triangle problem, three pieces fo data need to be entered,
while the condition to test is fairly simple (and in any case the condition
could be calculated in a function).

A \code{do}-\code{while} loop will help here.  It tests the condition at the end of the
loop, so there is no need to gather data before the loop:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{;}
\PYG{k}{do} \PYG{p}{\PYGZob{}}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Think of integer sides for a right triangle."}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{a} \PYG{p}{=} \PYG{n}{IntInput}\PYG{p}{(}\PYG{l+s}{"Enter integer leg: "}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{p}{=} \PYG{n}{IntInput}\PYG{p}{(}\PYG{l+s}{"Enter another integer leg: "}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{c} \PYG{p}{=} \PYG{n}{IntInput}\PYG{p}{(}\PYG{l+s}{"Enter integer hypotenuse: "}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{a}\PYG{p}{*}\PYG{n}{a} \PYG{p}{+} \PYG{n}{b}\PYG{p}{*}\PYG{n}{b} \PYG{p}{!}\PYG{p}{=} \PYG{n}{c}\PYG{p}{*}\PYG{n}{c}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Not a right triangle: Try again!"}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{k}{while} \PYG{p}{(}\PYG{n}{a}\PYG{p}{*}\PYG{n}{a} \PYG{p}{+} \PYG{n}{b}\PYG{p}{*}\PYG{n}{b} \PYG{p}{!}\PYG{p}{=} \PYG{n}{c}\PYG{p}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The general form of a \code{do}-\code{while} statement is
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \code{do \{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s)
\end{DUlineblock}
\item[] \code{\} while (} \emph{continuationCondition} \code{);}
\end{DUlineblock}
\end{quote}

Here the block of statement(s) is always executed, but it continues
to be executed in a loop only so long as the condition tested
after the loop body is true.

\begin{notice}{note}{Note:}
A \code{do}-\code{while} loop is the \emph{one} place where you \emph{do} want a semicolon
right after a condition, unlike the places mentioned in
{\hyperref[ifpitfalls:dangerous-semicolon]{\emph{Dangerous Semicolon}}}.  At least if you omit it here you
are likely to get a compiler error rather than a difficult logical
bug.
\end{notice}

A \code{do}-\code{while} loop, like the example above,
that accomplishes exactly the same thing as the \code{while}
loop rubric above, can have the form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{do} \PYG{p}{\PYGZob{}}
   \PYG{k}{set} \PYG{n}{data} \PYG{k}{for} \PYG{n}{condition}
   \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)} \PYG{p}{\PYGZob{}}
       \PYG{n}{accomplish} \PYG{n}{something}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}} \PYG{k}{while} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

It only sets the data to be tested once.
(The tradeoff is that the condition is tested twice.)

\index{labs!string manipulations}

\section{Number Guessing Game Lab}
\label{lab-number-game:index-0}\label{lab-number-game::doc}\label{lab-number-game:number-guessing-game-lab}\label{lab-number-game:lab-number-game}
\textbf{Objectives}:
\begin{itemize}
\item {} 
Work with functions

\item {} 
Work with interactive while loops

\item {} 
Use decisions

\item {} 
Introduce random values

\end{itemize}

This lab is inspired by a famous game played by children (and grown-ups,
too) known as the number-guessing game. It is often played by two
people but could be played by any number of people.

The rules are:
\begin{itemize}
\item {} 
Person A chooses a positive integer less than N and keeps it in his or
her head.

\item {} 
Person B makes repeated guesses to determine the number. Person A
must indicate whether the guess is higher or lower.

\item {} 
Person A must tell the truth.

\end{itemize}

So as an example:
\begin{itemize}
\item {} 
George and Andy are playing the game.

\item {} 
George chooses a positive number less than 100 (29) and puts it in his
head.

\item {} 
Andy guesses 50. George says ``Lower''. Andy now knows that
$1 \leq number < 50$.

\item {} 
Andy guesses 25. George says ``Higher''. Andy now knows that
$26 \leq number < 50$.

\item {} 
Andy guesses 30. George says ``Lower''. Andy now knows that the
$26 \leq number < 30$.

\item {} 
Andy starts thinking that he is close to knowing the correct answer. He
decides to guess 29. Andy guesses the correct number. So George
says, ``Good job! You win.''

\end{itemize}

We are going to elaborate this game in small steps.  You might save
the intermediate versions under new names.

The computer code for the
game is going to be acting like Player A.


\subsection{Part 1: No Hints; Fixed Secret Number}
\label{lab-number-game:part-1-no-hints-fixed-secret-number}
You are going to play a game, and later may repeat it, so put the code
for playing the number game in a function called \code{Game}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Game}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

For now your Main function can just call \code{Game()}.

Copy in the functions from previous code so you can use \code{InputInt}.

In \code{Game}:
\begin{enumerate}
\item {} 
For the simplest versions, which help testing, have the
program assign a specific
secret number (like 29), and call it \code{secret}.
Admittedly, this is not much fun for the player the second time!

\item {} 
Prompt the player for a guess.  Every time the player guesses wrong,
print ``Wrong!''.  A later version will give clues.  Keep
prompting for another number until the player guesses correctly.
(Since you, the programmer, knows the secret number, this need not go
on forever.)

\item {} 
When the player guesses the right number, print ``Correct!  You win!''

\end{enumerate}

Sample play could look like:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Guess the number: \textbf{55}
\item[] Wrong!
\item[] Guess the number: \textbf{12}
\item[] Wrong!
\item[] Guess the number:  \textbf{29}
\item[] Good job!  You win!
\end{DUlineblock}
\end{quote}

You could alspo make the game stop immediately,
(since you know the secret number):
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Guess the number:  \textbf{29}
\item[] Good job!  You win!
\end{DUlineblock}
\end{quote}


\subsection{Part 2: Add Hints}
\label{lab-number-game:part-2-add-hints}
In \code{Game}:
Instead of just printing ``Wrong!'' when the player is incorrect,
print ``Lower!'' or ``Higher!''  as appropriate.  For example:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Guess the number: \textbf{55}
\item[] Lower!
\item[] Guess the number: \textbf{12}
\item[] Higher!
\item[] Guess the number: \textbf{25}
\item[] Higher!
\item[] Guess the number:  \textbf{29}
\item[] Good job!  You win!
\end{DUlineblock}
\end{quote}


\subsection{Part 3:  Add a Random Secret Number}
\label{lab-number-game:part-3-add-a-random-secret-number}
In \code{Game}, make the following alterations and additions:
\begin{enumerate}
\item {} 
For now set an \code{int} variable \code{big} to 100.  We will make sure
the secret number is less than \code{big}.

\item {} 
Have the program print
``In this game you guess a positive number less than 100.''
For future use it is best if you have the printing statement
reference the variable \code{big}, rather than the literal \code{100}.

\end{enumerate}

\index{random number generator}\begin{enumerate}
\item {} 
Thus far the secret number was fixed in the program.  Now we are
going to let it vary, by having the game generate a \emph{random} number.
For your convenience, we are going to give you the C\#
code to compute the random number.  Assuming we want a secret number
so $1 \leq secret < big$, we can use the code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Random} \PYG{n}{r} \PYG{p}{=} \PYG{k}{new} \PYG{n}{Random}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{secret} \PYG{p}{=} \PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,} \PYG{n}{big}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

In case you are wondering, we are creating a \emph{new object}
of the \emph{class} \code{Random} which serves as the
random number generator. We'll cover this in more detail when we
get to the Classes and Objects section. Here is some illustration
in csharp.  Your answers will not be the same!

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{Random} \PYG{n}{r} \PYG{p}{=} \PYG{k}{new} \PYG{n}{Random}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{5}\PYG{l+m}{5}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}\PYG{l+m}{1}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{7}\PYG{l+m}{9}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{4}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{3}
\PYG{n}{csharp}\PYG{p}{\textgreater{}} \PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{l+m}{2}\PYG{p}{,} \PYG{l+m}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m}{2}
\end{Verbatim}

In general the minimum possible value of the number returned by \code{r.Next}
is the first parameter, and the value returned is always less than
the second parameter.

You can see that \code{r.Next()} is smart enough to give what appears to
be a randomly chosen number every time. If you call it 100 times, it is
likely that you'll see the same number twice!

Example (where \code{secret} ended up as 68):
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Guess a number less than 100!
\item[] Guess the number: \textbf{60}
\item[] Higher!
\item[] Guess the number: \textbf{72}
\item[] Lower!
\item[] Guess the number: \textbf{66}
\item[] Lower!
\item[] Guess the number: \textbf{68}
\item[] Good job!  You win!
\end{DUlineblock}
\end{quote}

For degugging purposes, you might want to have \code{secret}
be printed out right away
(but eliminate that part when everything works)!

\end{enumerate}


\subsection{Part 4:  Let the Player Set the Range of Values}
\label{lab-number-game:part-4-let-the-player-set-the-range-of-values}
In \code{Game}:
Instead of setting \code{big} automatically to 100, make \code{big}
be a parameter, so the heading looks like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{Game}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{big}\PYG{p}{)}
\end{Verbatim}

In \code{Main}:
\begin{enumerate}
\item {} 
Prompt the player for the limit on the secret number.
An exchange might look like:
\begin{quote}

Enter a secret number bound: \textbf{10}
\end{quote}

\item {} 
Pass the value given by the player to the \code{Game} function.

\end{enumerate}

Hence the program might start with:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Enter a secret number bound: \textbf{10}
\item[] Guess a number less than 10!
\item[] Guess the number: \textbf{5}
\item[] Higher!
\item[] Guess the number: \textbf{7}
\item[] Lower!
\item[] Guess the number: \textbf{6}
\item[] Good job!  You win!
\end{DUlineblock}
\end{quote}


\subsection{Part 5:  Count the Guesses}
\label{lab-number-game:part-5-count-the-guesses}
In \code{Game}: When the player finally wins, print the number of guesses
the player made.  For example, for the game sequence shown above,
the last line would become:
\begin{quote}

Good job!  You win on guess 3!
\end{quote}

You need to keep a count, adding 1 with each guess.


\subsection{Possible Extra Credit Improvements or Variations}
\label{lab-number-game:possible-extra-credit-improvements-or-variations}
Should you finish everything early, try the following:
\begin{enumerate}
\item {} 
\textbf{(20\% extra credit)}  In \code{Main}:

Use an outer \code{while} loop to allow the game to be played
repeatedly. Change the prompt for the bound in \code{Main} to:
\begin{quote}

Enter a secret number bound (or 0 to quit):
\end{quote}

Continue to play games until the player enters 0 for the bound.

\item {} 
\textbf{(40\% extra credit)}
Write the opposite program, where the user is the one who knows the secret
number and the computer guesses numbers until the answer
is obtained. You can keep the same \code{Main}, that sets \code{big}.
The new Game will tell the user to put a number in
his/her head, and press return to continue.
(You can throw away the string entered - this is just to cause a pause.)
Then the computer guesses.
For simpicity let the human enter ``L'' for lower, ``H'' for higher, and
``E'' for equal (when the computer wins).
As you saw in the initial example with George and Andy,
each hint reduces the range of the possible secret numbers.
Have the computer guess a random number in the \emph{exact} range that
remains possible.

To do this you must note the asymmetry of the parameters for the method
\code{Next}:  suppose \code{n = r.Next(low, higher)}, then
\begin{quote}

$low \leq number < higher$
\end{quote}

The first parameter \emph{may} be returned, but second
parameter is \emph{never} returned.

You will need two parameters \code{low} and \code{higher} that keep
bracketing the allowed range.  The simplest thing is to set them so they
will be the parameters for the following call to \code{Next}.

That would mean initially \code{low}
is 1 and \code{higher} is equal to \code{big}.
With each hint you adjust one or the other of \code{low} and \code{higher} so they
get closer together.
The game ends after the human enters ``E''.

Have the computer complain that the human is cheating (and stop the game)
if the computer
guesses the only posible value, and the human does \emph{not} respond with ``E''.

\end{enumerate}

\index{homework!input-output decisions}\index{input-output!decisions, homework}\index{decisions!homework input-output}\index{homework!input-output loops}\index{input-output!loops, homework}\index{loops!homework input-output}

\section{Homework: Grade Calculation from Individual Scores}
\label{homework-gradecalculation2:homework-grade-calculation-from-individual-scores}\label{homework-gradecalculation2:homework-grade-calculation2}\label{homework-gradecalculation2:index-0}\label{homework-gradecalculation2::doc}
In the previous assignment, we calculated grades based on a \emph{memorized}
overall grade within each of the categories below, as in this example:
\begin{itemize}
\item {} 
exams - 40\% (integer weight is 40)

\item {} 
labs - 15\% (weight 15)

\item {} 
homework - 15\% (weight 15)

\item {} 
project - 20\% (weight 20)

\item {} 
participation - 10\% (weight 10)

\end{itemize}

In this assignment, we are going to change the specification slightly
to make the program a bit smarter. Instead of someone having to remember
what their average grade was for each category, we will prompt the user for
the number of items within each category (e.g. number of exams, number
of labs, etc.), have the user enter individual grades, and have the program
calculate the average for the category.

As usual, we will begin by specifying \emph{requirements}. Whenever required,
we will explain how you would approach the solution to the requirement
in C\#.  User responses are shown \textbf{bold faced}.


\subsection{Functional Requirements}
\label{homework-gradecalculation2:functional-requirements}\begin{enumerate}
\item {} 
Instead of bombing out if the weights don't add up to 100, use a
\code{do \{ ... \} while} loop (see Miles p. 43-44) to prompt the user again
for all of the weights until they do add up to 100. The \code{do \{ ... \} while}
loop is the right choice here, because you can test all of the weights
at the end of the loop, after each time they have been entered
in the loop.

\item {} 
Add code to prompt the user for the number of items in each category:
\begin{quote}

Please enter the number of exams: \textbf{3}
\end{quote}

\item {} 
Instead of prompting the user for an overall average
exam grade, use a loop  to
read one grade at a time. The grades will be added together (on the fly)
to give the grade for that category. For example, after you have asked
for the number of exams, you'd prompt the user to enter each exam
grade and have the program compute the sum.
To make sure everyone understands what should
be happening, you should also print a \emph{running total} of the grade
category you're calculating:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] Please enter the grade for exam 1: \textbf{100}
\item[] Total exam points: 100
\item[] 
\item[] Please enter the grade for exam 2: \textbf{90}
\item[] Total exam points: 190
\item[] 
\item[] Please enter the grade for exam 3: \textbf{80}
\item[] Total exam points: 270
\item[] 
\item[] Calculated average exam grade = 90.0
\end{DUlineblock}
\end{quote}

Write a function, \code{FindAverage},
to do this, and that can be reused for each
category.  (Since it works for each category, the category
\emph{name} will need to be a parameter to \code{FindAverage}.)

\item {} 
Once you have read in the data for each of the items within a category,
you'll basically be able to \emph{reuse} the code that you developed in the
previous assignment to compute the weighted average and print the
final letter grade.

\end{enumerate}


\subsection{Style Requirements}
\label{homework-gradecalculation2:style-requirements}\begin{enumerate}
\item {} 
For this assignment, you are expected to start using functions for all
aspects of the assignment. For example, it can become tedious in a hurry
to write code to prompt for each of exams, labs, homeworks, etc. when
a single function (with parameter named \emph{category}) could be used to
avoid repeating yourself. (And per the Hints section, you will also
want to write your function to take advantage of our \emph{input}
functions.

\item {} 
Also beginning with this assignment, it is expected that your work
will be presented neatly. That is, we expect the following:
\begin{itemize}
\item {} 
proper indentation that makes your program more readable by other
humans. Use all spaces, not tabs to indent.  You never know what
default tabs your grader will have set up.

\item {} 
proper naming of classes and functions. In C\#, the convention is to
begin a name with a capital letter. You can have multiple words in a
name, but these should be capitalized using a method known as
CamelCase {\hyperref[homework-gradecalculation2:camelcase]{{[}CamelCase{]}}}. We also recommend this same naming convention
for variables but with a lowercase first letter.
For variables, we are also
ok with the use of underscores. For example, in homework 1 we used
names like \emph{exam\_grade}. If you use CamelCase, you can name this
variable \emph{examGrade}.

\item {} 
If you have any questions about the neatness or appearance of your
code, please talk to the instructor or teaching assistant.

\item {} 
This guide from CIS 193 at {\hyperref[homework-gradecalculation2:upenncsharp]{{[}UPennCSharp{]}}}
provides a nice set of conventions
to follow. We include this here so you know that other faculty at
other universities also consider neatness/apperance to be important.

\end{itemize}

\end{enumerate}


\subsection{Hints}
\label{homework-gradecalculation2:hints}
This assignment will be the first one where you need to start using
functions. Otherwise, you'll find yourself getting tired within minutes
of starting your work.{}`

You need to have two functions to prompt the user to input
integer and double
data. We're going to give you the code for these here and in
example \code{PromptUser1.cs}.  Your job is to
copy them into your program and make use of them in your solution.  The
first function is
a supporting function to return a string in response to a prompt.
These versions are sufficient for the assignment,
though you are \emph{welcomed} to replace these
with more \emph{robust} versions that get developed in class later:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Return a line from the keyboard}
\PYG{c+cm}{    * after displaying the prompt. */}
   \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{InputLine}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+cm}{/** Return an integer entered from the keyboard}
\PYG{c+cm}{    * after displaying the prompt. */}
   \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{InputInt}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{nStr} \PYG{p}{=} \PYG{n}{InputLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Trim removes enclosing blanks}
      \PYG{k}{return} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{nStr}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+cm}{/** Return a double entered from the keyboard}
\PYG{c+cm}{    * after displaying the prompt. */}
   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{InputDouble}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{nStr} \PYG{p}{=} \PYG{n}{InputLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Trim removes enclosing blanks}
      \PYG{k}{return} \PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{nStr}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{Grading Rubric}
\label{homework-gradecalculation2:grading-rubric}
\begin{notice}{warning}{Warning:}
As a general rule, we expect programs to be complete,
compile correctly, run, and be
thoroughly tested. We are able to grade an incomplete program
but will only give at most 10/25
for effort. Instead of submitting something incomplete,
you are encouraged to complete your program and
submit it per the late policy.  Start early and get help!
\end{notice}

25 point assignment broken down as follows:
\begin{itemize}
\item {} 
Loop until weights add to 100: 5

\item {} 
Average any number of grades in a category: 5

\item {} 
One function that is reused and works for the average in each category: 5

\item {} 
Previous program features still work: 5

\item {} 
Style: 5

\end{itemize}


\subsection{Logs and Partners}
\label{homework-gradecalculation2:logs-and-partners}
You may work with a partner, following good pair-programming practice,
sharing responsibility for all parts.

Only one of a pair needs to submit the actual programming assignment.
However \emph{both} students, \emph{independently}, should write and
include a log in their
Homework submission.  Students working alone should also submit a log,
with fewer parts.

Each individual's log should indicate each of the following clearly:
\begin{itemize}
\item {} 
Your name and who your partner is (if you have one)

\item {} 
Your approximate total number of hours working on the homework

\item {} 
Some comment about how it went - what was hard ...

\item {} 
An assessment of your contribution (if you have a partner)

\item {} 
An assessment of your partner's contribution (if you have a partner).

\end{itemize}

Just omit the parts about a partner if you do not have one.

\begin{notice}{note}{Note:}
Name the log file with the exact file name:
``log.txt'' and make it a plain text file.
You can create it in a program editor or in a fancy document editor.
If you use a fancy document editor, be sure to save it an a plain text file,
usually indicated by the ''.txt'' suffix.
\end{notice}
\phantomsection\label{lab-monodevelop:lab-monodevelop}
\index{labs!MonoDevelop}

\section{Lab: Using MonoDevelop}
\label{lab-monodevelop:lab-using-monodevelop}\label{lab-monodevelop:index-0}\label{lab-monodevelop::doc}

\subsection{Rationale for this Lab}
\label{lab-monodevelop:rationale-for-this-lab}
Now that we have developed basic fluency in editing, compiling, and
running programs, we are now going to start using something called the
\emph{integrated development environment} (the IDE). Professional software
developers generally prefer the IDE, because the IDE does for software
development what a word processor does for writing. That said, a word
processor won't make you a better writer but will help you to avoid
some of the pitfalls that plague writers: spelling, grammar, and
style, among other formatting features. When it comes to programming,
you've already learned that working at the command line can be an
exercise in frustration. You will often make basic syntax errors or
forget to do something ``grammatically'' like declaring a variable or
not using a particular feature of the language properly. It can be
tricky to fix errors, especially when the error output scrolls beyond
the visible terminal area. While there are ways to work around these
issues, the use of an IDE is far more efficient and allows us to
maintain our collective sanity.

So the IDE is here to help you, and it is now time to start using it
for our labs, homework, and (eventually) your project. You might
wonder why we don't teach it from the beginning. The rationale is
simple. You need to know the basics of how a program is put together
and run. It is part of learning to think like a computer scientist and
software developer. Furthermore, we want to be able to assume that you
know at least one of the \emph{basics}: executable programs and how to run
them. When we compile a Mono program, we get an output file named
\emph{Name}.exe, where this \emph{Name} can be anyhing, say,
\code{HelloWorld.exe}. When we use the IDE, MonoDevelop, we'll still be
getting this executable and be able to run it either within our
outside of MonoDevelop.


\subsection{Goals}
\label{lab-monodevelop:goals}
In this lab, we're going to set the table for the rest of the
course. So please do whatever you can to complete each part. It is
entirely possible we will spend two lab periods working on this lab.

Our primary goal to create a C\# Solution that you can use to do all of
the remaining homework assignments and labs this semester. If you
wish, you can create as many solutions as you like, but C\# allows you
to create a single solution and add (at any time) projects to it. This
will provide by far the best experience for you in the course, where
you can keep adding onto previous efforts without having to start over
each time. (As we'll see in this lab, you'll also have a way of making
\emph{use} of previous work, which is an incredibly powerful concept in
software engineering that many CS courses and real-world software
projects depend upon.)

We're going to create a solution that will contain (at least) three different
projects:
\begin{enumerate}
\item {} 
A project that contains our familiar Hello, World example. This
will be used to make sure that everyone can create something that
works, much like we did in the first lab.

\item {} 
A project that contains the \emph{input} functions that we have been
using in various examples (e.g. InputInt and InputString).

\item {} 
A project that makes use of the \emph{input} functions. This project
can contain whatever code you like, including your homework
assignment. This project will use something called a \emph{reference}
to make use of the \emph{input} library.

\end{enumerate}


\subsection{Steps}
\label{lab-monodevelop:steps}
So let's begin. We'll start by creating a \emph{solution} and add projects
to it one at a time.
\begin{enumerate}
\item {} 
Create a new blank solution using the following steps:
\begin{itemize}
\item {} 
Go File -\textgreater{} New -\textgreater{} Solution

{\hfill\includegraphics{FileNewSolution.png}\hfill}

\item {} 
Select C\# in left hand side panel

\item {} 
Select Empty Project in right hand side panel

\item {} 
Leave the Location field as is.

\item {} 
Enter any solution name you like (we recommend Last name, First name,
followed by 170, e.g. ThiruvathukalGeorge170) in the Name field.

\item {} 
For the Solution name

\item {} 
Make sure \emph{Create directory for solution} is checked.

\item {} 
Press the Forward button.

\item {} 
At the Project Features form, just press ok.

\item {} 
You now have created your first empty solution in MonoDevelop. We can now add \emph{projects}
to this \emph{solution}. Because your project is empty, it won't
actually do anything until we add some \emph{projects} to it.

\end{itemize}

\item {} 
Create a project for the familiar ``Hello, World!'' program:
\begin{itemize}
\item {} 
Place the mouse over the Solution \emph{folder} in the Solution pane
(on the left hand side).

\item {} 
Right click, select Add -\textgreater{} Add New Project

{\hfill\includegraphics{AddHelloProject.png}\hfill}

\item {} 
Select C\# in the left panel and Console Project in the right
panel. Enter Hello in the Name field.

\item {} 
Press the Forward button.

\item {} 
At the Project Features form, just press ok.

\item {} 
You'll now see the Hello folder. Click on Hello (beneath the
Solution) in the left panel and you'll see \code{Main.cs}. If you
double click on Main.cs, you will notice the familiar ``Hello,
World!'' program. In the current versions of mono, a new C\#
console project always creates a minimal, functioning program so
you can test MonoDevelop and Mono for their ability to build a
working project.

{\hfill\includegraphics{BrowseHelloProject.png}\hfill}

\end{itemize}

Now you can actually \emph{run} the program defined by this project:
\begin{itemize}
\item {} 
Right click on Hello.

\item {} 
Select \emph{Build Hello} or \emph{Rebuild Hello}.

\item {} 
If the build was successful, which it will be, you will see
\emph{Build successful.} in the status line.

\item {} 
Right click on Hello.

\item {} 
Select \emph{Run Item}.

\item {} 
If all goes well, you will see the familiar \emph{console} pop up with
the output from your program.

{\hfill\includegraphics{HelloRunOutput.png}\hfill}

Note that what you see here may vary, depending on whether you
use OS X, Windows, or another platform (Linux).

\end{itemize}

\item {} 
Create one or more projects for each of your labs/homework
assignments. For this last part you will add a project, which can
make use of code that you wrote in a previous lab or assignment:
\begin{itemize}
\item {} 
Add a project as we did in step 1.

\item {} 
Name your project appropriately. For example, if you want to take
the first homework assignment and move it to MonoDevelop, you
could name it Homework1. You could also name it GradeCalc or
something similar.

\item {} 
You don't need to retype the code that you've already created,
compiled, and run. Instead, you can just open it up in the text
editor and copy/paste it into the \code{Main.cs} file for your new
project. (You'll first want to delete the ``Hello, World!'' code
that MonoDevelop creates \emph{every time} you add a new C\# project.

\item {} 
You should now have \emph{two} projects: Hello and Homework1 (or
GradeCalc).

\item {} 
Build and Run the program to see whether it works.

\end{itemize}

\item {} 
Create a library project for the Input Utilities.

In many of our examples, we have made use of some functions to
handle various aspects of user input. For example:

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Return a line from the keyboard}
\PYG{c+cm}{    * after displaying the prompt. */}
   \PYG{k}{static} \PYG{k+kt}{string} \PYG{n+nf}{InputLine}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{Console}\PYG{p}{.}\PYG{n}{ReadLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+cm}{/** Return an integer entered from the keyboard}
\PYG{c+cm}{    * after displaying the prompt. */}
   \PYG{k}{static} \PYG{k+kt}{int} \PYG{n+nf}{InputInt}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{nStr} \PYG{p}{=} \PYG{n}{InputLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Trim removes enclosing blanks}
      \PYG{k}{return} \PYG{k+kt}{int}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{nStr}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+cm}{/** Return a double entered from the keyboard}
\PYG{c+cm}{    * after displaying the prompt. */}
   \PYG{k}{static} \PYG{k+kt}{double} \PYG{n+nf}{InputDouble}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{prompt}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{string} \PYG{n}{nStr} \PYG{p}{=} \PYG{n}{InputLine}\PYG{p}{(}\PYG{n}{prompt}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Trim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Trim removes enclosing blanks}
      \PYG{k}{return} \PYG{k+kt}{double}\PYG{p}{.}\PYG{n}{Parse}\PYG{p}{(}\PYG{n}{nStr}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

It is rather tedious for us to copy these functions every time we
want to make use of them. In MonoDevelop, we can \emph{package} these
functions into a \emph{library}. Much like your local public library,
where you can grab a book when you need it, a library in
MonoDevelop allows you to grab methods whenever you need them. In
this case, we'll create a simple class to hold our input methods
named \code{InputUtilities} and copy the above code into it. Let's do
it.
\begin{itemize}
\item {} 
On the solution you have created for your overall project, right
click and select Add -\textgreater{} Add New Project.

\item {} 
Select C\# and Library/C\#.

\item {} 
Enter \code{InputUtils} as the project name and press Forward as
many times as required to complete the process.

\item {} 
You now have a new library project.

\item {} 
You'll see a class named \code{MyClass.cs}. You can keep this name,
but it would be nice to give this class a name that has something
to do with \emph{input}. Right click on MyClass.cs to select the
Rename option and give it any name you like (we suggest
\code{InputUtils.cs}).

\item {} 
Now double click on the file to open it in the editor. We're
going to make a few alterations.
\begin{itemize}
\item {} 
Change namespace to \code{namespace InputUtils}, if it has not been set this
way already.

\item {} 
Change \code{public MyClass} to \code{public Input}.

\item {} 
If you see a method named \code{public MyClass}, remove it and its
braces. This is called a class constructor and is not needed
(but is harmless if you want to keep it).

\item {} 
Copy the code for the two Input functions above in between the
brackets (inside the class Input).

\item {} 
We need to make one change, now that we are putting our
functions into a library. We need to add the \code{public} keyword
before the word \code{static}. This indicates that these functions
can be used by \emph{anyone} who has access to the class
\code{Input}. We'll come to understand this in more detail when we
learn about classes and objects. (So just do it, even if you
don't fully understand it yet!)

\end{itemize}

\item {} 
When you are done,  you should have something like the following:

{\hfill\includegraphics{InputUtilsCS.png}\hfill}

\item {} 
As in the previous part, let's check whether our entire solution
\emph{builds} properly. From the Build menu, select Build All. If you
encounter any errors, you'll have to correct them.

\end{itemize}

\item {} 
Create a console project that makes use of the Input Utilities by
adding a reference to the Input Utilities library (created in the
previous step).

Now that we have a library project, we can create another project
that uses this library. That is, much like when we say \code{using
System} we now have a way of making use of our own \emph{stuff}. That
is, we can say \code{using InputUtils} and then call our \emph{input}
functions.
\begin{itemize}
\item {} 
Much like we did for the initial \code{Hello} project, we are going
create a new project called \code{InputTesting}. To make sure you
know how to do this, you must do the \code{Add New Project} like we
did earlier.

\item {} 
Once you have the new project, you need to \emph{reference} the
library.

\item {} 
In the Solution pane (explorer), you will see a folder named
References underneath InputTesting. Right click to Edit
References.

\item {} 
If all has gone according to plan, you should see \code{InputUtils}
as an ``assembly'' (.Net's fancy name for a compiled
library). Check the checkbox next to InputUtils so we can use it
in our new project.

\item {} 
Now click on \code{MyClass.cs} in the \code{InputTesting} project and
do the following:
\begin{itemize}
\item {} 
Add \code{using InputUtils}.

\item {} 
Create a Main() method to prompt the user for any desired input
(integer, string, etc.) We are just testing whether we can see
the functions that we referenced in InputUtils.

\item {} 
To call the input functions, we need to do things a bit
differently than in the past. Because we are now using a
separate class (Input) from the class that is using the
functions (MyClass), we need to use the \emph{dot} syntax to call
it. For example, this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{n}{InputInt}\PYG{p}{(}\PYG{l+s}{"Please enter an integer: "}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

is now:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{n}{Input}\PYG{p}{.}\PYG{n}{InputInt}\PYG{p}{(}\PYG{l+s}{"Please enter an integer: "}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{itemize}

\item {} 
As before, you should be able to Build -\textgreater{} Build All and then run
this simple program. You might want to use a
\code{Console.WriteLine} to write the variable \code{i} to the
console.

\end{itemize}

\end{enumerate}

So that's it! At this point, you will have a solution with three
projects. Incidentally, everything we have shown here does also work
in Microsoft Visual Studio. You may find that the instructions vary
slightly. Because our course places great emphasis on learning
computer science on the platform of your choice, we're only doing this
in Mono and MonoDevelop (for now).

So the next time you have a lab or homework assignment, you can start
by adding a new project to this existing solution. This will allow
you to build on ideas we have explored previously. As you become more
\emph{seasoned} as an introductory computer science student, you will find
yourself saying, ``I think I have done something like this before.'' If
properly packaged into a library, you can make use of the code again
and again in your work, which can be a real time saver!

\index{double loop!foreach}

\chapter{Foreach Loops}
\label{foreach:foreach-loops}\label{foreach:index-0}\label{foreach::doc}\label{foreach:foreach}

\section{\texttt{foreach} Syntax}
\label{foreachintro:foreach-syntax}\label{foreachintro::doc}\label{foreachintro:id1}
\index{statement!foreach}\index{foreach!statement}
This sections on \code{foreach} loops and the later {\hyperref[for:for-loops]{\emph{For Loops}}}
introduce new looping statements.
Neither is absolutely necessary:
You could do all the same things with \code{while} loops,
but there are many situations where \code{foreach} loops and \code{for} loops
are more convenient and easier to read.

A \code{foreach} statement
only works with an object that holds a sequence or collection.
We will see many more kinds of sequences later.  For now we can illustrate
with a string, which is a sequence of characters.

We have already processed strings a character at a time, with \code{while} loops.
We took advantage of the fact that strings could be indexed, and our \code{while}
loops directly controlled the sequence of indices, and then we could
look up the character at each index:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{use} \PYG{k}{value} \PYG{n}{of} \PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Examples have been in {\hyperref[while-with-sequence:while-sequence]{\emph{While-Statements with Sequences}}}, like

\begin{Verbatim}[commandchars=\\\{\}]
   \PYG{c+cm}{/** Print the characters of s, one per line. */}
   \PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{OneCharPerLine}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;}
      \PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
\end{Verbatim}

In this example we really only care about the characters, not the indices.
Managing the indices is just a way to get at the
underlying sequence of characters.

A conceptually simpler view is just:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{each} \PYG{n}{character} \PYG{k}{in} \PYG{n}{s}
    \PYG{n}{use} \PYG{n}{the} \PYG{k}{value} \PYG{n}{of} \PYG{n}{the} \PYG{n}{character}
\end{Verbatim}

To \emph{use} ``the character'' in C\#, we must be able to refer to it.
We might name the current character \code{ch}.
The following is a variant of \code{OneCharPerLine} with a \code{foreach}
loop:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{OneCharPerLine}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k}{foreach} \PYG{p}{(}\PYG{k+kt}{char} \PYG{n}{ch} \PYG{k}{in} \PYG{n}{s}\PYG{p}{)} \PYG{p}{\PYGZob{}}
       \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{ch}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

That is all you need!   The \code{foreach} heading feeds us one
character from \code{s} each time through, using the name \code{ch}
to refer to it.
Of course any new variable name must be declared in C\#, so \code{ch}
is preceded in the heading by its type, \code{char}.
Then we can use \code{ch} inside the body of the loop.
Advancing to the next element in the sequence is automatic in the next
time through the loop.  No \code{i++} to remember;
no possibility of an infinite loop!

The general syntax of a \code{foreach} loop is
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \code{foreach (} \textbf{type itemName} \code{in} \emph{sequence} \code{) \{}
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s) using \textbf{itemName}
\end{DUlineblock}
\item[] \code{\}}
\end{DUlineblock}
\end{quote}

Here is a version of IsDigits:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{n}{Boolean} \PYG{n+nf}{IsDigits}\PYG{p}{(}\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k}{foreach} \PYG{p}{(}\PYG{k+kt}{char} \PYG{n}{ch} \PYG{k}{in} \PYG{n}{s}\PYG{p}{)} \PYG{p}{\PYGZob{}}
       \PYG{k}{if} \PYG{p}{(}\PYG{n}{ch} \PYG{p}{\textless{}} \PYG{l+s+sc}{'0'} \PYG{p}{\textbar{}}\PYG{p}{\textbar{}} \PYG{n}{ch} \PYG{p}{\textgreater{}} \PYG{l+s+sc}{'9'}\PYG{p}{)} \PYG{p}{\PYGZob{}}
          \PYG{k}{return} \PYG{k}{false}\PYG{p}{;}
       \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{return} \PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{Length} \PYG{p}{\textgreater{}} \PYG{l+m}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

See the advantages of \code{foreach} in these examples:
\begin{itemize}
\item {} 
They are more concise than the indexing versions.

\item {} 
They keep the emphasis on the characters, not the secondary indicies.

\item {} 
The \code{foreach} heading emphasizes that a particular sequence is being
processed.

\end{itemize}

\emph{If} you have explicit need to refer to the indices of the items in the sequence,
then this pattern does not work.  You can use a \code{while} loop, or perhaps a
\code{for} loop, introduced soon....


\section{foreach Examples}
\label{foreachexamples::doc}\label{foreachexamples:foreach-examples}
\index{char!underlying numeric code}\phantomsection\label{foreachexamples:codeofstringchar}
In {\hyperref[while-with-sequence:isdigits]{\emph{IsDigits}}} we use the underlying int code value
of the characters in comparisons.
When printing, you cannot see this code directly,
since the \code{char} type prints as \emph{characters}!
To see the underlying code value for a character, ch,
it can be cast to an int:  \emph{(int)ch{}`}

We can easily write a loop to print the unicode value of each character in a
string, \code{s}.  We do not need indices here, so a \code{foreach} loop is
appropriate:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{foreach} \PYG{p}{(}\PYG{k+kt}{char} \PYG{n}{ch} \PYG{k}{in} \PYG{n}{s}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"Code for \PYGZob{}0\PYGZcb{} is \PYGZob{}1\PYGZcb{}."}\PYG{p}{,} \PYG{n}{ch}\PYG{p}{,} \PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{n}{ch}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Many more examples will come when we introduce more kinds of sequence.

\index{for!loop}\index{loop!for}

\chapter{For Loops}
\label{for:index-0}\label{for::doc}\label{for:for-loops}\label{for:id1}
\index{statement!for}

\section{For-Statement Syntax}
\label{forstatements:index-0}\label{forstatements::doc}\label{forstatements:for-statement-syntax}
We now introduce the last kind of loop syntax: \code{for} loops.

A \code{for} loop is an example of \emph{syntactic sugar}:  syntax that can simplify
things for the programmer, but can be immediately translated into an
equivalent syntax by the compiler.  For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{sum} \PYG{p}{=} \PYG{n}{sum} \PYG{p}{+} \PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

is exactly equivalent to this code simliar to part of
{\hyperref[whilestatements:sumton]{\emph{SumToN}}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{i}\PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{sum} \PYG{p}{=} \PYG{n}{sum} \PYG{p}{+} \PYG{n}{i}\PYG{p}{;}
   \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

More generally:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \code{for (} \emph{initialization} \code{;} \emph{condition} ; \emph{update} \code{)} \{
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s)
\end{DUlineblock}
\item[] \code{\}}
\end{DUlineblock}
\end{quote}

translates to
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \emph{initialization} \code{;}
\item[] \code{while (} \emph{condition} \code{)} \{
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] statement(s)
\item[] \emph{update}
\end{DUlineblock}
\item[] \code{\}}
\end{DUlineblock}
\end{quote}

In the example above, \emph{initialization} is \code{i=2}, \emph{condition} is \code{i \textless{}= n},
and \emph{update} is \code{i++}.

Why bother with this rearrangement?  It is a matter of taste,
but the heading:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\end{Verbatim}

puts all the information about the variable controlling the loop
into one place at the top, which may help quickly visualize the overall
sequence in the loop.  If you use this format, and get used to the
three parts you are less likely to forget the \code{i++}
than when it comes tacked on to the end of a while loop body, after all
the specific things you were trying to accomplish.

Although the \code{for} loop syntax is very general,
a strongly recommended convention
is to only use a \code{for} statement when all the control of variables
determining loop repetition are in the heading.

For example if a \code{for}
loop uses \code{i} in the heading, \code{i} can have a value assigned or
reassigned in the heading, but should \emph{not} have its value modified
anywhere inside the loop body.
If you want more complicated behavior, use a \code{while} loop.

A \code{for} loop can also include variable declaration in the initialization,
as in:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{sum} \PYG{p}{=} \PYG{n}{sum} \PYG{p}{+} \PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

This is close, but not quite equivalent to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{2}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{sum} \PYG{p}{=} \PYG{n}{sum} \PYG{p}{+} \PYG{n}{i}\PYG{p}{;}
   \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Variables declared in a \code{for} loop heading are local to the
\code{for} loop heading and body.  The variable \code{i} declared before
the \code{while} statement above is still defined after the \code{while} loop.

The two semicolons are always needed in the \code{for} heading, but any of the
parts they normally separate may be omitted.
If the condition part is omitted, the condition is
interpreted as always true, leading to an infinite loop, that can only
terminate due to a \code{return} or \code{break} statement in the body.
See Miles, page 46, for a discussion of \code{break}.

\textbf{Other variations}

As in a regular local variable declaration,
there may be several variables of the
same type initialized at the beginning of a \code{for} loop heading,
separated by commas.  Also, at the end of the \code{for} loop heading, the
update portion may include more than one expression, separated by commas.
For example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{,} \PYG{n}{j} \PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\textless{}} \PYG{n}{j}\PYG{p}{;} \PYG{n}{i} \PYG{p}{=} \PYG{n}{i}\PYG{p}{+}\PYG{l+m}{2}\PYG{p}{,} \PYG{n}{j}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{}"}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The comma separated lists in a \code{for} statement heading
are mentioned here for completeness.  Later we will find a situation
where this is actually useful.


\section{Examples With \texttt{for} Statements}
\label{forexamples:examples-with-for-statements}\label{forexamples::doc}
Thus far all of our \code{for} loops have used a sequence of successive integers.
Suppose you want to print the first \code{n} multiples of \code{k},
like the first 5 multiples
of 3:  3, 6, 9, 12, 15.  This could be handled by generating
a sequence \code{i} = 1 through \code{n}, and multiply each \code{i} by \code{k}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{1}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{i}\PYG{p}{*}\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Another approach is to note that the numbers you want to print advance
in a regular fashion, too, but with an increment 3 in the example above,
or k in general:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{n}{k}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{n}{n}\PYG{p}{*}\PYG{n}{k}\PYG{p}{;} \PYG{n}{i} \PYG{p}{=} \PYG{n}{i}\PYG{p}{+}\PYG{n}{k}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{p}{=} \PYG{n}{i} \PYG{p}{+} \PYG{n}{k}\PYG{p}{;}
\end{Verbatim}

is a common pattern, less common than incrementing by one,
but still very common.  C\# and many other languages allow a shorter version:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{p}{+}\PYG{p}{=} \PYG{n}{k}\PYG{p}{;}
\end{Verbatim}

This means to increment the variable i by k.

\begin{notice}{warning}{Warning:}
Be careful: the \code{+=} must be in
that order, with no space between.  Unfortunately the reverse order:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{i} \PYG{p}{=}\PYG{p}{+} \PYG{n}{k}\PYG{p}{;}
\end{Verbatim}

is also legal, and just assigns the value of k to i.
\end{notice}

\index{double operator!+=}\index{double operator!-=}\index{double operator!*=}\index{double operator!/=}\index{double operator!\%=}
Most C\# binary operations have a similar variation.  For instance
if \emph{op} is \code{+}, \code{-}, \code{*}, \code{/} or \code{\%},
\begin{quote}

\textbf{variable} \emph{op}= \emph{expression}
\end{quote}

means the same as
\begin{quote}

\textbf{variable} = \textbf{variable} op \emph{expression}
\end{quote}

For example

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{p}{*}\PYG{p}{=} \PYG{l+m}{5}\PYG{p}{;}
\end{Verbatim}

is the same as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{p}{=} \PYG{n}{x} \PYG{p}{*} \PYG{l+m}{5}\PYG{p}{;}
\end{Verbatim}

\index{format!field width}\index{field width!format}\index{format!table}\index{table!format}\index{example!PowerTable.cs}\index{PowerTable.cs!example}\paragraph{Tables}

Reports commonly include tables, often with successive lines generated by
a consistent formula.  As a simple first
table can show the square, cube, and square root of numbers 1 through 10.
The Math class has a function Sqrt, so we take the square root with Math.Sqrt
function.  The formula is consistent, so we can loop easily:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(} \PYG{k+kt}{int} \PYG{n}{n} \PYG{p}{=} \PYG{l+m}{1}\PYG{p}{;} \PYG{n}{n} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{p}{;} \PYG{n}{n}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0\PYGZcb{} \PYGZob{}1\PYGZcb{} \PYGZob{}2\PYGZcb{} \PYGZob{}3\PYGZcb{}"}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{*}\PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{*}\PYG{n}{n}\PYG{p}{*}\PYG{n}{n}\PYG{p}{,} \PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sqrt}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The numbers will be there, but it is not pretty:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1} \PYG{l+m}{1} \PYG{l+m}{1} \PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{4} \PYG{l+m}{8} \PYG{l+m}{1.4142135623731}
\PYG{l+m}{3} \PYG{l+m}{9} \PYG{l+m}{2}\PYG{l+m}{7} \PYG{l+m}{1.73205080756888}
\PYG{l+m}{4} \PYG{l+m}{1}\PYG{l+m}{6} \PYG{l+m}{6}\PYG{l+m}{4} \PYG{l+m}{2}
\PYG{l+m}{5} \PYG{l+m}{2}\PYG{l+m}{5} \PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{5} \PYG{l+m}{2.23606797749979}
\PYG{l+m}{6} \PYG{l+m}{3}\PYG{l+m}{6} \PYG{l+m}{2}\PYG{l+m}{1}\PYG{l+m}{6} \PYG{l+m}{2.44948974278318}
\PYG{l+m}{7} \PYG{l+m}{4}\PYG{l+m}{9} \PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{3} \PYG{l+m}{2.64575131106459}
\PYG{l+m}{8} \PYG{l+m}{6}\PYG{l+m}{4} \PYG{l+m}{5}\PYG{l+m}{1}\PYG{l+m}{2} \PYG{l+m}{2.82842712474619}
\PYG{l+m}{9} \PYG{l+m}{8}\PYG{l+m}{1} \PYG{l+m}{7}\PYG{l+m}{2}\PYG{l+m}{9} \PYG{l+m}{3}
\PYG{l+m}{1}\PYG{l+m}{0} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{l+m}{0} \PYG{l+m}{3.16227766016838}
\end{Verbatim}

First we might not need all those digits in the square root approximations.
We can replace \code{\{3\}} by \code{\{3:F4\}} to just show 4 decimal places.

There are not nice columns lining up.  We can adjust the spacing to make nice
columns by using a further formatting option.  The longest entries are all
in the last row, where they take up, 2, 3, 4, and 6 columns (for 3.1623).
Change the format string:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(} \PYG{k+kt}{int} \PYG{n}{n} \PYG{p}{=} \PYG{l+m}{1}\PYG{p}{;} \PYG{n}{n} \PYG{p}{\textless{}}\PYG{p}{=} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{p}{;} \PYG{n}{n}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0,2\PYGZcb{} \PYGZob{}1,3\PYGZcb{} \PYGZob{}2,4\PYGZcb{} \PYGZob{}3,6:F4\PYGZcb{}"}\PYG{p}{,}
                       \PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{*}\PYG{n}{n}\PYG{p}{,} \PYG{n}{n}\PYG{p}{*}\PYG{n}{n}\PYG{p}{*}\PYG{n}{n}\PYG{p}{,} \PYG{n}{Math}\PYG{p}{.}\PYG{n}{Sqrt}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

and we generate the neater:

\begin{Verbatim}[commandchars=\\\{\}]
 \PYG{l+m}{1}   \PYG{l+m}{1}    \PYG{l+m}{1} \PYG{l+m}{1.0000}
 \PYG{l+m}{2}   \PYG{l+m}{4}    \PYG{l+m}{8} \PYG{l+m}{1.4142}
 \PYG{l+m}{3}   \PYG{l+m}{9}   \PYG{l+m}{2}\PYG{l+m}{7} \PYG{l+m}{1.7321}
 \PYG{l+m}{4}  \PYG{l+m}{1}\PYG{l+m}{6}   \PYG{l+m}{6}\PYG{l+m}{4} \PYG{l+m}{2.0000}
 \PYG{l+m}{5}  \PYG{l+m}{2}\PYG{l+m}{5}  \PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{5} \PYG{l+m}{2.2361}
 \PYG{l+m}{6}  \PYG{l+m}{3}\PYG{l+m}{6}  \PYG{l+m}{2}\PYG{l+m}{1}\PYG{l+m}{6} \PYG{l+m}{2.4495}
 \PYG{l+m}{7}  \PYG{l+m}{4}\PYG{l+m}{9}  \PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{3} \PYG{l+m}{2.6458}
 \PYG{l+m}{8}  \PYG{l+m}{6}\PYG{l+m}{4}  \PYG{l+m}{5}\PYG{l+m}{1}\PYG{l+m}{2} \PYG{l+m}{2.8284}
 \PYG{l+m}{9}  \PYG{l+m}{8}\PYG{l+m}{1}  \PYG{l+m}{7}\PYG{l+m}{2}\PYG{l+m}{9} \PYG{l+m}{3.0000}
\PYG{l+m}{1}\PYG{l+m}{0} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0} \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{l+m}{0} \PYG{l+m}{3.1623}
\end{Verbatim}

We are using two new formatting forms:
\begin{quote}

\begin{DUlineblock}{0em}
\item[] \code{\{}index{}`{}`,{}`{}`fieldWidth{}`{}`\}{}`{}`  and
\item[] \code{\{}index{}`{}`,{}`{}`fieldWidth{}`{}`\code{:}F{}`{}`\#{}`{}`\}{}`{}`
\end{DUlineblock}
\end{quote}

where index, fieldWidth, and \# are replaces by specific integers.
The new part with the comma (not colon) and fieldWidth, sets the \emph{minimum}
number of columns used for the substituted string, padding with blanks as needed.

If the string to be inserted is wider than the fieldWidth, then the whole string is
inserted, ignoring the fieldWidth.  Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{string} \PYG{n}{s} \PYG{p}{=} \PYG{l+s}{"stuff"}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"123456789"}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0, 9\PYGZcb{}\PYGZbs{}n\PYGZob{}0, 7\PYGZcb{}\PYGZbs{}n\PYGZob{}0, 5\PYGZcb{}\PYGZbs{}n\PYGZob{}0, 3\PYGZcb{}"}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

generates:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{5}\PYG{l+m}{6}\PYG{l+m}{7}\PYG{l+m}{8}\PYG{l+m}{9}
    \PYG{n}{stuff}
  \PYG{n}{stuff}
\PYG{n}{stuff}
\PYG{n}{stuff}
\end{Verbatim}

filling 9, 7, and then 5 columns, by padding with 4, 2, and 0 blanks.  The
last line sticks out past the proposed 3-column fieldWidth.

One more thing to add to our power table is a heading.  We might want:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{n}   \PYG{n}{square}    \PYG{n}{cube}    \PYG{n}{root}
\end{Verbatim}

To make the data line up with the heading titles,
we can expand the columns, with code in example
\code{PowerTable.cs}:

generating:

\begin{Verbatim}[commandchars=\\\{\}]
 \PYG{n}{n}  \PYG{n}{square}    \PYG{n}{cube}    \PYG{n}{root}
 \PYG{l+m}{1}       \PYG{l+m}{1}       \PYG{l+m}{1}  \PYG{l+m}{1.0000}
 \PYG{l+m}{2}       \PYG{l+m}{4}       \PYG{l+m}{8}  \PYG{l+m}{1.4142}
 \PYG{l+m}{3}       \PYG{l+m}{9}      \PYG{l+m}{2}\PYG{l+m}{7}  \PYG{l+m}{1.7321}
 \PYG{l+m}{4}      \PYG{l+m}{1}\PYG{l+m}{6}      \PYG{l+m}{6}\PYG{l+m}{4}  \PYG{l+m}{2.0000}
 \PYG{l+m}{5}      \PYG{l+m}{2}\PYG{l+m}{5}     \PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{5}  \PYG{l+m}{2.2361}
 \PYG{l+m}{6}      \PYG{l+m}{3}\PYG{l+m}{6}     \PYG{l+m}{2}\PYG{l+m}{1}\PYG{l+m}{6}  \PYG{l+m}{2.4495}
 \PYG{l+m}{7}      \PYG{l+m}{4}\PYG{l+m}{9}     \PYG{l+m}{3}\PYG{l+m}{4}\PYG{l+m}{3}  \PYG{l+m}{2.6458}
 \PYG{l+m}{8}      \PYG{l+m}{6}\PYG{l+m}{4}     \PYG{l+m}{5}\PYG{l+m}{1}\PYG{l+m}{2}  \PYG{l+m}{2.8284}
 \PYG{l+m}{9}      \PYG{l+m}{8}\PYG{l+m}{1}     \PYG{l+m}{7}\PYG{l+m}{2}\PYG{l+m}{9}  \PYG{l+m}{3.0000}
\PYG{l+m}{1}\PYG{l+m}{0}     \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}    \PYG{l+m}{1}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{l+m}{0}  \PYG{l+m}{3.1623}
\end{Verbatim}

Note how we make sure the columns are consistent in the heading and further rows:
We used a format string for the headings with the same field widths as
in the body of the table. A separate variation: We also reduced the length
of the format string by putting all the substitution expressions in braces
right beside each other, and generate the space between columns with a
larger field width.

\index{ASCII!example}\index{example!ASCII}\phantomsection\label{forexamples:ascii}\paragraph{ASCII Codes}

Here is a reverse lookup from the
{\hyperref[foreachexamples:codeofstringchar]{\emph{Numeric Code of String Characters}}}:
Find the characters for a list of numeric codes. Just as we can cast a
\code{char} to an \code{int}, we can cast an \code{int} 0-127 to a \code{char}.

The Unicode used
by C\# is an extension of the ASCII codes corresponding to the
characters on a US keyboard.  The codes were originally
used to drive printers,
and the first 32 codes are non-printable instructions to the printer.
Characters 32 - 126 yield the 95 characters on a standard US keyboard.

A loop to print each code followed by a space and the corresponding
printable character
would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{3}\PYG{l+m}{2}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\textless{}} \PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{7}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0,3\PYGZcb{} \PYGZob{}1\PYGZcb{}"}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{p}{(}\PYG{k+kt}{char}\PYG{p}{)}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

To make all the character line up we added a field width 3 for the code column.

If you run  this in csharp,
the first line printed does not appear to have a character:  That is the
blank character.  All the other characters are visible.

Let us make a more concise table, putting 8 entries per line.
We can print successive parts use \code{Write} not \code{WriteLine},
but we still need to advance to the next line after every 8th
entry, for 39, 47, 55, ....
Since they are 8 apart, their remainder when divided by 8 is always
the same:
\begin{quote}

7 = 39 \% 8 = 47 \% 8 = 55 \% 8 = ....
\end{quote}

We can add a newline after each of these is printed.  This requires a test:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{3}\PYG{l+m}{2}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\textless{}} \PYG{l+m}{1}\PYG{l+m}{2}\PYG{l+m}{7}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}0, 3\PYGZcb{} \PYGZob{}1\PYGZcb{}  "}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{p}{(}\PYG{k+kt}{char}\PYG{p}{)}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{p}{\PYGZpc{}} \PYG{l+m}{8} \PYG{p}{=}\PYG{p}{=} \PYG{l+m}{7}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Paste that whole code at once into csharp to see the result.

The next csharp\textgreater{} prompt appears right after \code{126 \textasciitilde{}}.
There is no eighth entry on the last line, and hence no advance to the
next line.  A program printing this table should include an extra
\code{Console.WriteLine()} after the loop.

\index{table!nested loops}\index{nested loops!table}\index{format!table}\index{table!format}\index{example!ModMultTable.cs}\index{ModMultTable.cs!example}\paragraph{Modular Multiplication Table}

We have introduced the remainder operator \code{\%} and mentioned have the corresponding
mathematical term is ``mod''.  We can extend that to the idea of mudular arithmetic
systems.  For example, if we only look at remainders mod 7, we can just consider
numbers 0, 1, 2, 3, 4, 5, and 6.  We can do multiplication and addition and take
remainders mod 7 to get answers in the same range.  For example 3 * 5 mod 7
is \code{(3 * 5) \% 7} in C\#, which is 1.  As we look more at this system, we will
observe and explain more properties.

The next example is to make a table of multiplication, mod 7, and later generalize.

Tables generally have row and column labels.  We can aim for something like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{*} \PYG{p}{\textbar{}} \PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{2} \PYG{l+m}{3} \PYG{l+m}{4} \PYG{l+m}{5} \PYG{l+m}{6}
\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}\PYG{p}{-}
\PYG{l+m}{0} \PYG{p}{\textbar{}} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0}
\PYG{l+m}{1} \PYG{p}{\textbar{}} \PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{2} \PYG{l+m}{3} \PYG{l+m}{4} \PYG{l+m}{5} \PYG{l+m}{6}
\PYG{l+m}{2} \PYG{p}{\textbar{}} \PYG{l+m}{0} \PYG{l+m}{2} \PYG{l+m}{4} \PYG{l+m}{6} \PYG{l+m}{1} \PYG{l+m}{3} \PYG{l+m}{5}
\PYG{l+m}{3} \PYG{p}{\textbar{}} \PYG{l+m}{0} \PYG{l+m}{3} \PYG{l+m}{6} \PYG{l+m}{2} \PYG{l+m}{5} \PYG{l+m}{1} \PYG{l+m}{4}
\PYG{l+m}{4} \PYG{p}{\textbar{}} \PYG{l+m}{0} \PYG{l+m}{4} \PYG{l+m}{1} \PYG{l+m}{5} \PYG{l+m}{2} \PYG{l+m}{6} \PYG{l+m}{3}
\PYG{l+m}{5} \PYG{p}{\textbar{}} \PYG{l+m}{0} \PYG{l+m}{5} \PYG{l+m}{3} \PYG{l+m}{1} \PYG{l+m}{6} \PYG{l+m}{4} \PYG{l+m}{2}
\PYG{l+m}{6} \PYG{p}{\textbar{}} \PYG{l+m}{0} \PYG{l+m}{6} \PYG{l+m}{5} \PYG{l+m}{4} \PYG{l+m}{3} \PYG{l+m}{2} \PYG{l+m}{1}
\end{Verbatim}

The border labels make the table much more readable, but let us start simpler,
with just the modular multiplications:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0}
\PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{2} \PYG{l+m}{3} \PYG{l+m}{4} \PYG{l+m}{5} \PYG{l+m}{6}
\PYG{l+m}{0} \PYG{l+m}{2} \PYG{l+m}{4} \PYG{l+m}{6} \PYG{l+m}{1} \PYG{l+m}{3} \PYG{l+m}{5}
\PYG{l+m}{0} \PYG{l+m}{3} \PYG{l+m}{6} \PYG{l+m}{2} \PYG{l+m}{5} \PYG{l+m}{1} \PYG{l+m}{4}
\PYG{l+m}{0} \PYG{l+m}{4} \PYG{l+m}{1} \PYG{l+m}{5} \PYG{l+m}{2} \PYG{l+m}{6} \PYG{l+m}{3}
\PYG{l+m}{0} \PYG{l+m}{5} \PYG{l+m}{3} \PYG{l+m}{1} \PYG{l+m}{6} \PYG{l+m}{4} \PYG{l+m}{2}
\PYG{l+m}{0} \PYG{l+m}{6} \PYG{l+m}{5} \PYG{l+m}{4} \PYG{l+m}{3} \PYG{l+m}{2} \PYG{l+m}{1}
\end{Verbatim}

This is more complicated in some respects than our previous table, so start slow,
with some pseudocode.  We need a row for each number 0-6, and so a \code{for} loop
suggests itself:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;} \PYG{n}{r} \PYG{p}{\textless{}} \PYG{l+m}{7}\PYG{p}{;} \PYG{n}{r}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{print} \PYG{n}{row}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

Each individual row also involves a repeated pattern:
calculate for the next number.  We can name the second number c for column.  The
next revision replaces ``print row'' by a loop:  a \emph{nested} loop, inside the loop for
separate rows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;} \PYG{n}{r} \PYG{p}{\textless{}} \PYG{l+m}{7}\PYG{p}{;} \PYG{n}{r}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;} \PYG{n}{c} \PYG{p}{\textless{}} \PYG{l+m}{7}\PYG{p}{;} \PYG{n}{c}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
       \PYG{n}{print} \PYG{n}{modular} \PYG{n}{multiple} \PYG{n}{on} \PYG{n}{same} \PYG{n}{line}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

and the modular multiplication is just regular multiplication followed by
taking the remainder mod 7, so you might come up with the C\# code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;} \PYG{n}{r} \PYG{p}{\textless{}} \PYG{l+m}{7}\PYG{p}{;} \PYG{n}{r}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;} \PYG{n}{c} \PYG{p}{\textless{}} \PYG{l+m}{7}\PYG{p}{;} \PYG{n}{c}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
       \PYG{k+kt}{int} \PYG{n}{modProd} \PYG{p}{=} \PYG{p}{(}\PYG{n}{r}\PYG{p}{*}\PYG{n}{c}\PYG{p}{)} \PYG{p}{\PYGZpc{}} \PYG{l+m}{7}\PYG{p}{;}
       \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{modProd} \PYG{p}{+} \PYG{l+s}{" "}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

You can test this in csharp, and see it is not quite right!  chopped-off output starts:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{2} \PYG{l+m}{3} \PYG{l+m}{4} \PYG{l+m}{5} \PYG{l+m}{6} \PYG{l+m}{0} \PYG{l+m}{2} \PYG{l+m}{4} \PYG{l+m}{6} \PYG{l+m}{1} \PYG{l+m}{3} \PYG{l+m}{5} \PYG{l+m}{0} \PYG{l+m}{3} \PYG{l+m}{6} \PYG{l+m}{2} \PYG{l+m}{5} \PYG{l+m}{1} \PYG{l+m}{4} \PYG{l+m}{0.}\PYG{p}{.}\PYG{p}{.}
\end{Verbatim}

Though we want each entry in a row on the same line, we need to go down to the
next line at the end of each line!  Where do we put in the newline in the code?
A line is all the modular products by r, \emph{followed} by \emph{one} newline.
All the modular products for a row are printed in the inner \code{for} loop.  We want to
advance \emph{after} that, so the newline must be inserted \emph{outside the inner loop}.
On the other hand we do want it done for \emph{each} row, so it must be
\emph{inside the outer loop}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;} \PYG{n}{r} \PYG{p}{\textless{}} \PYG{l+m}{7}\PYG{p}{;} \PYG{n}{r}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;} \PYG{n}{c} \PYG{p}{\textless{}} \PYG{l+m}{7}\PYG{p}{;} \PYG{n}{c}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
       \PYG{k+kt}{int} \PYG{n}{modProd} \PYG{p}{=} \PYG{p}{(}\PYG{n}{r}\PYG{p}{*}\PYG{n}{c}\PYG{p}{)} \PYG{p}{\PYGZpc{}} \PYG{l+m}{7}\PYG{p}{;}
       \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{modProd} \PYG{p}{+} \PYG{l+s}{" "}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

You can copy and test that code in csharp, and it works!

It is important to be able to play computer on nested loops and follow execution,
statement by statement.  Look more closely at the code above,
noting the added line numbers.  General sequencing orders apply:
The basic pattern is sequential:  \emph{Complete} one statement before going on to the next.
\emph{Inside} the execution of a looping statement, there are extra rules, for testing and
going through the whole loop body sequentially.
Most new students can get successfully to line 4:
\begin{quote}

\begin{tabular}{|p{0.190\linewidth}|p{0.190\linewidth}|p{0.190\linewidth}|p{0.190\linewidth}|p{0.190\linewidth}|}
\hline
\textbf{
line
} & \textbf{
r
} & \textbf{
c
} & \textbf{
modProd
} & \textbf{
comment
}\\\hline

1
 & 
0
 & \begin{itemize}
\item {} 
\end{itemize}
 & \begin{itemize}
\item {} 
\end{itemize}
 & 
initialize outer loop
\\\hline

2
 & 
0
 & 
0
 & \begin{itemize}
\item {} 
\end{itemize}
 & 
initialize inner loop
\\\hline

3
 & 
0
 & 
0
 & 
0
 & \\\hline

4
 & 
0
 & 
0
 & 
0
 & 
Write 0
\\\hline
\end{tabular}

\end{quote}

After reaching the bottom of the loop, where do you go?
You finsh the innermost statement that you are in.
You are in the inner loop, so the next line is the \emph{inner} loop heading
where you increment c and continue with the loop since 1 \textless{} 7.  This
inner loop continues until you reach the bottom of the inner loop,
line 4, with c = 6, and return to the heading, line 2, and the test fails,
finishing the inner row loop:
\begin{quote}

\begin{tabular}{|p{0.190\linewidth}|p{0.190\linewidth}|p{0.190\linewidth}|p{0.190\linewidth}|p{0.190\linewidth}|}
\hline
\textbf{
line
} & \textbf{
r
} & \textbf{
c
} & \textbf{
modProd
} & \textbf{
comment
}\\\hline

1
 & 
0
 & \begin{itemize}
\item {} 
\end{itemize}
 & \begin{itemize}
\item {} 
\end{itemize}
 & 
initialize outer loop
\\\hline

2
 & 
0
 & 
0
 & \begin{itemize}
\item {} 
\end{itemize}
 & 
0 \textless{} 7, enter loop body
\\\hline

3
 & 
0
 & 
0
 & 
0
 & 
(0*0)\%7
\\\hline

4
 & 
0
 & 
0
 & 
0
 & 
Write 0
\\\hline

2
 & 
0
 & 
1
 & \begin{itemize}
\item {} 
\end{itemize}
 & 
c=0+1=1,  1 \textless{} 7: true
\\\hline

3
 & 
0
 & 
1
 & 
0
 & 
(0*1)\%7
\\\hline

4
 & 
0
 & 
1
 & 
0
 & 
Write 0
\\\hline

2
 & 
0
 & 
2
 & \begin{itemize}
\item {} 
\end{itemize}
 & 
c=1+1=2,  2 \textless{} 7: true
\\\hline

...
 &  &  &  & 
... through c = 6
\\\hline

4
 & 
0
 & 
6
 & 
0
 & 
Write 0
\\\hline

2
 & 
0
 & 
7
 & \begin{itemize}
\item {} 
\end{itemize}
 & 
c=+1=7,  7 \textless{} 7: false
\\\hline
\end{tabular}

\end{quote}

At this point the inner loop statement, lines 2-4, has completed,
and you continue.  You go on to the next statement in the
same sequential chuck as the inner loop statement in lines 2-4:
That chunk is the the outer loop body, lines 2-6.
The next statement is line 6, advancing printing to the next line.
That is the last statement of the outer loop, so you
return to the heading of the outer loop and modify its loop
variable r.  The two lines just described are:
\begin{quote}

\begin{tabular}{|p{0.190\linewidth}|p{0.190\linewidth}|p{0.190\linewidth}|p{0.190\linewidth}|p{0.190\linewidth}|}
\hline
\textbf{
line
} & \textbf{
r
} & \textbf{
c
} & \textbf{
modProd
} & \textbf{
comment
}\\\hline

6
 & 
0
 & \begin{itemize}
\item {} 
\end{itemize}
 & \begin{itemize}
\item {} 
\end{itemize}
 & 
print a newline
\\\hline

1
 & 
1
 & \begin{itemize}
\item {} 
\end{itemize}
 & \begin{itemize}
\item {} 
\end{itemize}
 & 
0+1=1, 1 \textless{} 7 enter outer loop
\\\hline
\end{tabular}

\end{quote}

Then you go all the way through the inner loop again,
for all columns, with c going from 0 through 6, and exit at c=7,
finish the body of the outer loop by advancing to a new print line,
and return to the outer loop heading, setting r = 2..., until
all rows are completed.

The common error here is to forget what loop is the innermost one
that you are working on, and exit that loop before is is totally finished.
It finishes when the test of the condition controling the loop becomes false.

Look back one more time and make sure the code for this \emph{simpler} table makes
sense before we continue to the one with labels....

The fancier table has a couple of extra rows at the top.  These two rows
are unlike the remaining rows in the body of the table, so they need special code.

If we go back to our pseudocode we could add to it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{print} \PYG{n}{heading} \PYG{n}{row}
\PYG{n}{print} \PYG{n}{dash}\PYG{p}{-}\PYG{n}{row}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{r} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;} \PYG{n}{r} \PYG{p}{\textless{}} \PYG{l+m}{7}\PYG{p}{;} \PYG{n}{r}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{print} \PYG{n}{body} \PYG{n}{row}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

First analyse the heading row:  Some parts are repetitive and
some are not: Print \code{"* \textbar{}"} once, and then there is a repetitive pattern printing
0 - 6, which we can do with a simpler loop than in the table body:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{l+s}{"* \textbar{} "}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(} \PYG{k+kt}{int} \PYG{n}{i} \PYG{p}{=} \PYG{l+m}{0}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\textless{}} \PYG{l+m}{7}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{Console}\PYG{p}{.}\PYG{n}{Write}\PYG{p}{(}\PYG{n}{i} \PYG{p}{+} \PYG{l+s}{" "}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Console}\PYG{p}{.}\PYG{n}{WriteLine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The dashed line can be generated using \code{StringRep} from
{\hyperref[forexamples:stringrepeatingexercise]{\emph{String Repeating Exercise}}}.  How many dashes?  For each of
seven columns, and in a row header, we need a digit and an space or
(7+1)*(1+1) characters, plus one for the `\textbar{}':  1 + (7+1)*(1+1).
Thinking ahead, we will leave that expression unsimplified.

We have done most of the work for the rows of the body of the table i the simpler
version.  We just
have a bit of printing for the initial row label before the column loop.  The row
label is r.  The whole code is in example \code{Mod7Table.cs} and below:

Besides the 0 row and 0 column in the mod 7 table,
note that each line contains a permutation of all the numbers 1-6.  That means it is
possible to define the \emph{inverse} of the multiplication operation, and mod 7 arithmetic
actually forms a mathematical \emph{field}.  A lot more math is useful in various places!
Modular arithmetic (with much larger moduli!) is extremely important in cryptography.
It protects all your online financial transactions....

The inverse operation to multiplication for prime moduli is
easy to work out by brute force, going through the row of products.
There needs to be a much more efficient
method for use in cryptography:  That method involves
an elaboration of \emph{GCD}.

Finally, let us generalize this table to mod n.  With n up to about 25,
it is reasonable to print.
Most of the changes are just replacing 7 by n.
There is a further complication
with column width, since the numbers can be more than one digit.  We can do
formatting with a field width.
Unfortunately in C\# the field width must be a \emph{literal}
integer embedded in the format string, but our number of digits in n is \emph{variable}.

Here is a good trick:  Construct the format string inside the program.
We can do that with \emph{another} format string.  To get the  format for a
number and an extra space
mod 7, we want format string ``\{0, 1\} '', but mod 11, we want ``\{0, 2\} ''.  We can
create a format string to substitute into the place where the 1 or 2 goes.
The 1 or 2 to substitute is the number of characters in n as a string,
given by \code{("" + n).Length}.

The second level format string has an
extra wrinkle, because we want explicit braces (for the main format string).
Recall the explicit braces are doubled.  Putting this all together, we can
create our main format string with:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{numberWidth} \PYG{p}{=} \PYG{p}{(}\PYG{l+s}{""} \PYG{p}{+} \PYG{n}{n}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Length}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{colFormat} \PYG{p}{=} \PYG{k+kt}{string}\PYG{p}{.}\PYG{n}{Format}\PYG{p}{(}\PYG{l+s}{"\PYGZob{}\PYGZob{}0, \PYGZob{}0\PYGZcb{}\PYGZcb{}\PYGZcb{} "}\PYG{p}{,} \PYG{n}{numberWidth}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The whole function code is below and in example \code{ModMultTable.cs}.

\begin{notice}{note}{Todo}

Do some of these examples backwards.
\end{notice}

\begin{notice}{note}{Todo}

Reversing a string...
\end{notice}

\begin{notice}{note}{Todo}

Palindrome
\end{notice}

\begin{notice}{note}{Todo}

ASCII art, triangles; see for loop lab.
\end{notice}

\begin{notice}{note}{Todo}

Repeat string N times.  part a, just printed, part b: return a string
\end{notice}

\begin{notice}{note}{Todo}

Make restructured text table with fixed rows, columns, and width empty content.
\end{notice}

\index{exercise!StringRepeating}\index{StringRepeating!exercise}

\subsection{String Repeating Exercise}
\label{forexamples:string-repeating-exercise}\label{forexamples:index-10}\label{forexamples:stringrepeatingexercise}\begin{enumerate}
\item {} 
Write a program StringRep.cs with a function PrintDup,
with heading:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/** Print n repetitions of s on one line (n \textgreater{}= 0). */}
\PYG{k}{static} \PYG{k}{void} \PYG{n+nf}{PrintDup}\PYG{p}{(}\PYG{n}{stirng} \PYG{n}{s}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)}
\end{Verbatim}

\item {} 
More versatile is to add and test a function \code{StringRep}:

This takes more thought and work that just printing repeatedly.
You need to accumulate the final string to return.

\end{enumerate}

\index{exercise!heads or tails}\index{heads or tails!exercise}\index{random!heads or tails}\index{heads or tails!random}

\subsection{Head or Tails Exercise}
\label{forexamples:head-or-tails-exercise}\label{forexamples:index-11}
Write a program \code{HeadsTails.cs}. It should include a function \code{Flip()},
that will randomly prints \code{Heads} or \code{Tails}.
Accomplish this by choosing 0 or 1 arbitrarily with a random
number generator.  Recall in {\hyperref[lab-number-game:lab-number-game]{\emph{Number Guessing Game Lab}}}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Random} \PYG{n}{r} \PYG{p}{=} \PYG{k}{new} \PYG{n}{Random}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Then, for \code{int}s \code{low} and \code{higher}, with \code{low \textless{} higher}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{n} \PYG{p}{=} \PYG{n}{r}\PYG{p}{.}\PYG{n}{Next}\PYG{p}{(}\PYG{n}{low}\PYG{p}{,} \PYG{n}{higher}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

returns a (pseudo) random \code{int}, satisfying \code{low \textless{}= n \textless{} higher}.
If you select \code{low} and \code{higher} so there are only two possible values
for n,
then you can choose to print \code{Heads} or \code{Tails} with an
\code{if}-\code{else} statement based on the result.

In your Main method have a \code{for} loop calling  \code{Flip()}
10 times to test it, so you generate a random sequence of
10 \code{Heads} and/or
\code{Tails}.


\chapter{Arrays}
\label{arrays:arrays}\label{arrays::doc}

\section{One Dimensional Arrays}
\label{onedim:one-dimensional-arrays}\label{onedim::doc}
\begin{notice}{note}{Todo}

one dimensional arrays
\end{notice}


\section{Two Dimensional Arrays}
\label{twodim::doc}\label{twodim:two-dimensional-arrays}
\begin{notice}{note}{Todo}

two dimensional arrays
\end{notice}


\chapter{Change Log}
\label{changelog::doc}\label{changelog:change-log}\begin{enumerate}
\item {} \begin{description}
\item[{Merge branch `master' of github.com:introcs-cs-luc-edu/introcs-lecture-notes}] \leavevmode\begin{itemize}
\item {} 
5397b6c

\item {} 
Andrew N. Harrington

\item {} 
10 hours ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{modified if parts, did todos for if pitfalls and compound conditions, simple while loops}] \leavevmode\begin{itemize}
\item {} 
fb471fe

\item {} 
Andrew N. Harrington

\item {} 
10 hours ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Merge branch `master' of github.com:introcs-cs-luc-edu/introcs-lecture-notes}] \leavevmode\begin{itemize}
\item {} 
eaa77a6

\item {} 
George K. Thiruvathukal

\item {} 
10 hours ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{homework 2 preview}] \leavevmode\begin{itemize}
\item {} 
e5347a5

\item {} 
George K. Thiruvathukal

\item {} 
11 hours ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{typo in string in Suitcse.cs}] \leavevmode\begin{itemize}
\item {} 
38a46a7

\item {} 
Andrew N. Harrington

\item {} 
19 hours ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{typos in string section, brace format convention fix in if, todo example sections added to index, todo syntax corrected}] \leavevmode\begin{itemize}
\item {} 
deb5a9c

\item {} 
Andrew N. Harrington

\item {} 
35 hours ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added GKT's lecture summaries/schedule as a separate document}] \leavevmode\begin{itemize}
\item {} 
35d79a2

\item {} 
George K. Thiruvathukal

\item {} 
2 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{updates to GKT offering; breaking out into separate schedule page}] \leavevmode\begin{itemize}
\item {} 
dca6e3f

\item {} 
George K. Thiruvathukal

\item {} 
2 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added a snippets example based on my GCD F\# example developed this winter break}] \leavevmode\begin{itemize}
\item {} 
ba07d88

\item {} 
George K. Thiruvathukal

\item {} 
3 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added some examples files; Andy to insert into our TOC}] \leavevmode\begin{itemize}
\item {} 
6f54b9f

\item {} 
George K. Thiruvathukal

\item {} 
3 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added some examples files; Andy to insert into our TOC}] \leavevmode\begin{itemize}
\item {} 
e255689

\item {} 
George K. Thiruvathukal

\item {} 
3 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{lots of files for if, also replace stub by todo for later parts}] \leavevmode\begin{itemize}
\item {} 
308b093

\item {} 
Andrew N. Harrington

\item {} 
4 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{collapsible navigation, schedule in gkt's syllabus, and some cross-referencing support}] \leavevmode\begin{itemize}
\item {} 
bd49c17

\item {} 
George K. Thiruvathukal

\item {} 
8 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{oops, it pays to save}] \leavevmode\begin{itemize}
\item {} 
609b493

\item {} 
Andrew N. Harrington

\item {} 
8 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added abort to assignment if weight do not add to 100}] \leavevmode\begin{itemize}
\item {} 
e9eeba1

\item {} 
Andrew N. Harrington

\item {} 
8 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added string lab and inserted ref links to us in it.}] \leavevmode\begin{itemize}
\item {} 
081ebf8

\item {} 
Andrew N. Harrington

\item {} 
8 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added edit hw - not committed before, slight edit of lab eliminating IF, started on conditions - likely changed later}] \leavevmode\begin{itemize}
\item {} 
5a4c5c6

\item {} 
Andrew N. Harrington

\item {} 
8 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Merge branch `master' of github.com:introcs-cs-luc-edu/introcs-lecture-notes}] \leavevmode\begin{itemize}
\item {} 
819479f

\item {} 
Andrew N. Harrington

\item {} 
9 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{detailed draft of first homework}] \leavevmode\begin{itemize}
\item {} 
056231e

\item {} 
George

\item {} 
9 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{it helps to save: todo removed from problemsolving with strings}] \leavevmode\begin{itemize}
\item {} 
5b9d6b3

\item {} 
Andrew N. Harrington

\item {} 
11 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added Miles first example and sugest at end of funcreturn to improve it.}] \leavevmode\begin{itemize}
\item {} 
9cb6bda

\item {} 
Andrew N. Harrington

\item {} 
11 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{oops before added StringManip.cs (ignore/delete), not StringManipStub.cs as intended.}] \leavevmode\begin{itemize}
\item {} 
93b9392

\item {} 
Andrew N. Harrington

\item {} 
11 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{typos}] \leavevmode\begin{itemize}
\item {} 
91905f9

\item {} 
Andrew N. Harrington

\item {} 
11 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{wrote notes part of problem solving with strings - assume draw the omitted parts out in class.  Also the rst file has parts labeled `.. forclass': look there if you have any question what I was expecting to happen.}] \leavevmode\begin{itemize}
\item {} 
0791426

\item {} 
Andrew N. Harrington

\item {} 
11 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{String intro sections, reorganized from todos; still need replace example and lab}] \leavevmode\begin{itemize}
\item {} 
c1c8e1b

\item {} 
Andrew N. Harrington

\item {} 
11 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Merge branch `master' of github.com:introcs-cs-luc-edu/introcs-lecture-notes}] \leavevmode\begin{itemize}
\item {} 
7f144c7

\item {} 
George K. Thiruvathukal

\item {} 
13 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added remainders lab with notes on java/csharp mode}] \leavevmode\begin{itemize}
\item {} 
b99c43b

\item {} 
George K. Thiruvathukal

\item {} 
13 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Did todo for learning-to-problem-solve}] \leavevmode\begin{itemize}
\item {} 
18777e0

\item {} 
Andrew N. Harrington

\item {} 
13 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{todo list now at end of main index}] \leavevmode\begin{itemize}
\item {} 
a312443

\item {} 
Andrew N. Harrington

\item {} 
13 days ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{todo:: needs a blank line under it!}] \leavevmode\begin{itemize}
\item {} 
38b9d5f

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{stub for comments on organizing learning, section in data}] \leavevmode\begin{itemize}
\item {} 
ce44011

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{for todo fixed conf.py param todo\_include\_todos}] \leavevmode\begin{itemize}
\item {} 
d41d9c8

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{:: after todo in all new stubs}] \leavevmode\begin{itemize}
\item {} 
215728a

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{typos in format with \{\}}] \leavevmode\begin{itemize}
\item {} 
e25b81f

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added lots of stubs - not see todo? new writeline-substitutions}] \leavevmode\begin{itemize}
\item {} 
38359e5

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{removed copied text found by Bob in end of multfunc}] \leavevmode\begin{itemize}
\item {} 
fd279cc

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{fixed small problem with indentation in Linux addition to monotools.rst}] \leavevmode\begin{itemize}
\item {} 
608f1be

\item {} 
George K. Thiruvathukal

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{fixed small typo in lab}] \leavevmode\begin{itemize}
\item {} 
33904e0

\item {} 
George K. Thiruvathukal

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{various fixes to syllabus, mono tools, and lab}] \leavevmode\begin{itemize}
\item {} 
ab7ebac

\item {} 
George K. Thiruvathukal

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Hello examples, including one that uses the NAnt build tool}] \leavevmode\begin{itemize}
\item {} 
ef4f2f6

\item {} 
George K. Thiruvathukal

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{minor edits to tools}] \leavevmode\begin{itemize}
\item {} 
b10401a

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{edited tools, temporary explicit source code}] \leavevmode\begin{itemize}
\item {} 
0425f42

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Merge branch `master' of github.com:introcs-cs-luc-edu/introcs-lecture-notes}] \leavevmode\begin{itemize}
\item {} 
fbe281e

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{fixed authors, edited tools}] \leavevmode\begin{itemize}
\item {} 
a6467f4

\item {} 
Andrew N. Harrington

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{offerings and monotools updates}] \leavevmode\begin{itemize}
\item {} 
485ef89

\item {} 
George K. Thiruvathukal

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{added syllabi and first lab exercise}] \leavevmode\begin{itemize}
\item {} 
b4ef7ea

\item {} 
George K. Thiruvathukal

\item {} 
2 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{fixed typo in addition2.cs}] \leavevmode\begin{itemize}
\item {} 
524d804

\item {} 
Andrew N. Harrington

\item {} 
3 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{posting staged commit for monotools notes and the python script fixes}] \leavevmode\begin{itemize}
\item {} 
57dd305

\item {} 
George K. Thiruvathukal

\item {} 
3 weeks ago

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{initial import of Andy's and George's latest text}] \leavevmode\begin{itemize}
\item {} 
5a24df9

\item {} 
George K. Thiruvathukal

\item {} 
3 weeks ago

\end{itemize}

\end{description}

\end{enumerate}


\chapter{Index and search}
\label{index:index-and-search}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{search}

\end{itemize}


\chapter{TODO's}
\label{index:todo-s}
\begin{notice}{note}{Todo}

George:
? tie into later work; good CS example?
\end{notice}

(The {\hyperref[assignment-functions:index-1]{\emph{original entry}}} is located in  /Users/anh/www/170/noteshg/introcs-csharp/rst/assignment-functions.rst, line 12.)

\begin{notice}{note}{Todo}

Andy new
\end{notice}

(The {\hyperref[notusereturn:index-1]{\emph{original entry}}} is located in  /Users/anh/www/170/noteshg/introcs-csharp/rst/notusereturn.rst, line 13.)

\begin{notice}{note}{Todo}

one dimensional arrays
\end{notice}

(The {\hyperref[onedim:index-0]{\emph{original entry}}} is located in  /Users/anh/www/170/noteshg/introcs-csharp/rst/onedim.rst, line 8.)

\begin{notice}{note}{Todo}

two dimensional arrays
\end{notice}

(The {\hyperref[twodim:index-0]{\emph{original entry}}} is located in  /Users/anh/www/170/noteshg/introcs-csharp/rst/twodim.rst, line 8.)

\begin{notice}{note}{Todo}

``bisection method''
\end{notice}

(The {\hyperref[whileexamples:index-0]{\emph{original entry}}} is located in  /Users/anh/www/170/noteshg/introcs-csharp/rst/whileexamples.rst, line 9.)

\begin{notice}{note}{Todo}

Do some of these examples backwards.
\end{notice}

(The {\hyperref[forexamples:index-4]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/rst/forexamples.rst, line 491.)

\begin{notice}{note}{Todo}

Reversing a string...
\end{notice}

(The {\hyperref[forexamples:index-5]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/rst/forexamples.rst, line 495.)

\begin{notice}{note}{Todo}

Palindrome
\end{notice}

(The {\hyperref[forexamples:index-6]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/rst/forexamples.rst, line 499.)

\begin{notice}{note}{Todo}

ASCII art, triangles; see for loop lab.
\end{notice}

(The {\hyperref[forexamples:index-7]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/rst/forexamples.rst, line 503.)

\begin{notice}{note}{Todo}

Repeat string N times.  part a, just printed, part b: return a string
\end{notice}

(The {\hyperref[forexamples:index-8]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/rst/forexamples.rst, line 506.)

\begin{notice}{note}{Todo}

Make restructured text table with fixed rows, columns, and width empty content.
\end{notice}

(The {\hyperref[forexamples:index-9]{\emph{original entry}}} is located in  /Users/anh/www/170/notes/rst/forexamples.rst, line 509.)

\begin{thebibliography}{UPennCSharp}
\bibitem[CamelCase]{CamelCase}{\phantomsection\label{homework-gradecalculation2:camelcase} 
\href{http://en.wikipedia.org/wiki/CamelCase}{http://en.wikipedia.org/wiki/CamelCase}
}
\bibitem[UPennCSharp]{UPennCSharp}{\phantomsection\label{homework-gradecalculation2:upenncsharp} 
\href{http://www.cis.upenn.edu/~cis193/csstyle.html}{http://www.cis.upenn.edu/\textasciitilde{}cis193/csstyle.html}
}
\end{thebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
