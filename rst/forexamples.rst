Examples With ``for`` Statements
==================================

Thus far all of our ``for`` loops have used a sequence of successive integers.
Suppose you want to print the first ``n`` multiples of ``k``, 
like the first 5 multiples
of 3:  3, 6, 9, 12, 15.  This could be handled by generating
a sequence ``i`` = 1 through ``n``, and multiply each ``i`` by ``k``::

    for (int i = 1; i <= n; i++) {
       Console.WriteLine(i*k);
    }
    
Another approach is to note that the numbers you want to print advance
in a regular fashion, too, but with an increment 3 in the example above,
or k in general::

    for (int i = k; i <= n*k; i = i+k) {
       Console.WriteLine(i);
    }

The ::

   i = i + k;
   
is a common pattern, less common than incrementing by one, 
but still very common.  C# and many other languages allow a shorter version::

   i += k;
   
This means to increment the variable i by k.  Be careful, the ``+=`` must be in
that order, with no space between.  Unfortunately ::

  i =+k;
  
is also legal, and just assigns the value of k to i.

.. index::
   double operator; +=
   double operator; -=
   double operator; *=
   double operator; /=
   double operator; %=

Most C# binary operations have a similar variation.  For instance
if *op* is ``+``, ``-``, ``*``, ``/`` or ``%``,

    **variable** *op*\ = *expression*
    
means the same as

    **variable** = **variable** op *expression*
    
For example ::

    x *= 5;
    
is the same as  ::

    x = x * 5;
    
.. index::
   double: format; field width
   double: format; table
   double: example; PowerTable.cs

.. rubric::  Tables

Reports commonly include tables, often with successive lines generated by 
a consistent formula.  As a simple first 
table can show the square, cube, and square root of numbers 1 through 10.  
The Math class has a function Sqrt, so we take the square root with Math.Sqrt
function.  The formula is consistent, so we can loop easily::

   for ( int n = 1; n <= 10; n++) {
	   Console.WriteLine("{0} {1} {2} {3}", n, n*n, n*n*n, Math.Sqrt(n));
   }

The numbers will be there, but it is not pretty::

	1 1 1 1
	2 4 8 1.4142135623731
	3 9 27 1.73205080756888
	4 16 64 2
	5 25 125 2.23606797749979
	6 36 216 2.44948974278318
	7 49 343 2.64575131106459
	8 64 512 2.82842712474619
	9 81 729 3
	10 100 1000 3.16227766016838


First we might not need all those digits in the square root approximations.
We can replace ``{3}`` by ``{3:F4}`` to just show 4 decimal places.

There are not nice columns lining up.  We can adjust the spacing to make nice
columns by using a further formatting option.  The longest entries are all
in the last row, where they take up, 2, 3, 4, and 6 columns (for 3.1623).
Change the format string::

   for ( int n = 1; n <= 10; n++) {
	   Console.WriteLine("{0,2} {1,3} {2,4} {3,6:F4}", 
						  n, n*n, n*n*n, Math.Sqrt(n));
   }

and we generate the neater::

	 1   1    1 1.0000
	 2   4    8 1.4142
	 3   9   27 1.7321
	 4  16   64 2.0000
	 5  25  125 2.2361
	 6  36  216 2.4495
	 7  49  343 2.6458
	 8  64  512 2.8284
	 9  81  729 3.0000
	10 100 1000 3.1623

We are using two new formatting forms:

   | ``{``\ index``,``\ fieldWidth``}``  and 
   | ``{``\ index``,``\ fieldWidth``\ ``:``\F``\ #``}``   

where index, fieldWidth, and # are replaces by specific integers.
The new part with the comma (not colon) and fieldWidth, sets the *minimum*
number of columns used for the substituted string, padding with blanks as needed.

If the string to be inserted is wider than the fieldWidth, then the whole string is
inserted, ignoring the fieldWidth.  Example::

    string s = "stuff";
    Console.WriteLine("123456789");
    Console.WriteLine("{0, 9}\n{0, 7}\n{0, 5}\n{0, 3}", s);
    
generates::

	123456789
		stuff
	  stuff
	stuff
	stuff

filling 9, 7, and then 5 columns, by padding with 4, 2, and 0 blanks.  The
last line sticks out past the proposed 3-column fieldWidth.

One more thing to add to our power table is a heading.  We might want::

    n   square    cube    root
    
To make the data line up with the heading titles,
we can expand the columns, with code in example
``PowerTable.cs``:

.. literalinclude:: ../examples/PowerTable.cs
   :start-after: chunk
   :end-before: chunk

generating::

	 n  square    cube    root
	 1       1       1  1.0000
	 2       4       8  1.4142
	 3       9      27  1.7321
	 4      16      64  2.0000
	 5      25     125  2.2361
	 6      36     216  2.4495
	 7      49     343  2.6458
	 8      64     512  2.8284
	 9      81     729  3.0000
	10     100    1000  3.1623

Note how we make sure the columns are consistent in the heading and further rows:  
We used a format string for the headings with the same field widths as
in the body of the table. A separate variation: We also reduced the length
of the format string by putting all the substitution expressions in braces
right beside each other, and generate the space between columns with a 
larger field width.


.. index:: 
   double: ASCII; example
   
.. _ASCII:

Here is a reverse lookup from the 
:ref:`Numeric Code of String Characters <codeofstringchar>`:  
Find the characters for a list of numeric codes. Just as we can cast a
``char`` to an ``int``, we can cast an ``int`` 0-127 to a ``char``.

The Unicode used
by C# is an extension of the ASCII codes corresponding to the
characters on a US keyboard.  The codes were originally 
used to drive printers,
and the first 32 codes are non-printable instructions to the printer.
Characters 32 - 126 yield the 95 characters on a standard US keyboard.

A loop to print each code followed by a space and the corresponding 
printable character
would be::

   for (int i = 32; i < 127; i++) {
      Console.WriteLine("{0,3} {1}", i, (char)i);
   }

To make all the character line up we added a field width 3 for the code column.

If you run  this in csharp, 
the first line printed does not appear to have a character:  That is the
blank character.  All the other characters are visible.

Let us make a more concise table, putting 8 entries per line.
We can print successive parts use ``Write`` not ``WriteLine``,
but we still need to advance to the next line after every 8th
entry, for 39, 47, 55, ....
Since they are 8 apart, their remainder when divided by 8 is always
the same:  

    7 = 39 % 8 = 47 % 8 = 55 % 8 = ....

We can add a newline after each of these is printed.  This requires a test::

   for (int i = 32; i < 127; i++) {
      Console.Write("{0, 3} {1}  ", i, (char)i);
      if (i % 8 == 7) {
         Console.WriteLine();
      }
   }

Paste that whole code at once into csharp to see the result.

The next csharp> prompt appears right after ``126 ~``.  
There is no eighth entry on the last line, and hence no advance to the
next line.  A program printing this table should include an extra 
``Console.WriteLine()`` after the loop.

.. todo::

   Do some of these examples backwards.

.. todo::

   Reversing a string...

.. todo::

   Palindrome

.. todo::
   ASCII art, triangles; see for loop lab.

.. todo::
   Repeat string N times.  part a, just printed, part b: return a string

.. todo::
   Make restructured text table with fixed rows, columns, and width empty content.


Head or Tails Exercise
~~~~~~~~~~~~~~~~~~~~~~

Write a program ``HeadsTails.cs``. It should include a function ``Flip()``,
that will randomly prints ``Heads`` or ``Tails``.
Accomplish this by choosing 0 or 1 arbitrarily with a random
number generator.  Recall in :ref:`lab-number-game`::

  Random r = new Random();
  
Then, for ``int``\ s ``low`` and ``higher``, with ``low < higher``::
 
    int n = r.Next(low, higher);

returns a (pseudo) random ``int``, satisfying ``low <= n < higher``.
If you select ``low`` and ``higher`` so there are only two possible values
for n,
then you can choose to print ``Heads`` or ``Tails`` with an
|if-else| statement based on the result.
	
In your Main method have a ``for`` loop calling  ``Flip()``
10 times to test it, so you generate a random sequence of 
10 ``Heads`` and/or
``Tails``.

